{"version":3,"sources":["node_modules/eslint/lib/rules/utils/ast-utils.js","node_modules/eslint/lib/rules/accessor-pairs.js","node_modules/eslint/lib/rules/array-bracket-newline.js","node_modules/eslint/lib/rules/array-bracket-spacing.js","node_modules/eslint/lib/rules/array-callback-return.js","node_modules/eslint/lib/rules/array-element-newline.js","node_modules/eslint/lib/rules/arrow-body-style.js","node_modules/eslint/lib/rules/arrow-parens.js","node_modules/eslint/lib/rules/arrow-spacing.js","node_modules/eslint/lib/rules/block-scoped-var.js","node_modules/eslint/lib/rules/block-spacing.js","node_modules/eslint/lib/rules/brace-style.js","node_modules/eslint/lib/rules/callback-return.js","node_modules/eslint/lib/rules/camelcase.js","node_modules/eslint/lib/rules/utils/patterns/letters.js","node_modules/eslint/lib/rules/capitalized-comments.js","node_modules/eslint/lib/rules/class-methods-use-this.js","node_modules/eslint/lib/rules/comma-dangle.js","node_modules/eslint/lib/rules/comma-spacing.js","node_modules/eslint/lib/rules/comma-style.js","node_modules/eslint/lib/rules/complexity.js","node_modules/eslint/lib/rules/computed-property-spacing.js","node_modules/eslint/lib/rules/consistent-return.js","node_modules/eslint/lib/rules/consistent-this.js","node_modules/eslint/lib/rules/constructor-super.js","node_modules/eslint/lib/rules/curly.js","node_modules/eslint/lib/rules/default-case-last.js","node_modules/eslint/lib/rules/default-case.js","node_modules/eslint/lib/rules/default-param-last.js","node_modules/eslint/lib/rules/dot-location.js","node_modules/eslint/lib/rules/utils/keywords.js","node_modules/eslint/lib/rules/dot-notation.js","node_modules/eslint/lib/rules/eol-last.js","node_modules/eslint/lib/rules/eqeqeq.js","node_modules/eslint/lib/rules/for-direction.js","node_modules/eslint/lib/rules/func-call-spacing.js","node_modules/eslint/lib/rules/func-name-matching.js","node_modules/eslint/lib/rules/func-names.js","node_modules/eslint/lib/rules/func-style.js","node_modules/eslint/lib/rules/function-call-argument-newline.js","node_modules/eslint/lib/rules/function-paren-newline.js","node_modules/eslint/lib/rules/generator-star-spacing.js","node_modules/eslint/lib/rules/getter-return.js","node_modules/eslint/lib/rules/global-require.js","node_modules/eslint/lib/rules/grouped-accessor-pairs.js","node_modules/eslint/lib/rules/guard-for-in.js","node_modules/eslint/lib/rules/handle-callback-err.js","node_modules/eslint/lib/rules/id-blacklist.js","node_modules/eslint/lib/rules/id-denylist.js","node_modules/eslint/lib/rules/id-length.js","node_modules/eslint/lib/rules/id-match.js","node_modules/eslint/lib/rules/implicit-arrow-linebreak.js","node_modules/eslint/lib/rules/indent-legacy.js","node_modules/eslint/lib/rules/indent.js","node_modules/eslint/lib/rules/init-declarations.js","node_modules/eslint/lib/rules/jsx-quotes.js","node_modules/eslint/lib/rules/key-spacing.js","node_modules/eslint/lib/rules/keyword-spacing.js","node_modules/eslint/lib/rules/line-comment-position.js","node_modules/eslint/lib/rules/linebreak-style.js","node_modules/eslint/lib/rules/lines-around-comment.js","node_modules/eslint/lib/rules/lines-around-directive.js","node_modules/eslint/lib/rules/lines-between-class-members.js","node_modules/eslint/lib/rules/max-classes-per-file.js","node_modules/eslint/lib/rules/max-depth.js","node_modules/eslint/lib/rules/max-len.js","node_modules/eslint/lib/rules/max-lines-per-function.js","node_modules/eslint/lib/rules/max-lines.js","node_modules/eslint/lib/rules/max-nested-callbacks.js","node_modules/eslint/lib/rules/max-params.js","node_modules/eslint/lib/rules/max-statements-per-line.js","node_modules/eslint/lib/rules/max-statements.js","node_modules/eslint/lib/rules/multiline-comment-style.js","node_modules/eslint/lib/rules/multiline-ternary.js","node_modules/eslint/lib/rules/new-cap.js","node_modules/eslint/lib/rules/new-parens.js","node_modules/eslint/lib/rules/newline-after-var.js","node_modules/eslint/lib/rules/newline-before-return.js","node_modules/eslint/lib/rules/newline-per-chained-call.js","node_modules/eslint/lib/rules/no-alert.js","node_modules/eslint/lib/rules/no-array-constructor.js","node_modules/eslint/lib/rules/no-async-promise-executor.js","node_modules/eslint/lib/rules/no-await-in-loop.js","node_modules/eslint/lib/rules/no-bitwise.js","node_modules/eslint/lib/rules/no-buffer-constructor.js","node_modules/eslint/lib/rules/no-caller.js","node_modules/eslint/lib/rules/no-case-declarations.js","node_modules/eslint/lib/rules/no-catch-shadow.js","node_modules/eslint/lib/rules/no-class-assign.js","node_modules/eslint/lib/rules/no-compare-neg-zero.js","node_modules/eslint/lib/rules/no-cond-assign.js","node_modules/eslint/lib/rules/no-confusing-arrow.js","node_modules/eslint/lib/rules/no-console.js","node_modules/eslint/lib/rules/no-const-assign.js","node_modules/eslint/lib/rules/no-constant-condition.js","node_modules/eslint/lib/rules/no-constructor-return.js","node_modules/eslint/lib/rules/no-continue.js","node_modules/eslint/lib/rules/no-control-regex.js","node_modules/eslint/lib/rules/no-debugger.js","node_modules/eslint/lib/rules/no-delete-var.js","node_modules/eslint/lib/rules/no-div-regex.js","node_modules/eslint/lib/rules/no-dupe-args.js","node_modules/eslint/lib/rules/no-dupe-class-members.js","node_modules/eslint/lib/rules/no-dupe-else-if.js","node_modules/eslint/lib/rules/no-dupe-keys.js","node_modules/eslint/lib/rules/no-duplicate-case.js","node_modules/eslint/lib/rules/no-duplicate-imports.js","node_modules/eslint/lib/rules/utils/fix-tracker.js","node_modules/eslint/lib/rules/no-else-return.js","node_modules/eslint/lib/rules/no-empty-character-class.js","node_modules/eslint/lib/rules/no-empty-function.js","node_modules/eslint/lib/rules/no-empty-pattern.js","node_modules/eslint/lib/rules/no-empty.js","node_modules/eslint/lib/rules/no-eq-null.js","node_modules/eslint/lib/rules/no-eval.js","node_modules/eslint/lib/rules/no-ex-assign.js","node_modules/eslint/lib/rules/no-extend-native.js","node_modules/eslint/lib/rules/no-extra-bind.js","node_modules/eslint/lib/rules/no-extra-boolean-cast.js","node_modules/eslint/lib/rules/no-extra-label.js","node_modules/eslint/lib/rules/no-extra-parens.js","node_modules/eslint/lib/rules/no-extra-semi.js","node_modules/eslint/lib/rules/no-fallthrough.js","node_modules/eslint/lib/rules/no-floating-decimal.js","node_modules/eslint/lib/rules/no-func-assign.js","node_modules/eslint/lib/rules/no-global-assign.js","node_modules/eslint/lib/rules/no-implicit-coercion.js","node_modules/eslint/lib/rules/no-implicit-globals.js","node_modules/eslint/lib/rules/no-implied-eval.js","node_modules/eslint/lib/rules/no-import-assign.js","node_modules/eslint/lib/rules/no-inline-comments.js","node_modules/eslint/lib/rules/no-inner-declarations.js","node_modules/eslint/lib/rules/no-invalid-regexp.js","node_modules/eslint/lib/rules/no-invalid-this.js","node_modules/eslint/lib/rules/no-irregular-whitespace.js","node_modules/eslint/lib/rules/no-iterator.js","node_modules/eslint/lib/rules/no-label-var.js","node_modules/eslint/lib/rules/no-labels.js","node_modules/eslint/lib/rules/no-lone-blocks.js","node_modules/eslint/lib/rules/no-lonely-if.js","node_modules/eslint/lib/rules/no-loop-func.js","node_modules/eslint/lib/rules/no-loss-of-precision.js","node_modules/eslint/lib/rules/no-magic-numbers.js","node_modules/eslint/lib/rules/utils/unicode/is-combining-character.js","node_modules/eslint/lib/rules/utils/unicode/is-emoji-modifier.js","node_modules/eslint/lib/rules/utils/unicode/is-regional-indicator-symbol.js","node_modules/eslint/lib/rules/utils/unicode/is-surrogate-pair.js","node_modules/eslint/lib/rules/utils/unicode/index.js","node_modules/eslint/lib/rules/no-misleading-character-class.js","node_modules/eslint/lib/rules/no-mixed-operators.js","node_modules/eslint/lib/rules/no-mixed-requires.js","node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js","node_modules/eslint/lib/rules/no-multi-assign.js","node_modules/eslint/lib/rules/no-multi-spaces.js","node_modules/eslint/lib/rules/no-multi-str.js","node_modules/eslint/lib/rules/no-multiple-empty-lines.js","node_modules/eslint/lib/rules/no-native-reassign.js","node_modules/eslint/lib/rules/no-negated-condition.js","node_modules/eslint/lib/rules/no-negated-in-lhs.js","node_modules/eslint/lib/rules/no-nested-ternary.js","node_modules/eslint/lib/rules/no-new-func.js","node_modules/eslint/lib/rules/no-new-object.js","node_modules/eslint/lib/rules/no-new-require.js","node_modules/eslint/lib/rules/no-new-symbol.js","node_modules/eslint/lib/rules/no-new-wrappers.js","node_modules/eslint/lib/rules/no-new.js","node_modules/eslint/lib/rules/no-nonoctal-decimal-escape.js","node_modules/eslint/lib/rules/no-obj-calls.js","node_modules/eslint/lib/rules/no-octal-escape.js","node_modules/eslint/lib/rules/no-octal.js","node_modules/eslint/lib/rules/no-param-reassign.js","node_modules/eslint/lib/rules/no-path-concat.js","node_modules/eslint/lib/rules/no-plusplus.js","node_modules/eslint/lib/rules/no-process-env.js","node_modules/eslint/lib/rules/no-process-exit.js","node_modules/eslint/lib/rules/no-promise-executor-return.js","node_modules/eslint/lib/rules/no-proto.js","node_modules/eslint/lib/rules/no-prototype-builtins.js","node_modules/eslint/lib/rules/no-redeclare.js","node_modules/eslint/lib/rules/no-regex-spaces.js","node_modules/eslint/lib/rules/no-restricted-exports.js","node_modules/eslint/lib/rules/no-restricted-globals.js","node_modules/eslint/lib/rules/no-restricted-imports.js","node_modules/eslint/lib/rules/no-restricted-modules.js","node_modules/eslint/lib/rules/no-restricted-properties.js","node_modules/eslint/lib/rules/no-restricted-syntax.js","node_modules/eslint/lib/rules/no-return-assign.js","node_modules/eslint/lib/rules/no-return-await.js","node_modules/eslint/lib/rules/no-script-url.js","node_modules/eslint/lib/rules/no-self-assign.js","node_modules/eslint/lib/rules/no-self-compare.js","node_modules/eslint/lib/rules/no-sequences.js","node_modules/eslint/lib/rules/no-setter-return.js","node_modules/eslint/lib/rules/no-shadow-restricted-names.js","node_modules/eslint/lib/rules/no-shadow.js","node_modules/eslint/lib/rules/no-spaced-func.js","node_modules/eslint/lib/rules/no-sparse-arrays.js","node_modules/eslint/lib/rules/no-sync.js","node_modules/eslint/lib/rules/no-tabs.js","node_modules/eslint/lib/rules/no-template-curly-in-string.js","node_modules/eslint/lib/rules/no-ternary.js","node_modules/eslint/lib/rules/no-this-before-super.js","node_modules/eslint/lib/rules/no-throw-literal.js","node_modules/eslint/lib/rules/no-trailing-spaces.js","node_modules/eslint/lib/rules/no-undef-init.js","node_modules/eslint/lib/rules/no-undef.js","node_modules/eslint/lib/rules/no-undefined.js","node_modules/eslint/lib/rules/no-underscore-dangle.js","node_modules/eslint/lib/rules/no-unexpected-multiline.js","node_modules/eslint/lib/rules/no-unmodified-loop-condition.js","node_modules/eslint/lib/rules/no-unneeded-ternary.js","node_modules/eslint/lib/rules/no-unreachable-loop.js","node_modules/eslint/lib/rules/no-unreachable.js","node_modules/eslint/lib/rules/no-unsafe-finally.js","node_modules/eslint/lib/rules/no-unsafe-negation.js","node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js","node_modules/eslint/lib/rules/no-unused-expressions.js","node_modules/eslint/lib/rules/no-unused-labels.js","node_modules/eslint/lib/rules/no-unused-vars.js","node_modules/eslint/lib/rules/no-use-before-define.js","node_modules/eslint/lib/rules/no-useless-backreference.js","node_modules/eslint/lib/rules/no-useless-call.js","node_modules/eslint/lib/rules/no-useless-catch.js","node_modules/eslint/lib/rules/no-useless-computed-key.js","node_modules/eslint/lib/rules/no-useless-concat.js","node_modules/eslint/lib/rules/no-useless-constructor.js","node_modules/eslint/lib/rules/no-useless-escape.js","node_modules/eslint/lib/rules/no-useless-rename.js","node_modules/eslint/lib/rules/no-useless-return.js","node_modules/eslint/lib/rules/no-var.js","node_modules/eslint/lib/rules/no-void.js","node_modules/eslint/lib/rules/no-warning-comments.js","node_modules/eslint/lib/rules/no-whitespace-before-property.js","node_modules/eslint/lib/rules/no-with.js","node_modules/eslint/lib/rules/nonblock-statement-body-position.js","node_modules/eslint/lib/rules/object-curly-newline.js","node_modules/eslint/lib/rules/object-curly-spacing.js","node_modules/eslint/lib/rules/object-property-newline.js","node_modules/eslint/lib/rules/object-shorthand.js","node_modules/eslint/lib/rules/one-var-declaration-per-line.js","node_modules/eslint/lib/rules/one-var.js","node_modules/eslint/lib/rules/operator-assignment.js","node_modules/eslint/lib/rules/operator-linebreak.js","node_modules/eslint/lib/rules/padded-blocks.js","node_modules/eslint/lib/rules/padding-line-between-statements.js","node_modules/eslint/lib/rules/prefer-arrow-callback.js","node_modules/eslint/lib/rules/prefer-const.js","node_modules/eslint/lib/rules/prefer-destructuring.js","node_modules/eslint/lib/rules/prefer-exponentiation-operator.js","node_modules/eslint/lib/rules/prefer-named-capture-group.js","node_modules/eslint/lib/rules/prefer-numeric-literals.js","node_modules/eslint/lib/rules/prefer-object-spread.js","node_modules/eslint/lib/rules/prefer-promise-reject-errors.js","node_modules/eslint/lib/rules/prefer-reflect.js","node_modules/eslint/lib/rules/prefer-regex-literals.js","node_modules/eslint/lib/rules/prefer-rest-params.js","node_modules/eslint/lib/rules/prefer-spread.js","node_modules/eslint/lib/rules/prefer-template.js","node_modules/eslint/lib/rules/quote-props.js","node_modules/eslint/lib/rules/quotes.js","node_modules/eslint/lib/rules/radix.js","node_modules/eslint/lib/rules/require-atomic-updates.js","node_modules/eslint/lib/rules/require-await.js","node_modules/eslint/lib/rules/require-jsdoc.js","node_modules/eslint/lib/rules/require-unicode-regexp.js","node_modules/eslint/lib/rules/require-yield.js","node_modules/eslint/lib/rules/rest-spread-spacing.js","node_modules/eslint/lib/rules/semi-spacing.js","node_modules/eslint/lib/rules/semi-style.js","node_modules/eslint/lib/rules/semi.js","node_modules/eslint/lib/rules/sort-imports.js","node_modules/eslint/lib/rules/sort-keys.js","node_modules/eslint/lib/rules/sort-vars.js","node_modules/eslint/lib/rules/space-before-blocks.js","node_modules/eslint/lib/rules/space-before-function-paren.js","node_modules/eslint/lib/rules/space-in-parens.js","node_modules/eslint/lib/rules/space-infix-ops.js","node_modules/eslint/lib/rules/space-unary-ops.js","node_modules/eslint/lib/rules/spaced-comment.js","node_modules/eslint/lib/rules/strict.js","node_modules/eslint/lib/rules/switch-colon-spacing.js","node_modules/eslint/lib/rules/symbol-description.js","node_modules/eslint/lib/rules/template-curly-spacing.js","node_modules/eslint/lib/rules/template-tag-spacing.js","node_modules/eslint/lib/rules/unicode-bom.js","node_modules/eslint/lib/rules/use-isnan.js","node_modules/eslint/lib/rules/valid-jsdoc.js","node_modules/eslint/lib/rules/valid-typeof.js","node_modules/eslint/lib/rules/vars-on-top.js","node_modules/eslint/lib/rules/wrap-iife.js","node_modules/eslint/lib/rules/wrap-regex.js","node_modules/eslint/lib/rules/yield-star-spacing.js","node_modules/eslint/lib/rules/yoda.js","scripts/shim/core-rules.js"],"names":["require$$0","esutils","espree","lodash","areEqualTokenLists","areEqualKeys","isPropertyDescriptor","TARGET_NODE_TYPE","util","LETTER_PATTERN","DEFAULT_OPTIONS","normalizeOptions","isConstructorFunction","isFunctionName","findReference","isShadowed","isAssignmentTarget","isRenamedImport","isRenamedInDestructuring","isShorthandPropertyDefinition","createTree","isInitialized","QUOTE_SETTINGS","OPTIONS_SCHEMA","OPTIONS_OR_INTEGER_SCHEMA","getPropertyName","BITWISE_OPERATORS","RegExpValidator","globals","eslintUtils","parseOptions","findVariable","getStaticPropertyName","require$$3","getStringIfConstant","visitRegExpAST","require$$1","ReferenceTracker","isGlobalReference","getOuterScope","regexpp","arrayOfStrings","arrayOfStringsOrObjects","ignore","SENTINEL_TYPE","isInRange","Traverser","parser","isValidThisArg","isConcatenation","getVariableOfArguments","isStaticTemplateLiteral","naturalCompare","doctrine","_283"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\nconst espree = require(\"espree\");\nconst lodash = require(\"lodash\");\nconst {\n    breakableTypePattern,\n    createGlobalLinebreakMatcher,\n    lineBreakPattern,\n    shebangPattern\n} = require(\"../../shared/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n\nconst DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u;\n\n// Tests the presence of at least one LegacyOctalEscapeSequence or NonOctalDecimalEscapeSequence in a raw string\nconst OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su;\n\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference A reference to check.\n * @param {int} index The index of the reference in the references.\n * @param {Reference[]} references The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n * @param {string} s The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node A function node to check.\n * @returns {boolean} Whether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (anyFunctionPattern.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n * @param {ASTNode|null} node A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n        if (isLoop(currentNode)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Determines whether the given node is a `null` literal.\n * @param {ASTNode} node The node to check\n * @returns {boolean} `true` if the node is a `null` literal\n */\nfunction isNullLiteral(node) {\n\n    /*\n     * Checking `node.value === null` does not guarantee that a literal is a null literal.\n     * When parsing values that cannot be represented in the current environment (e.g. unicode\n     * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n     */\n    return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Returns the result of the string conversion applied to the evaluated value of the given expression node,\n * if it can be determined statically.\n *\n * This function returns a `string` value for all `Literal` nodes and simple `TemplateLiteral` nodes only.\n * In all other cases, this function returns `null`.\n * @param {ASTNode} node Expression node.\n * @returns {string|null} String value if it can be determined. Otherwise, `null`.\n */\nfunction getStaticStringValue(node) {\n    switch (node.type) {\n        case \"Literal\":\n            if (node.value === null) {\n                if (isNullLiteral(node)) {\n                    return String(node.value); // \"null\"\n                }\n                if (node.regex) {\n                    return `/${node.regex.pattern}/${node.regex.flags}`;\n                }\n                if (node.bigint) {\n                    return node.bigint;\n                }\n\n                // Otherwise, this is an unknown literal. The function will return null.\n\n            } else {\n                return String(node.value);\n            }\n            break;\n        case \"TemplateLiteral\":\n            if (node.expressions.length === 0 && node.quasis.length === 1) {\n                return node.quasis[0].value.cooked;\n            }\n            break;\n\n            // no default\n    }\n\n    return null;\n}\n\n/**\n * Gets the property name of a given node.\n * The node can be a MemberExpression, a Property, or a MethodDefinition.\n *\n * If the name is dynamic, this returns `null`.\n *\n * For examples:\n *\n *     a.b           // => \"b\"\n *     a[\"b\"]        // => \"b\"\n *     a['b']        // => \"b\"\n *     a[`b`]        // => \"b\"\n *     a[100]        // => \"100\"\n *     a[b]          // => null\n *     a[\"a\" + \"b\"]  // => null\n *     a[tag`b`]     // => null\n *     a[`${b}`]     // => null\n *\n *     let a = {b: 1}            // => \"b\"\n *     let a = {[\"b\"]: 1}        // => \"b\"\n *     let a = {['b']: 1}        // => \"b\"\n *     let a = {[`b`]: 1}        // => \"b\"\n *     let a = {[100]: 1}        // => \"100\"\n *     let a = {[b]: 1}          // => null\n *     let a = {[\"a\" + \"b\"]: 1}  // => null\n *     let a = {[tag`b`]: 1}     // => null\n *     let a = {[`${b}`]: 1}     // => null\n * @param {ASTNode} node The node to get.\n * @returns {string|null} The property name if static. Otherwise, null.\n */\nfunction getStaticPropertyName(node) {\n    let prop;\n\n    switch (node && node.type) {\n        case \"ChainExpression\":\n            return getStaticPropertyName(node.expression);\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            prop = node.key;\n            break;\n\n        case \"MemberExpression\":\n            prop = node.property;\n            break;\n\n            // no default\n    }\n\n    if (prop) {\n        if (prop.type === \"Identifier\" && !node.computed) {\n            return prop.name;\n        }\n\n        return getStaticStringValue(prop);\n    }\n\n    return null;\n}\n\n/**\n * Retrieve `ChainExpression#expression` value if the given node a `ChainExpression` node. Otherwise, pass through it.\n * @param {ASTNode} node The node to address.\n * @returns {ASTNode} The `ChainExpression#expression` value if the node is a `ChainExpression` node. Otherwise, the node.\n */\nfunction skipChainExpression(node) {\n    return node && node.type === \"ChainExpression\" ? node.expression : node;\n}\n\n/**\n * Check if the `actual` is an expected value.\n * @param {string} actual The string value to check.\n * @param {string | RegExp} expected The expected string value or pattern.\n * @returns {boolean} `true` if the `actual` is an expected value.\n */\nfunction checkText(actual, expected) {\n    return typeof expected === \"string\"\n        ? actual === expected\n        : expected.test(actual);\n}\n\n/**\n * Check if a given node is an Identifier node with a given name.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp} name The expected name or the expected pattern of the object name.\n * @returns {boolean} `true` if the node is an Identifier node with the name.\n */\nfunction isSpecificId(node, name) {\n    return node.type === \"Identifier\" && checkText(node.name, name);\n}\n\n/**\n * Check if a given node is member access with a given object name and property name pair.\n * This is regardless of optional or not.\n * @param {ASTNode} node The node to check.\n * @param {string | RegExp | null} objectName The expected name or the expected pattern of the object name. If this is nullish, this method doesn't check object.\n * @param {string | RegExp | null} propertyName The expected name or the expected pattern of the property name. If this is nullish, this method doesn't check property.\n * @returns {boolean} `true` if the node is member access with the object name and property name pair.\n * The node is a `MemberExpression` or `ChainExpression`.\n */\nfunction isSpecificMemberAccess(node, objectName, propertyName) {\n    const checkNode = skipChainExpression(node);\n\n    if (checkNode.type !== \"MemberExpression\") {\n        return false;\n    }\n\n    if (objectName && !isSpecificId(checkNode.object, objectName)) {\n        return false;\n    }\n\n    if (propertyName) {\n        const actualPropertyName = getStaticPropertyName(checkNode);\n\n        if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two literal nodes are the same value.\n * @param {ASTNode} left The Literal node to compare.\n * @param {ASTNode} right The other Literal node to compare.\n * @returns {boolean} `true` if the two literal nodes are the same value.\n */\nfunction equalLiteralValue(left, right) {\n\n    // RegExp literal.\n    if (left.regex || right.regex) {\n        return Boolean(\n            left.regex &&\n            right.regex &&\n            left.regex.pattern === right.regex.pattern &&\n            left.regex.flags === right.regex.flags\n        );\n    }\n\n    // BigInt literal.\n    if (left.bigint || right.bigint) {\n        return left.bigint === right.bigint;\n    }\n\n    return left.value === right.value;\n}\n\n/**\n * Check if two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param {ASTNode} left The left side of the comparison.\n * @param {ASTNode} right The right side of the comparison.\n * @param {boolean} [disableStaticComputedKey] Don't address `a.b` and `a[\"b\"]` are the same if `true`. For backward compatibility.\n * @returns {boolean} `true` if both sides match and reference the same value.\n */\nfunction isSameReference(left, right, disableStaticComputedKey = false) {\n    if (left.type !== right.type) {\n\n        // Handle `a.b` and `a?.b` are samely.\n        if (left.type === \"ChainExpression\") {\n            return isSameReference(left.expression, right, disableStaticComputedKey);\n        }\n        if (right.type === \"ChainExpression\") {\n            return isSameReference(left, right.expression, disableStaticComputedKey);\n        }\n\n        return false;\n    }\n\n    switch (left.type) {\n        case \"Super\":\n        case \"ThisExpression\":\n            return true;\n\n        case \"Identifier\":\n            return left.name === right.name;\n        case \"Literal\":\n            return equalLiteralValue(left, right);\n\n        case \"ChainExpression\":\n            return isSameReference(left.expression, right.expression, disableStaticComputedKey);\n\n        case \"MemberExpression\": {\n            if (!disableStaticComputedKey) {\n                const nameA = getStaticPropertyName(left);\n\n                // x.y = x[\"y\"]\n                if (nameA !== null) {\n                    return (\n                        isSameReference(left.object, right.object, disableStaticComputedKey) &&\n                        nameA === getStaticPropertyName(right)\n                    );\n                }\n            }\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return (\n                left.computed === right.computed &&\n                isSameReference(left.object, right.object, disableStaticComputedKey) &&\n                isSameReference(left.property, right.property, disableStaticComputedKey)\n            );\n        }\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, \"from\");\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    return isSpecificMemberAccess(node, null, arrayMethodPattern);\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node A node to check.\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a dot token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a dot token.\n */\nfunction isDotToken(token) {\n    return token.value === \".\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a `?.` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `?.` token.\n */\nfunction isQuestionDotToken(token) {\n    return token.value === \"?.\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n * @param {ASTNode} node The function node to get.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left A node 1 to compare.\n * @param {ASTNode} right A node 2 to compare.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if the given node is a true logical expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function rejects coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `&&` or `||`.\n * @see https://tc39.es/ecma262/#prod-ShortCircuitExpression\n */\nfunction isLogicalExpression(node) {\n    return (\n        node.type === \"LogicalExpression\" &&\n            (node.operator === \"&&\" || node.operator === \"||\")\n    );\n}\n\n/**\n * Check if the given node is a nullish coalescing expression or not.\n *\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\n * coalesce (`??`) are known as `ShortCircuitExpression`.\n * But ESTree represents those by `LogicalExpression` node.\n *\n * This function finds only coalesce expressions of `LogicalExpression` node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `??`.\n */\nfunction isCoalesceExpression(node) {\n    return node.type === \"LogicalExpression\" && node.operator === \"??\";\n}\n\n/**\n * Check if given two nodes are the pair of a logical expression and a coalesce expression.\n * @param {ASTNode} left A node to check.\n * @param {ASTNode} right Another node to check.\n * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.\n */\nfunction isMixedLogicalAndCoalesceExpressions(left, right) {\n    return (\n        (isLogicalExpression(left) && isCoalesceExpression(right)) ||\n            (isCoalesceExpression(left) && isLogicalExpression(right))\n    );\n}\n\n/**\n * Checks if the given operator is a logical assignment operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} `true` if the operator is a logical assignment operator.\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER: lineBreakPattern,\n    SHEBANG_MATCHER: shebangPattern,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left The left token object.\n     * @param {Object} right The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n    equalTokens,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isDotToken,\n    isQuestionDotToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotDotToken: negate(isDotToken),\n    isNotQuestionDotToken: negate(isQuestionDotToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     * @param {ASTNode} node A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {Line|Block} node The comment token to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     * @param {eslint-scope.Scope} initScope A scope to start find.\n     * @param {string} name A variable name to find.\n     * @returns {eslint-scope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase. It's a convention to capitalize the names\n     *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\n     *   functions only, as the name of the variable is considered to be the name of the function in this case.\n     *   This check is not performed if `capIsConstructor` is set to `false`.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     * @param {ASTNode} node A function node to check.\n     * @param {SourceCode} sourceCode A SourceCode instance to get comments.\n     * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\n     * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode, { capIsConstructor = true } = {}) {\n        if (\n            (capIsConstructor && isES5Constructor(node)) ||\n            hasJSDocThisTag(node, sourceCode)\n        ) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n        let currentNode = node;\n\n        while (currentNode) {\n            const parent = currentNode.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                case \"ChainExpression\":\n                    currentNode = parent;\n                    break;\n\n                /*\n                 * If the upper function is IIFE, checks the destination of the return value.\n                 * e.g.\n                 *   obj.foo = (function() {\n                 *     // setup...\n                 *     return function foo() { ... };\n                 *   })();\n                 *   obj.foo = (() =>\n                 *     function foo() { ... }\n                 *   )();\n                 */\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    currentNode = func.parent;\n                    break;\n                }\n                case \"ArrowFunctionExpression\":\n                    if (currentNode !== parent.body || !isCallee(parent)) {\n                        return true;\n                    }\n                    currentNode = parent.parent;\n                    break;\n\n                /*\n                 * e.g.\n                 *   var obj = { foo() { ... } };\n                 *   var obj = { foo: function() { ... } };\n                 *   class A { constructor() { ... } }\n                 *   class A { foo() { ... } }\n                 *   class A { get foo() { ... } }\n                 *   class A { set foo() { ... } }\n                 *   class A { static foo() { ... } }\n                 */\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== currentNode;\n\n                /*\n                 * e.g.\n                 *   obj.foo = function foo() { ... };\n                 *   Foo = function() { ... };\n                 *   [obj.foo = function foo() { ... }] = a;\n                 *   [Foo = function() { ... }] = a;\n                 */\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.left.type === \"MemberExpression\") {\n                        return false;\n                    }\n                    if (\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.left.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.left.name)\n                    ) {\n                        return false;\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   var Foo = function() { ... };\n                 */\n                case \"VariableDeclarator\":\n                    return !(\n                        capIsConstructor &&\n                        isAnonymous &&\n                        parent.init === currentNode &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                /*\n                 * e.g.\n                 *   var foo = function foo() { ... }.bind(obj);\n                 *   (function foo() { ... }).call(obj);\n                 *   (function foo() { ... }).apply(obj, []);\n                 */\n                case \"MemberExpression\":\n                    if (\n                        parent.object === currentNode &&\n                        isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)\n                    ) {\n                        const maybeCalleeNode = parent.parent.type === \"ChainExpression\"\n                            ? parent.parent\n                            : parent;\n\n                        return !(\n                            isCallee(maybeCalleeNode) &&\n                            maybeCalleeNode.parent.arguments.length >= 1 &&\n                            !isNullOrUndefined(maybeCalleeNode.parent.arguments[0])\n                        );\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   Reflect.apply(function() {}, obj, []);\n                 *   Array.from([], function() {}, obj);\n                 *   list.forEach(function() {}, obj);\n                 */\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                    case \"??\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n            case \"ChainExpression\":\n            case \"ImportExpression\":\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            default:\n                return 20;\n        }\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     * @param {ASTNode|null} node The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            /*\n             * Do not check arrow functions with implicit return.\n             * `() => \"use strict\";` returns the string `\"use strict\"`.\n             */\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     * after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 0         // true\n     * 5         // true\n     * 50        // true\n     * 5_000     // true\n     * 1_234_56  // true\n     * 08        // true\n     * 0192      // true\n     * 5.        // false\n     * .5        // false\n     * 5.0       // false\n     * 5.00_00   // false\n     * 05        // false\n     * 0x5       // false\n     * 0b101     // false\n     * 0b11_01   // false\n     * 0o5       // false\n     * 5e0       // false\n     * 5e1_000   // false\n     * 5n        // false\n     * 1_000n    // false\n     * '5'       // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" &&\n            DECIMAL_INTEGER_PATTERN.test(node.raw);\n    },\n\n    /**\n     * Determines whether this token is a decimal integer numeric token.\n     * This is similar to isDecimalInteger(), but for tokens.\n     * @param {Token} token The token to check.\n     * @returns {boolean} `true` if this token is a decimal integer.\n     */\n    isDecimalIntegerNumericToken(token) {\n        return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     * @param {ASTNode} node The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" && parent.static) {\n            tokens.push(\"static\");\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\", \"function\");\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            }\n            if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else {\n            tokens.push(\"function\");\n        }\n\n        if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        } else {\n            const name = getStaticPropertyName(parent);\n\n            if (name !== null) {\n                tokens.push(`'${name}'`);\n            }\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     * @param {ASTNode} node The function node to get.\n     * @param {SourceCode} sourceCode The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n     * Gets next location when the result is not out of bound, otherwise returns null.\n     *\n     * Assumptions:\n     *\n     * - The given location represents a valid location in the given source code.\n     * - Columns are 0-based.\n     * - Lines are 1-based.\n     * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.\n     * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.\n     *   The start (column 0) of that extra line is considered to be a valid location.\n     *\n     * Examples of successive locations (line, column):\n     *\n     * code: foo\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null\n     *\n     * code: foo<LF>\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n     *\n     * code: foo<CR><LF>\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\n     *\n     * code: a<LF>b\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null\n     *\n     * code: a<LF>b<LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n     *\n     * code: a<CR><LF>b<CR><LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\n     *\n     * code: a<LF><LF>\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null\n     *\n     * code: <LF>\n     * locations: (1, 0) -> (2, 0) -> null\n     *\n     * code:\n     * locations: (1, 0) -> null\n     * @param {SourceCode} sourceCode The sourceCode\n     * @param {{line: number, column: number}} location The location\n     * @returns {{line: number, column: number} | null} Next location\n     */\n    getNextLocation(sourceCode, { line, column }) {\n        if (column < sourceCode.lines[line - 1].length) {\n            return {\n                line,\n                column: column + 1\n            };\n        }\n\n        if (line < sourceCode.lines.length) {\n            return {\n                line: line + 1,\n                column: 0\n            };\n        }\n\n        return null;\n    },\n\n    /**\n     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n     * surrounding the node.\n     * @param {SourceCode} sourceCode The source code object\n     * @param {ASTNode} node An expression node\n     * @returns {string} The text representing the node, with all surrounding parentheses included\n     */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /*\n     * Determine if a node has a possibility to be an Error object\n     * @param  {ASTNode} node  ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n            case \"ChainExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                if ([\"=\", \"&&=\"].includes(node.operator)) {\n                    return module.exports.couldBeError(node.right);\n                }\n\n                if ([\"||=\", \"??=\"].includes(node.operator)) {\n                    return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n                }\n\n                /**\n                 * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n                 * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n                 * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.\n                 */\n                return false;\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n\n                /*\n                 * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it\n                 * doesn't short-circuit, it takes the value from the right side, so the right side must always be\n                 * a plausible error. A future improvement could verify that the left side could be truthy by\n                 * excluding falsy literals.\n                 */\n                if (node.operator === \"&&\") {\n                    return module.exports.couldBeError(node.right);\n                }\n\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Check if a given node is a numeric literal or not.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is a number or bigint literal.\n     */\n    isNumericLiteral(node) {\n        return (\n            node.type === \"Literal\" &&\n            (typeof node.value === \"number\" || Boolean(node.bigint))\n        );\n    },\n\n    /**\n     * Determines whether two tokens can safely be placed next to each other without merging into a single token\n     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n     * next to each other, behavior is undefined (although it should return `true` in most cases).\n     */\n    canTokensBeAdjacent(leftValue, rightValue) {\n        const espreeOptions = {\n            ecmaVersion: espree.latestEcmaVersion,\n            comment: true,\n            range: true\n        };\n\n        let leftToken;\n\n        if (typeof leftValue === \"string\") {\n            let tokens;\n\n            try {\n                tokens = espree.tokenize(leftValue, espreeOptions);\n            } catch {\n                return false;\n            }\n\n            const comments = tokens.comments;\n\n            leftToken = tokens[tokens.length - 1];\n            if (comments.length) {\n                const lastComment = comments[comments.length - 1];\n\n                if (lastComment.range[0] > leftToken.range[0]) {\n                    leftToken = lastComment;\n                }\n            }\n        } else {\n            leftToken = leftValue;\n        }\n\n        if (leftToken.type === \"Shebang\") {\n            return false;\n        }\n\n        let rightToken;\n\n        if (typeof rightValue === \"string\") {\n            let tokens;\n\n            try {\n                tokens = espree.tokenize(rightValue, espreeOptions);\n            } catch {\n                return false;\n            }\n\n            const comments = tokens.comments;\n\n            rightToken = tokens[0];\n            if (comments.length) {\n                const firstComment = comments[0];\n\n                if (firstComment.range[0] < rightToken.range[0]) {\n                    rightToken = firstComment;\n                }\n            }\n        } else {\n            rightToken = rightValue;\n        }\n\n        if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n            if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n                const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n                const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n\n                return !(\n                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||\n                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)\n                );\n            }\n            if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\n                return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\n            }\n            return true;\n        }\n\n        if (\n            leftToken.type === \"String\" || rightToken.type === \"String\" ||\n            leftToken.type === \"Template\" || rightToken.type === \"Template\"\n        ) {\n            return true;\n        }\n\n        if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n            return true;\n        }\n\n        if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\n            return true;\n        }\n\n        return false;\n    },\n\n    /**\n     * Get the `loc` object of a given name in a `/*globals` directive comment.\n     * @param {SourceCode} sourceCode The source code to convert index to loc.\n     * @param {Comment} comment The `/*globals` directive comment which include the name.\n     * @param {string} name The name to find.\n     * @returns {SourceLocation} The `loc` object.\n     */\n    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n        const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\");\n\n        // To ignore the first text \"global\".\n        namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n        // Search a given variable name.\n        const match = namePattern.exec(comment.value);\n\n        // Convert the index to loc.\n        const start = sourceCode.getLocFromIndex(\n            comment.range[0] +\n            \"/*\".length +\n            (match ? match.index + 1 : 0)\n        );\n        const end = {\n            line: start.line,\n            column: start.column + (match ? name.length : 1)\n        };\n\n        return { start, end };\n    },\n\n    /**\n     * Determines whether the given raw string contains an octal escape sequence\n     * or a non-octal decimal escape sequence (\"\\8\", \"\\9\").\n     *\n     * \"\\1\", \"\\2\" ... \"\\7\", \"\\8\", \"\\9\"\n     * \"\\00\", \"\\01\" ... \"\\07\", \"\\08\", \"\\09\"\n     *\n     * \"\\0\", when not followed by a digit, is not an octal escape sequence.\n     * @param {string} rawString A string in its raw representation.\n     * @returns {boolean} `true` if the string contains at least one octal escape sequence\n     * or at least one non-octal decimal escape sequence.\n     */\n    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\n        return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);\n    },\n\n    isLogicalExpression,\n    isCoalesceExpression,\n    isMixedLogicalAndCoalesceExpressions,\n    isNullLiteral,\n    getStaticStringValue,\n    getStaticPropertyName,\n    skipChainExpression,\n    isSpecificId,\n    isSpecificMemberAccess,\n    equalLiteralValue,\n    isSameReference,\n    isLogicalAssignmentOperator\n};\n","/**\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n\n    for (let i = 0; i < left.length; i++) {\n        const leftToken = left[i],\n            rightToken = right[i];\n\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\") {\n\n        // Statically computed names.\n        return left === right;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n\n        // Token lists.\n        return areEqualTokenLists(left, right);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node A node to check.\n * @param {number} index An expected index of the node in arguments.\n * @param {string} object An expected name of the object of the method.\n * @param {string} property An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(parent.callee, object, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    const grandparent = node.parent.parent;\n\n    return grandparent.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce getter and setter pairs in objects and classes\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/accessor-pairs\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\",\n                    default: false\n                },\n                setWithoutGet: {\n                    type: \"boolean\",\n                    default: true\n                },\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n            missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n            missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n            missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n            missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n            missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n        }\n    },\n    create(context) {\n        const config = context.options[0] || {};\n        const checkGetWithoutSet = config.getWithoutSet === true;\n        const checkSetWithoutGet = config.setWithoutGet !== false;\n        const enforceForClassMembers = config.enforceForClassMembers !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function report(node, messageKind) {\n            if (node.type === \"Property\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InObjectLiteral`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else if (node.type === \"MethodDefinition\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InClass`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InPropertyDescriptor`\n                });\n            }\n        }\n\n        /**\n         * Reports each of the nodes in the given list using the same messageId.\n         * @param {ASTNode[]} nodes Nodes to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function reportList(nodes, messageKind) {\n            for (const node of nodes) {\n                report(node, messageKind);\n            }\n        }\n\n        /**\n         * Creates a new `AccessorData` object for the given getter or setter node.\n         * @param {ASTNode} node A getter or setter node.\n         * @returns {AccessorData} New `AccessorData` object that contains the given node.\n         * @private\n         */\n        function createAccessorData(node) {\n            const name = astUtils.getStaticPropertyName(node);\n            const key = (name !== null) ? name : sourceCode.getTokens(node.key);\n\n            return {\n                key,\n                getters: node.kind === \"get\" ? [node] : [],\n                setters: node.kind === \"set\" ? [node] : []\n            };\n        }\n\n        /**\n         * Merges the given `AccessorData` object into the given accessors list.\n         * @param {AccessorData[]} accessors The list to merge into.\n         * @param {AccessorData} accessorData The object to merge.\n         * @returns {AccessorData[]} The same instance with the merged object.\n         * @private\n         */\n        function mergeAccessorData(accessors, accessorData) {\n            const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\n\n            if (equalKeyElement) {\n                equalKeyElement.getters.push(...accessorData.getters);\n                equalKeyElement.setters.push(...accessorData.setters);\n            } else {\n                accessors.push(accessorData);\n            }\n\n            return accessors;\n        }\n\n        /**\n         * Checks accessor pairs in the given list of nodes.\n         * @param {ASTNode[]} nodes The list to check.\n         * @returns {void}\n         * @private\n         */\n        function checkList(nodes) {\n            const accessors = nodes\n                .filter(isAccessorKind)\n                .map(createAccessorData)\n                .reduce(mergeAccessorData, []);\n\n            for (const { getters, setters } of accessors) {\n                if (checkSetWithoutGet && setters.length && !getters.length) {\n                    reportList(setters, \"missingGetter\");\n                }\n                if (checkGetWithoutSet && getters.length && !setters.length) {\n                    reportList(getters, \"missingSetter\");\n                }\n            }\n        }\n\n        /**\n         * Checks accessor pairs in an object literal.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectLiteral(node) {\n            checkList(node.properties.filter(p => p.type === \"Property\"));\n        }\n\n        /**\n         * Checks accessor pairs in a property descriptor.\n         * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkPropertyDescriptor(node) {\n            const namesToCheck = node.properties\n                .filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed)\n                .map(({ key }) => key.name);\n\n            const hasGetter = namesToCheck.includes(\"get\");\n            const hasSetter = namesToCheck.includes(\"set\");\n\n            if (checkSetWithoutGet && hasSetter && !hasGetter) {\n                report(node, \"missingGetter\");\n            }\n            if (checkGetWithoutSet && hasGetter && !hasSetter) {\n                report(node, \"missingSetter\");\n            }\n        }\n\n        /**\n         * Checks the given object expression as an object literal and as a possible property descriptor.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectExpression(node) {\n            checkObjectLiteral(node);\n            if (isPropertyDescriptor(node)) {\n                checkPropertyDescriptor(node);\n            }\n        }\n\n        /**\n         * Checks the given class body.\n         * @param {ASTNode} node `ClassBody` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkClassBody(node) {\n            const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n\n            checkList(methodDefinitions.filter(m => m.static));\n            checkList(methodDefinitions.filter(m => !m.static));\n        }\n\n        const listeners = {};\n\n        if (checkSetWithoutGet || checkGetWithoutSet) {\n            listeners.ObjectExpression = checkObjectExpression;\n            if (enforceForClassMembers) {\n                listeners.ClassBody = checkClassBody;\n            }\n        }\n\n        return listeners;\n    }\n};\n","/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} option An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    openBracket.loc.end.line !== first.loc.start.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of array brackets.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    singleValue: {\n                        type: \"boolean\"\n                    },\n                    objectsInArrays: {\n                        type: \"boolean\"\n                    },\n                    arraysInArrays: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n            unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n            missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\",\n            missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\"\n        }\n    },\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            singleElementException: isOptionSet(\"singleValue\"),\n            objectsInArraysException: isOptionSet(\"objectsInArrays\"),\n            arraysInArraysException: isOptionSet(\"arraysInArrays\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            context.report({\n                node,\n                loc: { start: token.loc.end, end: nextToken.loc.start },\n                messageId: \"unexpectedSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token) {\n            const previousToken = sourceCode.getTokenBefore(token);\n\n            context.report({\n                node,\n                loc: { start: previousToken.loc.end, end: token.loc.start },\n                messageId: \"unexpectedSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if a node is an object type\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node is an object type.\n         */\n        function isObjectType(node) {\n            return node && (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\");\n        }\n\n        /**\n         * Determines if a node is an array type\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node is an array type.\n         */\n        function isArrayType(node) {\n            return node && (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n        }\n\n        /**\n         * Validates the spacing around array brackets\n         * @param {ASTNode} node The node we're checking for spacing\n         * @returns {void}\n         */\n        function validateArraySpacing(node) {\n            if (options.spaced && node.elements.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                second = sourceCode.getFirstToken(node, 1),\n                last = node.typeAnnotation\n                    ? sourceCode.getTokenBefore(node.typeAnnotation)\n                    : sourceCode.getLastToken(node),\n                penultimate = sourceCode.getTokenBefore(last),\n                firstElement = node.elements[0],\n                lastElement = node.elements[node.elements.length - 1];\n\n            const openingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(firstElement) ||\n                options.arraysInArraysException && isArrayType(firstElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            const closingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(lastElement) ||\n                options.arraysInArraysException && isArrayType(lastElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {\n                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrayPattern: validateArraySpacing,\n            ArrayExpression: validateArraySpacing\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n        return \"Array.\".concat(arrayMethodName);\n    }\n    return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n            case \"ChainExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return null;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    ) {\n                        return \"from\";\n                    }\n                }\n                if (isTargetMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    ) {\n                        return astUtils.getStaticPropertyName(parent.callee);\n                    }\n                }\n                return null;\n\n            // Otherwise this node is not target.\n            default:\n                return null;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    checkForEach: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false, checkForEach: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            arrayMethodName: null,\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n\n            if (!funcInfo.shouldCheck) {\n                return;\n            }\n\n            let messageId = null;\n\n            if (funcInfo.arrayMethodName === \"forEach\") {\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n                    messageId = \"expectedNoReturnValue\";\n                }\n            } else {\n                if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n                    messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n                }\n            }\n\n            if (messageId) {\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId,\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n\n                let methodName = null;\n\n                if (TARGET_NODE_TYPE.test(node.type)) {\n                    methodName = getArrayMethodName(node);\n                }\n\n                funcInfo = {\n                    arrayMethodName: methodName,\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        methodName &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n\n                if (!funcInfo.shouldCheck) {\n                    return;\n                }\n\n                funcInfo.hasReturn = true;\n\n                let messageId = null;\n\n                if (funcInfo.arrayMethodName === \"forEach\") {\n\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n                    if (options.checkForEach && node.argument) {\n                        messageId = \"expectedNoReturnValue\";\n                    }\n                } else {\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        messageId = \"expectedReturnValue\";\n                    }\n                }\n\n                if (messageId) {\n                    context.report({\n                        node,\n                        messageId,\n                        data: {\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n                        }\n                    });\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                basicConfig: {\n                    oneOf: [\n                        {\n                            enum: [\"always\", \"never\", \"consistent\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                multiline: {\n                                    type: \"boolean\"\n                                },\n                                minItems: {\n                                    type: [\"integer\", \"null\"],\n                                    minimum: 0\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            },\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/basicConfig\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ArrayExpression: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                },\n                                ArrayPattern: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                }\n                            },\n                            additionalProperties: false,\n                            minProperties: 1\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} providedOption An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            if (options && (options.ArrayExpression || options.ArrayPattern)) {\n                let expressionOptions, patternOptions;\n\n                if (options.ArrayExpression) {\n                    expressionOptions = normalizeOptionValue(options.ArrayExpression);\n                }\n\n                if (options.ArrayPattern) {\n                    patternOptions = normalizeOptionValue(options.ArrayPattern);\n                }\n\n                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };\n            }\n\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            if (!options) {\n                return;\n            }\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const linebreaksCount = node.elements.map((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return false;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n            }).filter(isBreak => isBreak === true).length;\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis which is the pair of the given opening parenthesis.\n         * @param {Token} token The opening parenthesis token to get.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(token) {\n            let node = sourceCode.getNodeByRangeIndex(token.range[0]);\n\n            while (!astUtils.isParenthesised(sourceCode, node)) {\n                node = node.parent;\n            }\n            return sourceCode.getTokenAfter(node);\n        }\n\n        /**\n         * Check whether the node is inside of a for loop's init\n         * @param {ASTNode} node node is inside for loop\n         * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n         */\n        function isInsideForLoopInitializer(node) {\n            if (node && node.parent) {\n                if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n                    return true;\n                }\n                return isInsideForLoopInitializer(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1) {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the return value is `{` or the return value is a sequence expression,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || (funcInfo.hasInOperator && isInsideForLoopInitializer(node))) {\n                                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                                    fixes.push(\n                                        fixer.insertTextBefore(firstValueToken, \"(\"),\n                                        fixer.insertTextAfter(lastValueToken, \")\")\n                                    );\n                                }\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });\n                            const lastToken = sourceCode.getLastToken(node);\n                            const isParenthesisedObjectLiteral =\n                                astUtils.isOpeningParenToken(firstTokenAfterArrow) &&\n                                astUtils.isOpeningBraceToken(secondTokenAfterArrow);\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (isParenthesisedObjectLiteral) {\n                                const openingParenToken = firstTokenAfterArrow;\n                                const openingBraceToken = secondTokenAfterArrow;\n\n                                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                                    fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                                } else {\n\n                                    // Avoid ASI\n                                    fixes.push(\n                                        fixer.replaceText(openingParenToken, \"{\"),\n                                        fixer.insertTextBefore(openingBraceToken, \"return \")\n                                    );\n                                }\n\n                                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n                                fixes.push(fixer.remove(findClosingParen(openingBraceToken)));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n\n                            } else {\n                                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"BinaryExpression[operator='in']\"() {\n                let info = funcInfo;\n\n                while (info) {\n                    info.hasInOperator = true;\n                    info = info.upper;\n                }\n            },\n            ArrowFunctionExpression() {\n                funcInfo = {\n                    upper: funcInfo,\n                    hasInOperator: false\n                };\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                validate(node);\n                funcInfo = funcInfo.upper;\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\nfunction hasBlockBody(node) {\n    return node.body.type === \"BlockStatement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Finds opening paren of parameters for the given arrow function, if it exists.\n         * It is assumed that the given arrow function has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n         */\n        function findOpeningParenOfParams(node) {\n            const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n            if (\n                tokenBeforeParams &&\n                astUtils.isOpeningParenToken(tokenBeforeParams) &&\n                node.range[0] <= tokenBeforeParams.range[0]\n            ) {\n                return tokenBeforeParams;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds closing paren of parameters for the given arrow function.\n         * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token} the closing paren of parameters.\n         */\n        function getClosingParenOfParams(node) {\n            return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n        }\n\n        /**\n         * Determines whether the given arrow function has comments inside parens of parameters.\n         * It is assumed that the given arrow function has parens of parameters.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n         */\n        function hasCommentsInParensOfParams(node, openingParen) {\n            return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n        }\n\n        /**\n         * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n         * in which case it will be assumed that the existing parens of parameters are necessary.\n         * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n         * Example: <T>(a) => b\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one unexpected token.\n         */\n        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n            const expectedCount = node.async ? 1 : 0;\n\n            return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;\n        }\n\n        return {\n            \"ArrowFunctionExpression[params.length=1]\"(node) {\n                const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n                const openingParen = findOpeningParenOfParams(node);\n                const hasParens = openingParen !== null;\n                const [param] = node.params;\n\n                if (shouldHaveParens && !hasParens) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            yield fixer.insertTextBefore(param, \"(\");\n                            yield fixer.insertTextAfter(param, \")\");\n                        }\n                    });\n                }\n\n                if (\n                    !shouldHaveParens &&\n                    hasParens &&\n                    param.type === \"Identifier\" &&\n                    !param.typeAnnotation &&\n                    !node.returnType &&\n                    !hasCommentsInParensOfParams(node, openingParen) &&\n                    !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)\n                ) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n                            const closingParen = getClosingParenOfParams(node);\n\n                            if (\n                                tokenBeforeOpeningParen &&\n                                tokenBeforeOpeningParen.range[1] === openingParen.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))\n                            ) {\n                                yield fixer.insertTextBefore(openingParen, \" \");\n                            }\n\n                            // remove parens, whitespace inside parens, and possible trailing comma\n                            yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n                            yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Missing space before =>.\",\n            unexpectedBefore: \"Unexpected space before =>.\",\n\n            expectedAfter: \"Missing space after =>.\",\n            unexpectedAfter: \"Unexpected space after =>.\"\n        }\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = Object.assign({}, context.options[0]);\n\n        rule.before = rule.before !== false;\n        rule.after = rule.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"expectedBefore\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"unexpectedBefore\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"expectedAfter\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"unexpectedAfter\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, messageId: \"outOfScope\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst util = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow or enforce spaces inside of blocks after opening block and before closing block\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n\n        messages: {\n            missing: \"Requires a space {{location}} '{{token}}'.\",\n            extra: \"Unexpected space(s) {{location}} '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const always = (context.options[0] !== \"never\"),\n            messageId = always ? \"missing\" : \"extra\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement/SwitchStatement node to get.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                if (node.cases.length > 0) {\n                    return sourceCode.getTokenBefore(node.cases[0]);\n                }\n                return sourceCode.getLastToken(node, 1);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks whether or not:\n         *   - given tokens are on same line.\n         *   - there is/isn't a space between given tokens.\n         * @param {Token} left A token to check.\n         * @param {Token} right The token which is next to `left`.\n         * @returns {boolean}\n         *    When the option is `\"always\"`, `true` if there are one or more spaces between given tokens.\n         *    When the option is `\"never\"`, `true` if there are not any spaces between given tokens.\n         *    If given tokens are not on same line, it's always `true`.\n         */\n        function isValid(left, right) {\n            return (\n                !util.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === always\n            );\n        }\n\n        /**\n         * Reports invalid spacing style inside braces.\n         * @param {ASTNode} node A BlockStatement/SwitchStatement node to get.\n         * @returns {void}\n         */\n        function checkSpacingInsideBraces(node) {\n\n            // Gets braces and the first/last token of content.\n            const openBrace = getOpenBrace(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            // Skip if the node is invalid or empty.\n            if (openBrace.type !== \"Punctuator\" ||\n                openBrace.value !== \"{\" ||\n                closeBrace.type !== \"Punctuator\" ||\n                closeBrace.value !== \"}\" ||\n                firstToken === closeBrace\n            ) {\n                return;\n            }\n\n            // Skip line comments for option never\n            if (!always && firstToken.type === \"Line\") {\n                return;\n            }\n\n            // Check.\n            if (!isValid(openBrace, firstToken)) {\n                let loc = openBrace.loc;\n\n                if (messageId === \"extra\") {\n                    loc = {\n                        start: openBrace.loc.end,\n                        end: firstToken.loc.start\n                    };\n                }\n\n                context.report({\n                    node,\n                    loc,\n                    messageId,\n                    data: {\n                        location: \"after\",\n                        token: openBrace.value\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(firstToken, \" \");\n                        }\n\n                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n                    }\n                });\n            }\n            if (!isValid(lastToken, closeBrace)) {\n                let loc = closeBrace.loc;\n\n                if (messageId === \"extra\") {\n                    loc = {\n                        start: lastToken.loc.end,\n                        end: closeBrace.loc.start\n                    };\n                }\n                context.report({\n                    node,\n                    loc,\n                    messageId,\n                    data: {\n                        location: \"before\",\n                        token: closeBrace.value\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(lastToken, \" \");\n                        }\n\n                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            BlockStatement: checkSpacingInsideBraces,\n            SwitchStatement: checkSpacingInsideBraces\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/callback-return\"\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }],\n\n        messages: {\n            missingReturn: \"Expected return with your callback function.\"\n        }\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifiers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifiers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, messageId: \"missingReturn\" });\n                }\n\n            }\n\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreImports: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreGlobals: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const ignoreImports = options.ignoreImports;\n        const ignoreGlobals = options.ignoreGlobals;\n        const allow = options.allow || [];\n\n        let globalScope;\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.includes(\"_\") && name !== name.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let current = node;\n\n            while (current) {\n                const parent = current.parent;\n\n                if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n                    return false;\n                }\n\n                if (current.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                current = parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether the given node represents assignment target property in destructuring.\n         *\n         * For examples:\n         *    ({a: b.foo} = c);  // => true for `foo`\n         *    ([a.foo] = b);     // => true for `foo`\n         *    ([a.foo = 1] = b); // => true for `foo`\n         *    ({...a.foo} = b);  // => true for `foo`\n         * @param {ASTNode} node An Identifier node to check\n         * @returns {boolean} True if the node is an assignment target property in destructuring.\n         */\n        function isAssignmentTargetPropertyInDestructuring(node) {\n            if (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.property === node &&\n                !node.parent.computed\n            ) {\n                const effectiveParent = node.parent.parent;\n\n                return (\n                    effectiveParent.type === \"Property\" &&\n                    effectiveParent.value === node.parent &&\n                    effectiveParent.parent.type === \"ObjectPattern\" ||\n                    effectiveParent.type === \"ArrayPattern\" ||\n                    effectiveParent.type === \"RestElement\" ||\n                    (\n                        effectiveParent.type === \"AssignmentPattern\" &&\n                        effectiveParent.left === node.parent\n                    )\n                );\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a property of an object in an object literal expression.\n         * This allows to differentiate between a global variable that is allowed to be used as a reference, and the key\n         * of the expressed object (which shouldn't be allowed).\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a property name of an object literal expression\n         */\n        function isPropertyNameInObjectLiteral(node) {\n            const parent = node.parent;\n\n            return (\n                parent.type === \"Property\" &&\n                parent.parent.type === \"ObjectExpression\" &&\n                !parent.computed &&\n                parent.key === node\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.includes(node)) {\n                reported.push(node);\n                context.report({ node, messageId: \"notCamelCase\", data: { name: node.name } });\n            }\n        }\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them before checking if underscored\n                 */\n                const name = node.name,\n                    nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // First, we ignore the node if it match the ignore list\n                if (isAllowed(name)) {\n                    return;\n                }\n\n                // Check if it's a global variable\n                if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {\n                    return;\n                }\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n                        report(node);\n\n                    } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n                        if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n                        if (nameIsUnderscored && node.parent.computed) {\n                            report(node);\n                        }\n\n                        // prevent checking righthand side of destructured object\n                        if (node.parent.key === node && node.parent.value !== node) {\n                            return;\n                        }\n\n                        const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // \"never\" check properties or always ignore destructuring\n                    if (properties === \"never\" || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].includes(node.parent.type)) {\n\n                    if (node.parent.type === \"ImportSpecifier\" && ignoreImports) {\n                        return;\n                    }\n\n                    // Report only if the local imported identifier is underscored\n                    if (\n                        node.parent.local &&\n                        node.parent.local.name === node.name &&\n                        nameIsUnderscored\n                    ) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).\n * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js\n * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.\n * @author Kevin Partington\n * @license MIT License (from JSCS). See below.\n */\n\n/*\n * The MIT License (MIT)\n *\n * Copyright 2013-2016 Dulin Marat and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\"use strict\";\n\nmodule.exports = /[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/u;\n","/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/gu,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\nconst DEFAULTS = {\n    ignorePattern: \"\",\n    ignoreInlineComments: false,\n    ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions = {}) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n        }\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/gu, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            }\n            if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const messageId = capitalize === \"always\"\n                    ? \"unexpectedLowercaseComment\"\n                    : \"unexpectedUppercaseComment\";\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    messageId,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce that all class methods use 'this'.\n * @author Patrick Williams\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce that class methods utilize `this`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/class-methods-use-this\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                exceptMethods: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingThis: \"Expected 'this' to be used by class {{name}}.\"\n        }\n    },\n    create(context) {\n        const config = Object.assign({}, context.options[0]);\n        const exceptMethods = new Set(config.exceptMethods || []);\n\n        const stack = [];\n\n        /**\n         * Initializes the current context to false and pushes it onto the stack.\n         * These booleans represent whether 'this' has been used in the context.\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            stack.push(false);\n        }\n\n        /**\n         * Check if the node is an instance method\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if its an instance method\n         * @private\n         */\n        function isInstanceMethod(node) {\n            return !node.static && node.kind !== \"constructor\" && node.type === \"MethodDefinition\";\n        }\n\n        /**\n         * Check if the node is an instance method not excluded by config\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if it is an instance method, and not excluded by config\n         * @private\n         */\n        function isIncludedInstanceMethod(node) {\n            return isInstanceMethod(node) &&\n                (node.computed || !exceptMethods.has(node.key.name));\n        }\n\n        /**\n         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.\n         * Static methods and the constructor are exempt.\n         * Then pops the context off the stack.\n         * @param {ASTNode} node A function node that was entered.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction(node) {\n            const methodUsesThis = stack.pop();\n\n            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {\n                context.report({\n                    node,\n                    messageId: \"missingThis\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Mark the current context as having used 'this'.\n         * @returns {void}\n         * @private\n         */\n        function markThisUsed() {\n            if (stack.length) {\n                stack[stack.length - 1] = true;\n            }\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markThisUsed,\n            Super: markThisUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: (!ecmaVersion || ecmaVersion < 8) ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return lodash.last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return lodash.last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return lodash.last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return lodash.last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return lodash.last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: lodash.noop\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n","/**\n * @fileoverview Comma spacing - validates spacing before and after comma\n * @author Vignesh Anand aka vegetableman.\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missing: \"A space is required {{loc}} ','.\",\n            unexpected: \"There should be no space {{loc}} ','.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n        const tokensAndComments = sourceCode.tokensAndComments;\n\n        const options = {\n            before: context.options[0] ? context.options[0].before : false,\n            after: context.options[0] ? context.options[0].after : true\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // list of comma tokens to ignore for the check of leading whitespace\n        const commaTokensToIgnore = [];\n\n        /**\n         * Reports a spacing error with an appropriate message.\n         * @param {ASTNode} node The binary expression node to report.\n         * @param {string} loc Is the error \"before\" or \"after\" the comma?\n         * @param {ASTNode} otherNode The node at the left or right of `node`\n         * @returns {void}\n         * @private\n         */\n        function report(node, loc, otherNode) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (options[loc]) {\n                        if (loc === \"before\") {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.insertTextAfter(node, \" \");\n\n                    }\n                    let start, end;\n                    const newText = \"\";\n\n                    if (loc === \"before\") {\n                        start = otherNode.range[1];\n                        end = node.range[0];\n                    } else {\n                        start = node.range[1];\n                        end = otherNode.range[0];\n                    }\n\n                    return fixer.replaceTextRange([start, end], newText);\n\n                },\n                messageId: options[loc] ? \"missing\" : \"unexpected\",\n                data: {\n                    loc\n                }\n            });\n        }\n\n        /**\n         * Validates the spacing around a comma token.\n         * @param {Object} tokens The tokens to be validated.\n         * @param {Token} tokens.comma The token representing the comma.\n         * @param {Token} [tokens.left] The last token before the comma.\n         * @param {Token} [tokens.right] The first token after the comma.\n         * @param {Token|ASTNode} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(tokens, reportItem) {\n            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&\n                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))\n            ) {\n                report(reportItem, \"before\", tokens.left);\n            }\n\n            if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {\n                return;\n            }\n\n            if (tokens.right && !options.after && tokens.right.type === \"Line\") {\n                return;\n            }\n\n            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&\n                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))\n            ) {\n                report(reportItem, \"after\", tokens.right);\n            }\n        }\n\n        /**\n         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.\n         * @returns {void}\n         */\n        function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"() {\n                tokensAndComments.forEach((token, i) => {\n\n                    if (!astUtils.isCommaToken(token)) {\n                        return;\n                    }\n\n                    if (token && token.type === \"JSXText\") {\n                        return;\n                    }\n\n                    const previousToken = tokensAndComments[i - 1];\n                    const nextToken = tokensAndComments[i + 1];\n\n                    validateCommaItemSpacing({\n                        comma: token,\n                        left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,\n                        right: astUtils.isCommaToken(nextToken) ? null : nextToken\n                    }, token);\n                });\n            },\n            ArrayExpression: addNullElementsToIgnoreList,\n            ArrayPattern: addNullElementsToIgnoreList\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken,\n                            currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n","/**\n * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.\n * Counts the number of if, conditional, for, while, try, switch/case,\n * @author Patrick Brosset\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum cyclomatic complexity allowed in a program\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/complexity\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            complex: \"{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let THRESHOLD = 20;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            THRESHOLD = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store complexity (handling nested functions)\n        const fns = [];\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            fns.push(1);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n            const complexity = fns.pop();\n\n            if (complexity > THRESHOLD) {\n                context.report({\n                    node,\n                    messageId: \"complex\",\n                    data: { name, complexity, max: THRESHOLD }\n                });\n            }\n        }\n\n        /**\n         * Increase the complexity of the function in context\n         * @returns {void}\n         * @private\n         */\n        function increaseComplexity() {\n            if (fns.length) {\n                fns[fns.length - 1]++;\n            }\n        }\n\n        /**\n         * Increase the switch complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseSwitchComplexity(node) {\n\n            // Avoiding `default`\n            if (node.test) {\n                increaseComplexity();\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            CatchClause: increaseComplexity,\n            ConditionalExpression: increaseComplexity,\n            LogicalExpression: increaseComplexity,\n            ForStatement: increaseComplexity,\n            ForInStatement: increaseComplexity,\n            ForOfStatement: increaseComplexity,\n            IfStatement: increaseComplexity,\n            SwitchCase: increaseSwitchComplexity,\n            WhileStatement: increaseComplexity,\n            DoWhileStatement: increaseComplexity,\n\n            AssignmentExpression(node) {\n                if (astUtils.isLogicalAssignmentOperator(node.operator)) {\n                    increaseComplexity();\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside computed properties.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside computed property brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/computed-property-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForClassMembers: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n            unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n\n            missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\",\n            missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const propertyNameMustBeSpaced = context.options[0] === \"always\"; // default is \"never\"\n        const enforceForClassMembers = !context.options[1] || context.options[1].enforceForClassMembers;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @param {Token} tokenAfter The token after `token`.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token, tokenAfter) {\n            context.report({\n                node,\n                loc: { start: token.loc.end, end: tokenAfter.loc.start },\n                messageId: \"unexpectedSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @param {Token} tokenBefore The token before `token`.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token, tokenBefore) {\n            context.report({\n                node,\n                loc: { start: tokenBefore.loc.end, end: token.loc.start },\n                messageId: \"unexpectedSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Returns a function that checks the spacing of a node on the property name\n         * that was passed in.\n         * @param {string} propertyName The property on the node to check for spacing\n         * @returns {Function} A function that will check spacing on a node\n         */\n        function checkSpacing(propertyName) {\n            return function(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const property = node[propertyName];\n\n                const before = sourceCode.getTokenBefore(property, astUtils.isOpeningBracketToken),\n                    first = sourceCode.getTokenAfter(before, { includeComments: true }),\n                    after = sourceCode.getTokenAfter(property, astUtils.isClosingBracketToken),\n                    last = sourceCode.getTokenBefore(after, { includeComments: true });\n\n                if (astUtils.isTokenOnSameLine(before, first)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {\n                            reportRequiredBeginningSpace(node, before);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(before, first)) {\n                            reportNoBeginningSpace(node, before, first);\n                        }\n                    }\n                }\n\n                if (astUtils.isTokenOnSameLine(last, after)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {\n                            reportRequiredEndingSpace(node, after);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(last, after)) {\n                            reportNoEndingSpace(node, after, last);\n                        }\n                    }\n                }\n            };\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const listeners = {\n            Property: checkSpacing(\"key\"),\n            MemberExpression: checkSpacing(\"property\")\n        };\n\n        if (enforceForClassMembers) {\n            listeners.MethodDefinition = checkSpacing(\"key\");\n        }\n\n        return listeners;\n\n    }\n};\n","/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingReturn: \"Expected to return a value at the end of {{name}}.\",\n            missingReturnValue: \"{{name}} expected a return value.\",\n            unexpectedReturnValue: \"{{name}} expected no return value.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         * @param {ASTNode} node A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                messageId: \"missingReturn\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    messageId: \"\",\n                    node\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        messageId: funcInfo.messageId,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node The assigning node.\n         * @param {string}  name the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node The assigning node.\n         * @param {Identifier} name The name of the variable assigned to.\n         * @param {Expression} value The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assigned to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n * @param {CodePathSegment} segment A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"ChainExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            if ([\"=\", \"&&=\"].includes(node.operator)) {\n                return isPossibleConstructor(node.right);\n            }\n\n            if ([\"||=\", \"??=\"].includes(node.operator)) {\n                return (\n                    isPossibleConstructor(node.left) ||\n                    isPossibleConstructor(node.right)\n                );\n            }\n\n            /**\n             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n             * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n             */\n            return false;\n\n        case \"LogicalExpression\":\n\n            /*\n             * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n             * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n             * possible constructor. A future improvement could verify that the left side could be truthy by\n             * excluding falsy literals.\n             */\n            if (node.operator === \"&&\") {\n                return isPossibleConstructor(node.right);\n            }\n\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n            unexpected: \"Unexpected 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath A code path which was ended.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                messageId: \"duplicate\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                messageId: \"badSuper\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        messageId: \"unexpected\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/curly\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n        }\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            if (node.type === \"EmptyStatement\") {\n                return true;\n            }\n\n            const first = sourceCode.getFirstToken(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if the given node is a lexical declaration (let, const, function, or class)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lexical declaration\n         * @private\n         */\n        function isLexicalDeclaration(node) {\n            if (node.type === \"VariableDeclaration\") {\n                return node.kind === \"const\" || node.kind === \"let\";\n            }\n\n            return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n        }\n\n        /**\n         * Determines whether the given node has an `else` keyword token as the first token after.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is followed by an `else` keyword token.\n         */\n        function isFollowedByElseKeyword(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            return Boolean(nextToken) && isElseKeywordToken(nextToken);\n        }\n\n        /**\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n         * @param {Token} closingBracket The } token\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n         */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                /*\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                 * a SyntaxError if it was followed by `else`.\n                 */\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Determines whether the code represented by the given node contains an `if` statement\n         * that would become associated with an `else` keyword directly appended to that code.\n         *\n         * Examples where it returns `true`:\n         *\n         *    if (a)\n         *        foo();\n         *\n         *    if (a) {\n         *        foo();\n         *    }\n         *\n         *    if (a)\n         *        foo();\n         *    else if (b)\n         *        bar();\n         *\n         *    while (a)\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *\n         * Examples where it returns `false`:\n         *\n         *    if (a)\n         *        foo();\n         *    else\n         *        bar();\n         *\n         *    while (a) {\n         *        if (b)\n         *            if(c)\n         *                foo();\n         *            else\n         *                bar();\n         *    }\n         *\n         *    while (a)\n         *        if (b) {\n         *            if(c)\n         *                foo();\n         *        }\n         *        else\n         *            bar();\n         * @param {ASTNode} node Node representing the code to check.\n         * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\n         */\n        function hasUnsafeIf(node) {\n            switch (node.type) {\n                case \"IfStatement\":\n                    if (!node.alternate) {\n                        return true;\n                    }\n                    return hasUnsafeIf(node.alternate);\n                case \"ForStatement\":\n                case \"ForInStatement\":\n                case \"ForOfStatement\":\n                case \"LabeledStatement\":\n                case \"WithStatement\":\n                case \"WhileStatement\":\n                    return hasUnsafeIf(node.body);\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\n         * The braces, which make the given block body, are necessary in either of the following situations:\n         *\n         * 1. The statement is a lexical declaration.\n         * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\n         *\n         *     if (a) {\n         *         if (b)\n         *             foo();\n         *     }\n         *     else\n         *         bar();\n         *\n         *     if (a)\n         *         while (b)\n         *             while (c) {\n         *                 while (d)\n         *                     if (e)\n         *                         while(f)\n         *                             foo();\n         *            }\n         *     else\n         *         bar();\n         * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\n         * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\n         * would change the semantics of the code or produce a syntax error.\n         */\n        function areBracesNecessary(node) {\n            const statement = node.body[0];\n\n            return isLexicalDeclaration(statement) ||\n                hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, opts) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n                expected = true;\n            } else if (multiOnly) {\n                expected = false;\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n\n                // otherwise, the body is allowed to have braces or not to have braces\n\n            } else if (multiOrNest) {\n                if (hasBlock) {\n                    const statement = body.body[0];\n                    const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n\n                    expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n                } else {\n                    expected = !isOneLiner(body);\n                }\n            } else {\n\n                // default \"all\"\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n                            });\n                        } else {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix(fixer) {\n\n                                    /*\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                                     */\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\n\n                                    const openingBracket = sourceCode.getFirstToken(body);\n                                    const closingBracket = sourceCode.getLastToken(body);\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                                    if (needsSemicolon(closingBracket)) {\n\n                                        /*\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                                         * change the semantics of the code due to ASI), don't perform a fix.\n                                         */\n                                        return null;\n                                    }\n\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                                        sourceCode.getText(lastTokenInBlock) +\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n                    break;\n                }\n            }\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                const parent = node.parent;\n                const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n                if (!isElseIf) {\n\n                    // This is a top `if`, check the whole `if-else-if` chain\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n\n                // Skip `else if`, it's already checked (when the top `if` was visited)\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce default clauses in switch statements to be last\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce default clauses in switch statements to be last\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/default-case-last\"\n        },\n\n        schema: [],\n\n        messages: {\n            notLast: \"Default clause should be the last clause.\"\n        }\n    },\n\n    create(context) {\n        return {\n            SwitchStatement(node) {\n                const cases = node.cases,\n                    indexOfDefault = cases.findIndex(c => c.test === null);\n\n                if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {\n                    const defaultClause = cases[indexOfDefault];\n\n                    context.report({ node: defaultClause, messageId: \"notLast\" });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview require default case in switch statements\n * @author Aliaksei Shytkin\n */\n\"use strict\";\n\nconst DEFAULT_COMMENT_PATTERN = /^no default$/iu;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `default` cases in `switch` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/default-case\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                commentPattern: {\n                    type: \"string\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingDefaultCase: \"Expected a default case.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const commentPattern = options.commentPattern\n            ? new RegExp(options.commentPattern, \"u\")\n            : DEFAULT_COMMENT_PATTERN;\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Shortcut to get last element of array\n         * @param  {*[]} collection Array\n         * @returns {*} Last element\n         */\n        function last(collection) {\n            return collection[collection.length - 1];\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            SwitchStatement(node) {\n\n                if (!node.cases.length) {\n\n                    /*\n                     * skip check of empty switch because there is no easy way\n                     * to extract comments inside it now\n                     */\n                    return;\n                }\n\n                const hasDefault = node.cases.some(v => v.test === null);\n\n                if (!hasDefault) {\n\n                    let comment;\n\n                    const lastCase = last(node.cases);\n                    const comments = sourceCode.getCommentsAfter(lastCase);\n\n                    if (comments.length) {\n                        comment = last(comments);\n                    }\n\n                    if (!comment || !commentPattern.test(comment.value.trim())) {\n                        context.report({ node, messageId: \"missingDefaultCase\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview enforce default parameters to be last\n * @author Chiawen Chen\n */\n\n\"use strict\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce default parameters to be last\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/default-param-last\"\n        },\n\n        schema: [],\n\n        messages: {\n            shouldBeLast: \"Default parameters should be last.\"\n        }\n    },\n\n    create(context) {\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node function node\n         * @returns {void}\n         */\n        function handleFunction(node) {\n            let hasSeenPlainParam = false;\n\n            for (let i = node.params.length - 1; i >= 0; i -= 1) {\n                const param = node.params[i];\n\n                if (\n                    param.type !== \"AssignmentPattern\" &&\n                    param.type !== \"RestElement\"\n                ) {\n                    hasSeenPlainParam = true;\n                    continue;\n                }\n\n                if (hasSeenPlainParam && param.type === \"AssignmentPattern\") {\n                    context.report({\n                        node: param,\n                        messageId: \"shouldBeLast\"\n                    });\n                }\n            }\n        }\n\n        return {\n            FunctionDeclaration: handleFunction,\n            FunctionExpression: handleFunction,\n            ArrowFunctionExpression: handleFunction\n        };\n    }\n};\n","/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent newlines before and after dots\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-location\"\n        },\n\n        schema: [\n            {\n                enum: [\"object\", \"property\"]\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n            expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n\n        // default to onObject if no preference is passed\n        const onObject = config === \"object\" || !config;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if the dot between object and property is on the correct location.\n         * @param {ASTNode} node The `MemberExpression` node.\n         * @returns {void}\n         */\n        function checkDotLocation(node) {\n            const property = node.property;\n            const dotToken = sourceCode.getTokenBefore(property);\n\n            if (onObject) {\n\n                // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.\n                const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);\n\n                if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {\n                    context.report({\n                        node,\n                        loc: dotToken.loc,\n                        messageId: \"expectedDotAfterObject\",\n                        *fix(fixer) {\n                            if (dotToken.value.startsWith(\".\") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {\n                                yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);\n                            } else {\n                                yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);\n                            }\n                            yield fixer.remove(dotToken);\n                        }\n                    });\n                }\n            } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {\n                context.report({\n                    node,\n                    loc: dotToken.loc,\n                    messageId: \"expectedDotBeforeProperty\",\n                    *fix(fixer) {\n                        yield fixer.remove(dotToken);\n                        yield fixer.insertTextBefore(property, dotToken.value);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks the spacing of the dot within a member expression.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            if (!node.computed) {\n                checkDotLocation(node);\n            }\n        }\n\n        return {\n            MemberExpression: checkNode\n        };\n    }\n};\n","/**\n * @fileoverview A shared list of ES3 keywords.\n * @author Josh Perez\n */\n\"use strict\";\n\nmodule.exports = [\n    \"abstract\",\n    \"boolean\",\n    \"break\",\n    \"byte\",\n    \"case\",\n    \"catch\",\n    \"char\",\n    \"class\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"double\",\n    \"else\",\n    \"enum\",\n    \"export\",\n    \"extends\",\n    \"false\",\n    \"final\",\n    \"finally\",\n    \"float\",\n    \"for\",\n    \"function\",\n    \"goto\",\n    \"if\",\n    \"implements\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"new\",\n    \"null\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"return\",\n    \"short\",\n    \"static\",\n    \"super\",\n    \"switch\",\n    \"synchronized\",\n    \"this\",\n    \"throw\",\n    \"throws\",\n    \"transient\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"volatile\",\n    \"while\",\n    \"with\"\n];\n","/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern, \"u\");\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    *fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n                        const nextToken = sourceCode.getTokenAfter(node);\n\n                        // Don't perform any fixes if there are comments inside the brackets.\n                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n                            return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                        }\n\n                        // Replace the brackets by an identifier.\n                        if (!node.optional) {\n                            yield fixer.insertTextBefore(\n                                leftBracket,\n                                astUtils.isDecimalInteger(node.object) ? \" .\" : \".\"\n                            );\n                        }\n                        yield fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            value\n                        );\n\n                        // Insert a space after the property if it will be connected to the next token.\n                        if (\n                            nextToken &&\n                            rightBracket.range[1] === nextToken.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), nextToken)\n                        ) {\n                            yield fixer.insertTextAfter(node, \" \");\n                        }\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        *fix(fixer) {\n                            const dotToken = sourceCode.getTokenBefore(node.property);\n\n                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                                return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                            }\n\n                            // Don't perform any fixes if there are comments between the dot and the property name.\n                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                                return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                            }\n\n                            // Replace the identifier to brackets.\n                            if (!node.optional) {\n                                yield fixer.remove(dotToken);\n                            }\n                            yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    location = {\n                        column: lodash.last(sourceCode.lines).length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = src.endsWith(LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n\n            context.report({\n                node,\n                loc: operatorToken.loc,\n                messageId: \"unexpected\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/for-direction\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * report an error.\n         * @param {ASTNode} node the node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"incorrectDirection\"\n            });\n        }\n\n        /**\n         * check the right side of the assignment\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {int} dir expected direction that could either be turned around or invalidated\n         * @returns {int} return dir, the negated dir or zero if it's not clear for identifiers\n         */\n        function getRightDirection(update, dir) {\n            if (update.right.type === \"UnaryExpression\") {\n                if (update.right.operator === \"-\") {\n                    return -dir;\n                }\n            } else if (update.right.type === \"Identifier\") {\n                return 0;\n            }\n            return dir;\n        }\n\n        /**\n         * check UpdateExpression add/sub the counter\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getUpdateDirection(update, counter) {\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n                if (update.operator === \"++\") {\n                    return 1;\n                }\n                if (update.operator === \"--\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * check AssignmentExpression add/sub the counter\n         * @param {ASTNode} update AssignmentExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getAssignmentDirection(update, counter) {\n            if (update.left.name === counter) {\n                if (update.operator === \"+=\") {\n                    return getRightDirection(update, 1);\n                }\n                if (update.operator === \"-=\") {\n                    return getRightDirection(update, -1);\n                }\n            }\n            return 0;\n        }\n        return {\n            ForStatement(node) {\n\n                if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\n                    const counter = node.test.left.name;\n                    const operator = node.test.operator;\n                    const update = node.update;\n\n                    let wrongDirection;\n\n                    if (operator === \"<\" || operator === \"<=\") {\n                        wrongDirection = -1;\n                    } else if (operator === \">\" || operator === \">=\") {\n                        wrongDirection = 1;\n                    } else {\n                        return;\n                    }\n\n                    if (update.type === \"UpdateExpression\") {\n                        if (getUpdateDirection(update, counter) === wrongDirection) {\n                            report(node);\n                        }\n                    } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n                        report(node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to control spacing within function calls\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing between function identifiers and their invocations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-call-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                allowNewlines: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpectedWhitespace: \"Unexpected whitespace between function name and paren.\",\n            unexpectedNewline: \"Unexpected newline between function name and paren.\",\n            missing: \"Missing space between function name and paren.\"\n        }\n    },\n\n    create(context) {\n\n        const never = context.options[0] !== \"always\";\n        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;\n        const sourceCode = context.getSourceCode();\n        const text = sourceCode.getText();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @param {Token} leftToken The last token of the callee. This may be the closing parenthesis that encloses the callee.\n         * @param {Token} rightToken Tha first token of the arguments. this is the opening parenthesis that encloses the arguments.\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node, leftToken, rightToken) {\n            const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\\/\\*.*?\\*\\//gu, \"\");\n            const hasWhitespace = /\\s/u.test(textBetweenTokens);\n            const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);\n\n            /*\n             * never allowNewlines hasWhitespace hasNewline message\n             * F     F             F             F          Missing space between function name and paren.\n             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     F             T             T          Unexpected newline between function name and paren.\n             * F     F             T             F          (OK)\n             * F     T             T             F          (OK)\n             * F     T             T             T          (OK)\n             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     T             F             F          Missing space between function name and paren.\n             * T     T             F             F          (Invalid `never && allowNewlines`)\n             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     T             T             T          (Invalid `never && allowNewlines`)\n             * T     T             T             F          (Invalid `never && allowNewlines`)\n             * T     F             T             F          Unexpected space between function name and paren.\n             * T     F             T             T          Unexpected space between function name and paren.\n             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     F             F             F          (OK)\n             *\n             * T                   T                        Unexpected space between function name and paren.\n             * F                   F                        Missing space between function name and paren.\n             * F     F                           T          Unexpected newline between function name and paren.\n             */\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        start: leftToken.loc.end,\n                        end: {\n                            line: rightToken.loc.start.line,\n                            column: rightToken.loc.start.column - 1\n                        }\n                    },\n                    messageId: \"unexpectedWhitespace\",\n                    fix(fixer) {\n\n                        // Don't remove comments.\n                        if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n                            return null;\n                        }\n\n                        // If `?.` exists, it doesn't hide no-unexpected-multiline errors\n                        if (node.optional) {\n                            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \"?.\");\n                        }\n\n                        /*\n                         * Only autofix if there is no newline\n                         * https://github.com/eslint/eslint/issues/7787\n                         */\n                        if (hasNewline) {\n                            return null;\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        start: {\n                            line: leftToken.loc.end.line,\n                            column: leftToken.loc.end.column - 1\n                        },\n                        end: rightToken.loc.start\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        if (node.optional) {\n                            return null; // Not sure if inserting a space to either before/after `?.` token.\n                        }\n                        return fixer.insertTextBefore(rightToken, \" \");\n                    }\n                });\n            } else if (!never && !allowNewlines && hasNewline) {\n                context.report({\n                    node,\n                    loc: {\n                        start: leftToken.loc.end,\n                        end: rightToken.loc.start\n                    },\n                    messageId: \"unexpectedNewline\",\n                    fix(fixer) {\n\n                        /*\n                         * Only autofix if there is no newline\n                         * https://github.com/eslint/eslint/issues/7787\n                         * But if `?.` exists, it doesn't hide no-unexpected-multiline errors\n                         */\n                        if (!node.optional) {\n                            return null;\n                        }\n\n                        // Don't remove comments.\n                        if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n                            return null;\n                        }\n\n                        const range = [leftToken.range[1], rightToken.range[0]];\n                        const qdToken = sourceCode.getTokenAfter(leftToken);\n\n                        if (qdToken.range[0] === leftToken.range[1]) {\n                            return fixer.replaceTextRange(range, \"?. \");\n                        }\n                        if (qdToken.range[1] === rightToken.range[0]) {\n                            return fixer.replaceTextRange(range, \" ?.\");\n                        }\n                        return fixer.replaceTextRange(range, \" ?. \");\n                    }\n                });\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                const lastToken = sourceCode.getLastToken(node);\n                const lastCalleeToken = sourceCode.getLastToken(node.callee);\n                const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);\n                const prevToken = parenToken && sourceCode.getTokenBefore(parenToken, astUtils.isNotQuestionDotToken);\n\n                // Parens in NewExpression are optional\n                if (!(parenToken && parenToken.range[1] < node.range[1])) {\n                    return;\n                }\n\n                checkSpacing(node, prevToken, parenToken);\n            },\n\n            ImportExpression(node) {\n                const leftToken = sourceCode.getFirstToken(node);\n                const rightToken = sourceCode.getTokenAfter(leftToken);\n\n                checkSpacing(node, leftToken, rightToken);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\") {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (considerPropertyDescriptor && propertyName === \"value\") {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options.length > 1 &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0] || \"always\";\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * The listener for function nodes.\n         * @param {ASTNode} node function node\n         * @returns {void}\n         */\n        function handleFunction(node) {\n\n            // Skip recursive functions.\n            const nameVar = context.getDeclaredVariables(node)[0];\n\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                return;\n            }\n\n            const hasName = Boolean(node.id && node.id.name);\n            const config = getConfigForNode(node);\n\n            if (config === \"never\") {\n                if (hasName && node.type !== \"FunctionDeclaration\") {\n                    reportUnexpectedNamedFunction(node);\n                }\n            } else if (config === \"as-needed\") {\n                if (!hasName && !hasInferredName(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            } else {\n                if (!hasName && !isObjectOrClassMethod(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            }\n        }\n\n        return {\n            \"FunctionExpression:exit\": handleFunction,\n            \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a particular function style\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of either `function` declarations or expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"declaration\", \"expression\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowArrowFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expression: \"Expected a function expression.\",\n            declaration: \"Expected a function declaration.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0],\n            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions,\n            enforceDeclarations = (style === \"declaration\"),\n            stack = [];\n\n        const nodesToCheck = {\n            FunctionDeclaration(node) {\n                stack.push(false);\n\n                if (!enforceDeclarations && node.parent.type !== \"ExportDefaultDeclaration\") {\n                    context.report({ node, messageId: \"expression\" });\n                }\n            },\n            \"FunctionDeclaration:exit\"() {\n                stack.pop();\n            },\n\n            FunctionExpression(node) {\n                stack.push(false);\n\n                if (enforceDeclarations && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, messageId: \"declaration\" });\n                }\n            },\n            \"FunctionExpression:exit\"() {\n                stack.pop();\n            },\n\n            ThisExpression() {\n                if (stack.length > 0) {\n                    stack[stack.length - 1] = true;\n                }\n            }\n        };\n\n        if (!allowArrowFunctions) {\n            nodesToCheck.ArrowFunctionExpression = function() {\n                stack.push(false);\n            };\n\n            nodesToCheck[\"ArrowFunctionExpression:exit\"] = function(node) {\n                const hasThisExpr = stack.pop();\n\n                if (enforceDeclarations && !hasThisExpr && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, messageId: \"declaration\" });\n                }\n            };\n        }\n\n        return nodesToCheck;\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce line breaks between arguments of a function call\n * @author Alexey Gonchar <https://github.com/finico>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks between arguments of a function call\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"consistent\"]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no line break here.\",\n            missingLineBreak: \"There should be a line break after this argument.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const checkers = {\n            unexpected: {\n                messageId: \"unexpectedLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n            },\n            missing: {\n                messageId: \"missingLineBreak\",\n                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n                createFix: (token, tokenBefore) => fixer =>\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n            }\n        };\n\n        /**\n         * Check all arguments for line breaks in the CallExpression\n         * @param {CallExpression} node node to evaluate\n         * @param {{ messageId: string, check: Function }} checker selected checker\n         * @returns {void}\n         * @private\n         */\n        function checkArguments(node, checker) {\n            for (let i = 1; i < node.arguments.length; i++) {\n                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n                if (checker.check(prevArgToken, currentArgToken)) {\n                    const tokenBefore = sourceCode.getTokenBefore(\n                        currentArgToken,\n                        { includeComments: true }\n                    );\n\n                    const hasLineCommentBefore = tokenBefore.type === \"Line\";\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBefore.loc.end,\n                            end: currentArgToken.loc.start\n                        },\n                        messageId: checker.messageId,\n                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if open space is present in a function name\n         * @param {CallExpression} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.arguments.length < 2) {\n                return;\n            }\n\n            const option = context.options[0] || \"always\";\n\n            if (option === \"never\") {\n                checkArguments(node, checkers.unexpected);\n            } else if (option === \"always\") {\n                checkArguments(node, checkers.missing);\n            } else if (option === \"consistent\") {\n                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n                    checkArguments(node, checkers.unexpected);\n                } else {\n                    checkArguments(node, checkers.missing);\n                }\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Expected newline before ')'.\",\n            expectedAfter: \"Expected newline after '('.\",\n            expectedBetween: \"Expected newline between arguments/params.\",\n            unexpectedBefore: \"Unexpected newline before ')'.\",\n            unexpectedAfter: \"Unexpected newline after '('.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineArgumentsOption && elements.length === 1) {\n                return hasLeftNewline;\n            }\n            if (multilineOption || multilineArgumentsOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates parens\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"unexpectedAfter\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"unexpectedBefore\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateArguments(parens, elements) {\n            const leftParen = parens.leftParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            for (let i = 0; i <= elements.length - 2; i++) {\n                const currentElement = elements[i];\n                const nextElement = elements[i + 1];\n                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n                if (!hasNewLine && needsNewlines) {\n                    context.report({\n                        node: currentElement,\n                        messageId: \"expectedBetween\",\n                        fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n                    });\n                }\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node, { skip: (node.async ? 1 : 0) });\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                case \"ImportExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, 1);\n                    const rightParen = sourceCode.getLastToken(node);\n\n                    return { leftParen, rightParen };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            [[\n                \"ArrowFunctionExpression\",\n                \"CallExpression\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ImportExpression\",\n                \"NewExpression\"\n            ]](node) {\n                const parens = getParenTokens(node);\n                let params;\n\n                if (node.type === \"ImportExpression\") {\n                    params = [node.source];\n                } else if (astUtils.isFunction(node)) {\n                    params = node.params;\n                } else {\n                    params = node.arguments;\n                }\n\n                if (parens) {\n                    validateParens(parens, params);\n\n                    if (multilineArgumentsOption) {\n                        validateArguments(parens, params);\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst OVERRIDE_SCHEMA = {\n    oneOf: [\n        {\n            enum: [\"before\", \"after\", \"both\", \"neither\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                before: { type: \"boolean\" },\n                after: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" },\n                            named: OVERRIDE_SCHEMA,\n                            anonymous: OVERRIDE_SCHEMA,\n                            method: OVERRIDE_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            missingBefore: \"Missing space before *.\",\n            missingAfter: \"Missing space after *.\",\n            unexpectedBefore: \"Unexpected space before *.\",\n            unexpectedAfter: \"Unexpected space after *.\"\n        }\n    },\n\n    create(context) {\n\n        const optionDefinitions = {\n            before: { before: true, after: false },\n            after: { before: false, after: true },\n            both: { before: true, after: true },\n            neither: { before: false, after: false }\n        };\n\n        /**\n         * Returns resolved option definitions based on an option and defaults\n         * @param {any} option The option object or string value\n         * @param {Object} defaults The defaults to use if options are not present\n         * @returns {Object} the resolved object definition\n         */\n        function optionToDefinition(option, defaults) {\n            if (!option) {\n                return defaults;\n            }\n\n            return typeof option === \"string\"\n                ? optionDefinitions[option]\n                : Object.assign({}, defaults, option);\n        }\n\n        const modes = (function(option) {\n            const defaults = optionToDefinition(option, optionDefinitions.before);\n\n            return {\n                named: optionToDefinition(option.named, defaults),\n                anonymous: optionToDefinition(option.anonymous, defaults),\n                method: optionToDefinition(option.method, defaults)\n            };\n        }(context.options[0] || {}));\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if the given token is a star token or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if the token is a star token.\n         */\n        function isStarToken(token) {\n            return token.value === \"*\" && token.type === \"Punctuator\";\n        }\n\n        /**\n         * Gets the generator star token of the given function node.\n         * @param {ASTNode} node The function node to get.\n         * @returns {Token} Found star token.\n         */\n        function getStarToken(node) {\n            return sourceCode.getFirstToken(\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\n                isStarToken\n            );\n        }\n\n        /**\n         * capitalize a given string.\n         * @param {string} str the given string.\n         * @returns {string} the capitalized string.\n         */\n        function capitalize(str) {\n            return str[0].toUpperCase() + str.slice(1);\n        }\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(kind, side, leftToken, rightToken) {\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = modes[kind][side];\n                const node = after ? leftToken : rightToken;\n                const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n\n                context.report({\n                    node,\n                    messageId,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a generator function.\n         * @param {ASTNode} node A function expression or declaration node.\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const starToken = getStarToken(node);\n            const prevToken = sourceCode.getTokenBefore(starToken);\n            const nextToken = sourceCode.getTokenAfter(starToken);\n\n            let kind = \"named\";\n\n            if (node.parent.type === \"MethodDefinition\" || (node.parent.type === \"Property\" && node.parent.method)) {\n                kind = \"method\";\n            } else if (!node.id) {\n                kind = \"anonymous\";\n            }\n\n            // Only check before when preceded by `function`|`static` keyword\n            if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n                checkSpacing(kind, \"before\", prevToken, starToken);\n            }\n\n            checkSpacing(kind, \"after\", starToken, nextToken);\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n        const sourceCode = context.getSourceCode();\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule for disallowing require() outside of the top-level module context\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst ACCEPTABLE_PARENTS = [\n    \"AssignmentExpression\",\n    \"VariableDeclarator\",\n    \"MemberExpression\",\n    \"ExpressionStatement\",\n    \"CallExpression\",\n    \"ConditionalExpression\",\n    \"Program\",\n    \"VariableDeclaration\",\n    \"ChainExpression\"\n];\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    /* istanbul ignore else: correctly returns null */\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {ASTNode} node The identifier node to check.\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `require()` calls to be placed at top-level module scope\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/global-require\"\n        },\n\n        schema: [],\n        messages: {\n            unexpected: \"Unexpected require().\"\n        }\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const currentScope = context.getScope();\n\n                if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\n                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n                    if (!isGoodRequire) {\n                        context.report({ node, messageId: \"unexpected\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require grouped accessor pairs in object literals and classes\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n\n    for (let i = 0; i < left.length; i++) {\n        const leftToken = left[i],\n            rightToken = right[i];\n\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\") {\n\n        // Statically computed names.\n        return left === right;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n\n        // Token lists.\n        return areEqualTokenLists(left, right);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require grouped accessor pairs in object literals and classes\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/grouped-accessor-pairs\"\n        },\n\n        schema: [\n            {\n                enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\n            }\n        ],\n\n        messages: {\n            notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\n            invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\n        }\n    },\n\n    create(context) {\n        const order = context.options[0] || \"anyOrder\";\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports the given accessor pair.\n         * @param {string} messageId messageId to report.\n         * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.\n         * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.\n         * @returns {void}\n         * @private\n         */\n        function report(messageId, formerNode, latterNode) {\n            context.report({\n                node: latterNode,\n                messageId,\n                loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\n                data: {\n                    formerName: astUtils.getFunctionNameWithKind(formerNode.value),\n                    latterName: astUtils.getFunctionNameWithKind(latterNode.value)\n                }\n            });\n        }\n\n        /**\n         * Creates a new `AccessorData` object for the given getter or setter node.\n         * @param {ASTNode} node A getter or setter node.\n         * @returns {AccessorData} New `AccessorData` object that contains the given node.\n         * @private\n         */\n        function createAccessorData(node) {\n            const name = astUtils.getStaticPropertyName(node);\n            const key = (name !== null) ? name : sourceCode.getTokens(node.key);\n\n            return {\n                key,\n                getters: node.kind === \"get\" ? [node] : [],\n                setters: node.kind === \"set\" ? [node] : []\n            };\n        }\n\n        /**\n         * Merges the given `AccessorData` object into the given accessors list.\n         * @param {AccessorData[]} accessors The list to merge into.\n         * @param {AccessorData} accessorData The object to merge.\n         * @returns {AccessorData[]} The same instance with the merged object.\n         * @private\n         */\n        function mergeAccessorData(accessors, accessorData) {\n            const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\n\n            if (equalKeyElement) {\n                equalKeyElement.getters.push(...accessorData.getters);\n                equalKeyElement.setters.push(...accessorData.setters);\n            } else {\n                accessors.push(accessorData);\n            }\n\n            return accessors;\n        }\n\n        /**\n         * Checks accessor pairs in the given list of nodes.\n         * @param {ASTNode[]} nodes The list to check.\n         * @param {Function} shouldCheck – Predicate that returns `true` if the node should be checked.\n         * @returns {void}\n         * @private\n         */\n        function checkList(nodes, shouldCheck) {\n            const accessors = nodes\n                .filter(shouldCheck)\n                .filter(isAccessorKind)\n                .map(createAccessorData)\n                .reduce(mergeAccessorData, []);\n\n            for (const { getters, setters } of accessors) {\n\n                // Don't report accessor properties that have duplicate getters or setters.\n                if (getters.length === 1 && setters.length === 1) {\n                    const [getter] = getters,\n                        [setter] = setters,\n                        getterIndex = nodes.indexOf(getter),\n                        setterIndex = nodes.indexOf(setter),\n                        formerNode = getterIndex < setterIndex ? getter : setter,\n                        latterNode = getterIndex < setterIndex ? setter : getter;\n\n                    if (Math.abs(getterIndex - setterIndex) > 1) {\n                        report(\"notGrouped\", formerNode, latterNode);\n                    } else if (\n                        (order === \"getBeforeSet\" && getterIndex > setterIndex) ||\n                        (order === \"setBeforeGet\" && getterIndex < setterIndex)\n                    ) {\n                        report(\"invalidOrder\", formerNode, latterNode);\n                    }\n                }\n            }\n        }\n\n        return {\n            ObjectExpression(node) {\n                checkList(node.properties, n => n.type === \"Property\");\n            },\n            ClassBody(node) {\n                checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\n                checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag for-in loops without if statements inside\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `for-in` loops to include an `if` statement\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/guard-for-in\"\n        },\n\n        schema: [],\n        messages: {\n            wrap: \"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            ForInStatement(node) {\n                const body = node.body;\n\n                // empty statement\n                if (body.type === \"EmptyStatement\") {\n                    return;\n                }\n\n                // if statement\n                if (body.type === \"IfStatement\") {\n                    return;\n                }\n\n                // empty block\n                if (body.type === \"BlockStatement\" && body.body.length === 0) {\n                    return;\n                }\n\n                // block with just if statement\n                if (body.type === \"BlockStatement\" && body.body.length === 1 && body.body[0].type === \"IfStatement\") {\n                    return;\n                }\n\n                // block that starts with if statement\n                if (body.type === \"BlockStatement\" && body.body.length >= 1 && body.body[0].type === \"IfStatement\") {\n                    const i = body.body[0];\n\n                    // ... whose consequent is a continue\n                    if (i.consequent.type === \"ContinueStatement\") {\n                        return;\n                    }\n\n                    // ... whose consequent is a block that contains only a continue\n                    if (i.consequent.type === \"BlockStatement\" && i.consequent.body.length === 1 && i.consequent.body[0].type === \"ContinueStatement\") {\n                        return;\n                    }\n                }\n\n                context.report({ node, messageId: \"wrap\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Ensure handling of errors when we know they exist.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require error handling in callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/handle-callback-err\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            }\n        ],\n        messages: {\n            expected: \"Expected error to be handled.\"\n        }\n    },\n\n    create(context) {\n\n        const errorArgument = context.options[0] || \"err\";\n\n        /**\n         * Checks if the given argument should be interpreted as a regexp pattern.\n         * @param {string} stringToCheck The string which should be checked.\n         * @returns {boolean} Whether or not the string should be interpreted as a pattern.\n         */\n        function isPattern(stringToCheck) {\n            const firstChar = stringToCheck[0];\n\n            return firstChar === \"^\";\n        }\n\n        /**\n         * Checks if the given name matches the configured error argument.\n         * @param {string} name The name which should be compared.\n         * @returns {boolean} Whether or not the given name matches the configured error variable name.\n         */\n        function matchesConfiguredErrorName(name) {\n            if (isPattern(errorArgument)) {\n                const regexp = new RegExp(errorArgument, \"u\");\n\n                return regexp.test(name);\n            }\n            return name === errorArgument;\n        }\n\n        /**\n         * Get the parameters of a given function scope.\n         * @param {Object} scope The function scope.\n         * @returns {Array} All parameters of the given scope.\n         */\n        function getParameters(scope) {\n            return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === \"Parameter\");\n        }\n\n        /**\n         * Check to see if we're handling the error object properly.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         */\n        function checkForError(node) {\n            const scope = context.getScope(),\n                parameters = getParameters(scope),\n                firstParameter = parameters[0];\n\n            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n                if (firstParameter.references.length === 0) {\n                    context.report({ node, messageId: \"expected\" });\n                }\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkForError,\n            FunctionExpression: checkForError,\n            ArrowFunctionExpression: checkForError\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n    const parent = node.parent;\n\n    return (\n\n        // normal assignment\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // destructuring\n        parent.type === \"ArrayPattern\" ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            parent.type === \"ImportSpecifier\" &&\n            parent.imported !== parent.local &&\n            parent.imported === node\n        ) ||\n        (\n            parent.type === \"ExportSpecifier\" &&\n            parent.parent.source && // re-export\n            parent.local !== parent.exported &&\n            parent.local === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node is a renamed identifier node in an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo; // node `a` is renamed node.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed node in an ObjectPattern destructuring.\n */\nfunction isRenamedInDestructuring(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            !parent.computed &&\n            parent.type === \"Property\" &&\n            parent.parent.type === \"ObjectPattern\" &&\n            parent.value !== node &&\n            parent.key === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents shorthand definition of a property in an object literal.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a shorthand property definition.\n */\nfunction isShorthandPropertyDefinition(node) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"Property\" &&\n        parent.parent.type === \"ObjectExpression\" &&\n        parent.shorthand\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        replacedBy: [\"id-denylist\"],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-blacklist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            restricted: \"Identifier '{{name}}' is restricted.\"\n        }\n    },\n\n    create(context) {\n\n        const denyList = new Set(context.options);\n        const reportedNodes = new Set();\n\n        let globalScope;\n\n        /**\n         * Checks whether the given name is restricted.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is restricted.\n         * @private\n         */\n        function isRestricted(name) {\n            return denyList.has(name);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether the given node should be checked.\n         * @param {ASTNode} node `Identifier` node.\n         * @returns {boolean} `true` if the node should be checked.\n         */\n        function shouldCheck(node) {\n            const parent = node.parent;\n\n            /*\n             * Member access has special rules for checking property names.\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n             */\n            if (\n                parent.type === \"MemberExpression\" &&\n                parent.property === node &&\n                !parent.computed\n            ) {\n                return isAssignmentTarget(parent);\n            }\n\n            return (\n                parent.type !== \"CallExpression\" &&\n                parent.type !== \"NewExpression\" &&\n                !isRenamedImport(node) &&\n                !isRenamedInDestructuring(node) &&\n                !(\n                    isReferenceToGlobalVariable(node) &&\n                    !isShorthandPropertyDefinition(node)\n                )\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reportedNodes.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"restricted\",\n                    data: {\n                        name: node.name\n                    }\n                });\n                reportedNodes.add(node);\n            }\n        }\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            Identifier(node) {\n                if (isRestricted(node.name) && shouldCheck(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n    const parent = node.parent;\n\n    return (\n\n        // normal assignment\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // destructuring\n        parent.type === \"ArrayPattern\" ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            parent.type === \"ImportSpecifier\" &&\n            parent.imported !== parent.local &&\n            parent.imported === node\n        ) ||\n        (\n            parent.type === \"ExportSpecifier\" &&\n            parent.parent.source && // re-export\n            parent.local !== parent.exported &&\n            parent.local === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node is a renamed identifier node in an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo; // node `a` is renamed node.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed node in an ObjectPattern destructuring.\n */\nfunction isRenamedInDestructuring(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            !parent.computed &&\n            parent.type === \"Property\" &&\n            parent.parent.type === \"ObjectPattern\" &&\n            parent.value !== node &&\n            parent.key === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents shorthand definition of a property in an object literal.\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a shorthand property definition.\n */\nfunction isShorthandPropertyDefinition(node) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"Property\" &&\n        parent.parent.type === \"ObjectExpression\" &&\n        parent.shorthand\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-denylist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            restricted: \"Identifier '{{name}}' is restricted.\"\n        }\n    },\n\n    create(context) {\n\n        const denyList = new Set(context.options);\n        const reportedNodes = new Set();\n\n        let globalScope;\n\n        /**\n         * Checks whether the given name is restricted.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is restricted.\n         * @private\n         */\n        function isRestricted(name) {\n            return denyList.has(name);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether the given node should be checked.\n         * @param {ASTNode} node `Identifier` node.\n         * @returns {boolean} `true` if the node should be checked.\n         */\n        function shouldCheck(node) {\n            const parent = node.parent;\n\n            /*\n             * Member access has special rules for checking property names.\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n             */\n            if (\n                parent.type === \"MemberExpression\" &&\n                parent.property === node &&\n                !parent.computed\n            ) {\n                return isAssignmentTarget(parent);\n            }\n\n            return (\n                parent.type !== \"CallExpression\" &&\n                parent.type !== \"NewExpression\" &&\n                !isRenamedImport(node) &&\n                !isRenamedInDestructuring(node) &&\n                !(\n                    isReferenceToGlobalVariable(node) &&\n                    !isShorthandPropertyDefinition(node)\n                )\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reportedNodes.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"restricted\",\n                    data: {\n                        name: node.name\n                    }\n                });\n                reportedNodes.add(node);\n            }\n        }\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            Identifier(node) {\n                if (isRestricted(node.name) && shouldCheck(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce minimum and maximum identifier lengths\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-length\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"integer\",\n                        default: 2\n                    },\n                    max: {\n                        type: \"integer\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    exceptionPatterns: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n            tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n        const properties = options.properties !== \"never\";\n        const exceptions = new Set(options.exceptions);\n        const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\n        const reportedNode = new Set();\n\n        /**\n         * Checks if a string matches the provided exception patterns\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function matchesExceptionPattern(name) {\n            return exceptionPatterns.some(pattern => pattern.test(name));\n        }\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property(parent, node) {\n\n                if (parent.parent.type === \"ObjectPattern\") {\n                    return (\n                        parent.value !== parent.key && parent.value === node ||\n                        parent.value === parent.key && parent.key === node && properties\n                    );\n                }\n                return properties && !parent.computed && parent.key === node;\n            },\n            ImportDefaultSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            CatchClause: true,\n            ArrayPattern: true\n        };\n\n        return {\n            Identifier(node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const isShort = name.length < minLength;\n                const isLong = name.length > maxLength;\n\n                if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n                    return; // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                if (isValidExpression && !reportedNode.has(node) && (isValidExpression === true || isValidExpression(parent, node))) {\n                    reportedNode.add(node);\n                    context.report({\n                        node,\n                        messageId: isShort ? \"tooShort\" : \"tooLong\",\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-match\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyDeclarations: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Options\n        //--------------------------------------------------------------------------\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern, \"u\");\n\n        const options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations,\n            ignoreDestructuring = !!options.ignoreDestructuring;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Map();\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let { parent } = node;\n\n            while (parent) {\n                if (parent.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"notMatch\",\n                    data: {\n                        name: node.name,\n                        pattern\n                    }\n                });\n                reported.set(node, true);\n            }\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions left side's assigned variable id\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n                        if (parent.shorthand && parent.value.left && isInvalid(name)) {\n\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n                        // prevent checking righthand side of destructured object\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\n                            return;\n                        }\n\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // never check properties or always ignore destructuring\n                    if (!properties || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if (IMPORT_TYPES.has(parent.type)) {\n\n                    // Report only if the local imported identifier is invalid\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is invalid that isn't a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst { isCommentToken, isNotOpeningParenToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of arrow function bodies\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"beside\";\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            if (node.body.type === \"BlockStatement\") {\n                return;\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n                });\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};\n","/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"indent\"],\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object} [loc] Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks whether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview This rule sets a specific indentation style and width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst createTree = require(\"functional-red-black-tree\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\n    \"AssignmentExpression\",\n    \"AssignmentPattern\",\n    \"ArrayExpression\",\n    \"ArrayPattern\",\n    \"ArrowFunctionExpression\",\n    \"AwaitExpression\",\n    \"BlockStatement\",\n    \"BinaryExpression\",\n    \"BreakStatement\",\n    \"CallExpression\",\n    \"CatchClause\",\n    \"ChainExpression\",\n    \"ClassBody\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"ConditionalExpression\",\n    \"ContinueStatement\",\n    \"DoWhileStatement\",\n    \"DebuggerStatement\",\n    \"EmptyStatement\",\n    \"ExperimentalRestProperty\",\n    \"ExperimentalSpreadProperty\",\n    \"ExpressionStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"IfStatement\",\n    \"Literal\",\n    \"LabeledStatement\",\n    \"LogicalExpression\",\n    \"MemberExpression\",\n    \"MetaProperty\",\n    \"MethodDefinition\",\n    \"NewExpression\",\n    \"ObjectExpression\",\n    \"ObjectPattern\",\n    \"Program\",\n    \"Property\",\n    \"RestElement\",\n    \"ReturnStatement\",\n    \"SequenceExpression\",\n    \"SpreadElement\",\n    \"Super\",\n    \"SwitchCase\",\n    \"SwitchStatement\",\n    \"TaggedTemplateExpression\",\n    \"TemplateElement\",\n    \"TemplateLiteral\",\n    \"ThisExpression\",\n    \"ThrowStatement\",\n    \"TryStatement\",\n    \"UnaryExpression\",\n    \"UpdateExpression\",\n    \"VariableDeclaration\",\n    \"VariableDeclarator\",\n    \"WhileStatement\",\n    \"WithStatement\",\n    \"YieldExpression\",\n    \"JSXFragment\",\n    \"JSXOpeningFragment\",\n    \"JSXClosingFragment\",\n    \"JSXIdentifier\",\n    \"JSXNamespacedName\",\n    \"JSXMemberExpression\",\n    \"JSXEmptyExpression\",\n    \"JSXExpressionContainer\",\n    \"JSXElement\",\n    \"JSXClosingElement\",\n    \"JSXOpeningElement\",\n    \"JSXAttribute\",\n    \"JSXSpreadAttribute\",\n    \"JSXText\",\n    \"ExportDefaultDeclaration\",\n    \"ExportNamedDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportSpecifier\",\n    \"ImportDeclaration\",\n    \"ImportSpecifier\",\n    \"ImportDefaultSpecifier\",\n    \"ImportNamespaceSpecifier\",\n    \"ImportExpression\"\n]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n\n/**\n * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.\n * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation\n * can easily be swapped out.\n */\nclass BinarySearchTree {\n\n    /**\n     * Creates an empty tree\n     */\n    constructor() {\n        this._rbTree = createTree();\n    }\n\n    /**\n     * Inserts an entry into the tree.\n     * @param {number} key The entry's key\n     * @param {*} value The entry's value\n     * @returns {void}\n     */\n    insert(key, value) {\n        const iterator = this._rbTree.find(key);\n\n        if (iterator.valid) {\n            this._rbTree = iterator.update(value);\n        } else {\n            this._rbTree = this._rbTree.insert(key, value);\n        }\n    }\n\n    /**\n     * Finds the entry with the largest key less than or equal to the provided key\n     * @param {number} key The provided key\n     * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.\n     */\n    findLe(key) {\n        const iterator = this._rbTree.le(key);\n\n        return iterator && { key: iterator.key, value: iterator.value };\n    }\n\n    /**\n     * Deletes all of the keys in the interval [start, end)\n     * @param {number} start The start of the range\n     * @param {number} end The end of the range\n     * @returns {void}\n     */\n    deleteRange(start, end) {\n\n        // Exit without traversing the tree if the range has zero size.\n        if (start === end) {\n            return;\n        }\n        const iterator = this._rbTree.ge(start);\n\n        while (iterator.valid && iterator.key < end) {\n            this._rbTree = this._rbTree.remove(iterator.key);\n            iterator.next();\n        }\n    }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\n            if (!map.has(token.loc.start.line)) {\n                map.set(token.loc.start.line, token);\n            }\n            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n                map.set(token.loc.end.line, token);\n            }\n            return map;\n        }, new Map());\n    }\n\n    /**\n     * Gets the first token on a given token's line\n     * @param {Token|ASTNode} token a node or token\n     * @returns {Token} The first token on the given line\n     */\n    getFirstTokenOfLine(token) {\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\n    }\n\n    /**\n     * Determines whether a token is the first token in its line\n     * @param {Token} token The token\n     * @returns {boolean} `true` if the token is the first on its line\n     */\n    isFirstTokenOfLine(token) {\n        return this.getFirstTokenOfLine(token) === token;\n    }\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n    getTokenIndent(token) {\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n    }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {number} indentSize The desired size of each indentation level\n     * @param {string} indentType The indentation character\n     */\n    constructor(tokenInfo, indentSize, indentType) {\n        this._tokenInfo = tokenInfo;\n        this._indentSize = indentSize;\n        this._indentType = indentType;\n\n        this._tree = new BinarySearchTree();\n        this._tree.insert(0, { offset: 0, from: null, force: false });\n\n        this._lockedFirstTokens = new WeakMap();\n        this._desiredIndentCache = new WeakMap();\n        this._ignoredTokens = new WeakSet();\n    }\n\n    _getOffsetDescriptor(token) {\n        return this._tree.findLe(token.range[0]).value;\n    }\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n     * most cases, `setDesiredOffset` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n    matchOffsetOf(baseToken, offsetToken) {\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n        this._lockedFirstTokens.set(offsetToken, baseToken);\n    }\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     * @param {Token} token The token\n     * @param {Token} fromToken The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n    setDesiredOffset(token, fromToken, offset) {\n        return this.setDesiredOffsets(token.range, fromToken, offset);\n    }\n\n    /**\n     * Sets the desired offset of all tokens in a range\n     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n     * it). This means that the offset of each token is updated O(AST depth) times.\n     * It would not be performant to store and update the offsets for each token independently, because the rule would end\n     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n     *\n     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n     * list could represent the state of the offset tree at a given point:\n     *\n     * * Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n     * * Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n     * * Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n     * * Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n     * * Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token\n     *\n     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n     * `setDesiredOffsets([30, 43], fooToken, 1);`\n     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n     * @param {Token} fromToken The token that this is offset from\n     * @param {number} offset The desired indent level\n     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n     * @returns {void}\n     */\n    setDesiredOffsets(range, fromToken, offset, force) {\n\n        /*\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n         * descriptor. The tree for the example above would have the following nodes:\n         *\n         * * key: 0, value: { offset: 0, from: null }\n         * * key: 15, value: { offset: 1, from: barToken }\n         * * key: 30, value: { offset: 1, from: fooToken }\n         * * key: 43, value: { offset: 2, from: barToken }\n         * * key: 820, value: { offset: 1, from: bazToken }\n         *\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\n         * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary\n         * search tree indexed by key.\n         */\n\n        const descriptorToInsert = { offset, from: fromToken, force };\n\n        const descriptorAfterRange = this._tree.findLe(range[1]).value;\n\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n        // First, remove any existing nodes in the range from the tree.\n        this._tree.deleteRange(range[0] + 1, range[1]);\n\n        // Insert a new node into the tree for this range\n        this._tree.insert(range[0], descriptorToInsert);\n\n        /*\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n         * even if it's in the current range.\n         */\n        if (fromTokenIsInRange) {\n            this._tree.insert(fromToken.range[0], fromTokenDescriptor);\n            this._tree.insert(fromToken.range[1], descriptorToInsert);\n        }\n\n        /*\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n         * tokens the same as it was before.\n         */\n        this._tree.insert(range[1], descriptorAfterRange);\n    }\n\n    /**\n     * Gets the desired indent of a token\n     * @param {Token} token The token\n     * @returns {string} The desired indent of the token\n     */\n    getDesiredIndent(token) {\n        if (!this._desiredIndentCache.has(token)) {\n\n            if (this._ignoredTokens.has(token)) {\n\n                /*\n                 * If the token is ignored, use the actual indent of the token as the desired indent.\n                 * This ensures that no errors are reported for this token.\n                 */\n                this._desiredIndentCache.set(\n                    token,\n                    this._tokenInfo.getTokenIndent(token)\n                );\n            } else if (this._lockedFirstTokens.has(token)) {\n                const firstToken = this._lockedFirstTokens.get(token);\n\n                this._desiredIndentCache.set(\n                    token,\n\n                    // (indentation for the first element's line)\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n\n                        // (space between the start of the first element's line and the first element)\n                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)\n                );\n            } else {\n                const offsetInfo = this._getOffsetDescriptor(token);\n                const offset = (\n                    offsetInfo.from &&\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\n                    !/^\\s*?\\n/u.test(token.value) &&\n                    !offsetInfo.force\n                ) ? 0 : offsetInfo.offset * this._indentSize;\n\n                this._desiredIndentCache.set(\n                    token,\n                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset)\n                );\n            }\n        }\n        return this._desiredIndentCache.get(token);\n    }\n\n    /**\n     * Ignores a token, preventing it from being reported.\n     * @param {Token} token The token\n     * @returns {void}\n     */\n    ignoreToken(token) {\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\n            this._ignoredTokens.add(token);\n        }\n    }\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n    getFirstDependency(token) {\n        return this._getOffsetDescriptor(token).from;\n    }\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n    oneOf: [\n        {\n            type: \"integer\",\n            minimum: 0\n        },\n        {\n            enum: [\"first\", \"off\"]\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0,\n                        default: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            ELEMENT_LIST_SCHEMA,\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: ELEMENT_LIST_SCHEMA,\n                                    let: ELEMENT_LIST_SCHEMA,\n                                    const: ELEMENT_LIST_SCHEMA\n                                },\n                                additionalProperties: false\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    MemberExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            arguments: ELEMENT_LIST_SCHEMA\n                        },\n                        additionalProperties: false\n                    },\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\n                    flatTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    offsetTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoredNodes: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            not: {\n                                pattern: \":exit$\"\n                            }\n                        }\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = 1;\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: 1,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            MemberExpression: 1,\n            ArrayExpression: 1,\n            ObjectExpression: 1,\n            ImportDeclaration: 1,\n            flatTernaryExpressions: false,\n            ignoredNodes: [],\n            ignoreComments: false\n        };\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                Object.assign(options, context.options[1]);\n\n                if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n                    options.VariableDeclarator = {\n                        var: options.VariableDeclarator,\n                        let: options.VariableDeclarator,\n                        const: options.VariableDeclarator\n                    };\n                }\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n        const tokenInfo = new TokenInfo(sourceCode);\n        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\");\n        const parameterParens = new WeakSet();\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Token violating the indent rule\n         * @param {string} neededIndent Expected indentation string\n         * @returns {void}\n         */\n        function report(token, neededIndent) {\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n\n            context.report({\n                node: token,\n                messageId: \"wrongIndentation\",\n                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n                loc: {\n                    start: { line: token.loc.start.line, column: 0 },\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\n                },\n                fix(fixer) {\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\n                    const newText = neededIndent;\n\n                    return fixer.replaceTextRange(range, newText);\n                }\n            });\n        }\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {string} desiredIndent Desired indentation of the string\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n        function validateTokenIndent(token, desiredIndent) {\n            const indentation = tokenInfo.getTokenIndent(token);\n\n            return indentation === desiredIndent ||\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n\n            /*\n             * Verify that the node is an IIFE\n             */\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n            let statement = node.parent && node.parent.parent;\n\n            while (\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 ||\n                statement.type === \"AssignmentExpression\" ||\n                statement.type === \"LogicalExpression\" ||\n                statement.type === \"SequenceExpression\" ||\n                statement.type === \"VariableDeclarator\"\n            ) {\n                statement = statement.parent;\n            }\n\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n        }\n\n        /**\n         * Counts the number of linebreaks that follow the last non-whitespace character in a string\n         * @param {string} string The string to check\n         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\n         * or the total number of linebreaks if the string is all whitespace.\n         */\n        function countTrailingLinebreaks(string) {\n            const trailingWhitespace = string.match(/\\s*$/u)[0];\n            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n\n            return linebreakMatches === null ? 0 : linebreakMatches.length;\n        }\n\n        /**\n         * Check indentation for lists of elements (arrays, objects, function params)\n         * @param {ASTNode[]} elements List of elements that should be offset\n         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n         * @param {Token} endToken The end token of the list, e.g. ']'\n         * @param {number|string} offset The amount that the elements should be offset\n         * @returns {void}\n         */\n        function addElementListIndent(elements, startToken, endToken, offset) {\n\n            /**\n             * Gets the first token of a given element, including surrounding parentheses.\n             * @param {ASTNode} element A node in the `elements` list\n             * @returns {Token} The first token of this element\n             */\n            function getFirstToken(element) {\n                let token = sourceCode.getTokenBefore(element);\n\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n                    token = sourceCode.getTokenBefore(token);\n                }\n                return sourceCode.getTokenAfter(token);\n            }\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            offsets.setDesiredOffsets(\n                [startToken.range[1], endToken.range[0]],\n                startToken,\n                typeof offset === \"number\" ? offset : 1\n            );\n            offsets.setDesiredOffset(endToken, startToken, 0);\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n            if (offset === \"first\" && elements.length && !elements[0]) {\n                return;\n            }\n            elements.forEach((element, index) => {\n                if (!element) {\n\n                    // Skip holes in arrays\n                    return;\n                }\n                if (offset === \"off\") {\n\n                    // Ignore the first token of every element if the \"off\" option is used\n                    offsets.ignoreToken(getFirstToken(element));\n                }\n\n                // Offset the following elements correctly relative to the first element\n                if (index === 0) {\n                    return;\n                }\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n                } else {\n                    const previousElement = elements[index - 1];\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n                    if (\n                        previousElement &&\n                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line\n                    ) {\n                        offsets.setDesiredOffsets(\n                            [previousElement.range[1], element.range[1]],\n                            firstTokenOfPreviousElement,\n                            0\n                        );\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function addBlocklessNodeIndent(node) {\n            if (node.type !== \"BlockStatement\") {\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n\n                let firstBodyToken = sourceCode.getFirstToken(node);\n                let lastBodyToken = sourceCode.getLastToken(node);\n\n                while (\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\n                ) {\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n                }\n\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n\n                /*\n                 * For blockless nodes with semicolon-first style, don't indent the semicolon.\n                 * e.g.\n                 * if (foo) bar()\n                 * ; [1, 2, 3].map(foo)\n                 */\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\n                    offsets.setDesiredOffset(lastToken, lastParentToken, 0);\n                }\n            }\n        }\n\n        /**\n         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n         * @param {ASTNode} node A CallExpression or NewExpression node\n         * @returns {void}\n         */\n        function addFunctionCallIndent(node) {\n            let openingParen;\n\n            if (node.arguments.length) {\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n            } else {\n                openingParen = sourceCode.getLastToken(node, 1);\n            }\n            const closingParen = sourceCode.getLastToken(node);\n\n            parameterParens.add(openingParen);\n            parameterParens.add(closingParen);\n\n            /*\n             * If `?.` token exists, set desired offset for that.\n             * This logic is copied from `MemberExpression`'s.\n             */\n            if (node.optional) {\n                const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n                const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;\n                const firstTokenOfCallee = calleeParenCount\n                    ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 })\n                    : sourceCode.getFirstToken(node.callee);\n                const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n                const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line\n                    ? lastTokenOfCallee\n                    : firstTokenOfCallee;\n\n                offsets.setDesiredOffset(dotToken, offsetBase, 1);\n            }\n\n            const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n            const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n\n            offsets.setDesiredOffset(openingParen, offsetToken, 0);\n\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n        }\n\n        /**\n         * Checks the indentation of parenthesized values, given a list of tokens in a program\n         * @param {Token[]} tokens A list of tokens\n         * @returns {void}\n         */\n        function addParensIndent(tokens) {\n            const parenStack = [];\n            const parenPairs = [];\n\n            tokens.forEach(nextToken => {\n\n                // Accumulate a list of parenthesis pairs\n                if (astUtils.isOpeningParenToken(nextToken)) {\n                    parenStack.push(nextToken);\n                } else if (astUtils.isClosingParenToken(nextToken)) {\n                    parenPairs.unshift({ left: parenStack.pop(), right: nextToken });\n                }\n            });\n\n            parenPairs.forEach(pair => {\n                const leftParen = pair.left;\n                const rightParen = pair.right;\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n\n                    parenthesizedTokens.forEach(token => {\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n                            offsets.setDesiredOffset(token, leftParen, 1);\n                        }\n                    });\n                }\n\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\n            });\n        }\n\n        /**\n         * Ignore all tokens within an unknown node whose offset do not depend\n         * on another token's offset within the unknown node\n         * @param {ASTNode} node Unknown Node\n         * @returns {void}\n         */\n        function ignoreNode(node) {\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\n\n            unknownNodeTokens.forEach(token => {\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n                    if (token === firstTokenOfLine) {\n                        offsets.ignoreToken(token);\n                    } else {\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check whether the given token is on the first line of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is on the first line of a statement.\n         */\n        function isOnFirstLineOfStatement(token, leafNode) {\n            let node = leafNode;\n\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n                node = node.parent;\n            }\n            node = node.parent;\n\n            return !node || node.loc.start.line === token.loc.start.line;\n        }\n\n        /**\n         * Check whether there are any blank (whitespace-only) lines between\n         * two tokens on separate lines.\n         * @param {Token} firstToken The first token.\n         * @param {Token} secondToken The second token.\n         * @returns {boolean} `true` if the tokens are on separate lines and\n         *   there exists a blank line between them, `false` otherwise.\n         */\n        function hasBlankLinesBetween(firstToken, secondToken) {\n            const firstTokenLine = firstToken.loc.end.line;\n            const secondTokenLine = secondToken.loc.start.line;\n\n            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n                return false;\n            }\n\n            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n                if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        const ignoredNodeFirstTokens = new Set();\n\n        const baseOffsetListeners = {\n            \"ArrayExpression, ArrayPattern\"(node) {\n                const openingBracket = sourceCode.getFirstToken(node);\n                const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);\n\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n            },\n\n            \"ObjectExpression, ObjectPattern\"(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getTokenAfter(\n                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,\n                    astUtils.isClosingBraceToken\n                );\n\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n            },\n\n            ArrowFunctionExpression(node) {\n                const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });\n\n                if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n                    const openingParen = maybeOpeningParen;\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n\n                    parameterParens.add(openingParen);\n                    parameterParens.add(closingParen);\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n                }\n\n                addBlocklessNodeIndent(node.body);\n            },\n\n            AssignmentExpression(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n            },\n\n            \"BinaryExpression, LogicalExpression\"(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                /*\n                 * For backwards compatibility, don't check BinaryExpression indents, e.g.\n                 * var foo = bar &&\n                 *                   baz;\n                 */\n\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(tokenAfterOperator);\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n            },\n\n            \"BlockStatement, ClassBody\"(node) {\n                let blockIndentLevel;\n\n                if (node.parent && isOuterIIFE(node.parent)) {\n                    blockIndentLevel = options.outerIIFEBody;\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n                    blockIndentLevel = options.FunctionExpression.body;\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n                    blockIndentLevel = options.FunctionDeclaration.body;\n                } else {\n                    blockIndentLevel = 1;\n                }\n\n                /*\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\n                 * is aligned with the parent.\n                 */\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n                }\n\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n            },\n\n            CallExpression: addFunctionCallIndent,\n\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n                const classToken = sourceCode.getFirstToken(node);\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n            },\n\n            ConditionalExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n                if (!options.flatTernaryExpressions ||\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\n                    isOnFirstLineOfStatement(firstToken, node)\n                ) {\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\n\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken,\n                        firstConsequentToken.type === \"Punctuator\" &&\n                        options.offsetTernaryExpressions ? 2 : 1);\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n                    } else {\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken,\n                            firstAlternateToken.type === \"Punctuator\" &&\n                            options.offsetTernaryExpressions ? 2 : 1);\n                    }\n                }\n            },\n\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\n\n            ExportNamedDeclaration(node) {\n                if (node.declaration === null) {\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\n\n                    if (node.source) {\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n                    }\n                }\n            },\n\n            ForStatement(node) {\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n                if (node.init) {\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n                }\n                if (node.test) {\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n                }\n                if (node.update) {\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            \"FunctionDeclaration, FunctionExpression\"(node) {\n                const closingParen = sourceCode.getTokenBefore(node.body);\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n            },\n\n            IfStatement(node) {\n                addBlocklessNodeIndent(node.consequent);\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    addBlocklessNodeIndent(node.alternate);\n                }\n            },\n\n            ImportDeclaration(node) {\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n                }\n\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n                const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n                const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n                if (fromToken) {\n                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n\n                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n                }\n            },\n\n            ImportExpression(node) {\n                const openingParen = sourceCode.getFirstToken(node, 1);\n                const closingParen = sourceCode.getLastToken(node);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n\n                addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n            },\n\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\n                const firstObjectToken = objectParenCount\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\n                    : sourceCode.getFirstToken(object);\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n                if (node.computed) {\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n                }\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\n                    ? lastObjectToken\n                    : firstObjectToken;\n\n                if (typeof options.MemberExpression === \"number\") {\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n                } else {\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n                    offsets.ignoreToken(firstNonObjectToken);\n                    offsets.ignoreToken(secondNonObjectToken);\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n                }\n            },\n\n            NewExpression(node) {\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n                if (node.arguments.length > 0 ||\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n                    addFunctionCallIndent(node);\n                }\n            },\n\n            Property(node) {\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n                }\n            },\n\n            SwitchStatement(node) {\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n                if (node.cases.length) {\n                    sourceCode.getTokensBetween(\n                        node.cases[node.cases.length - 1],\n                        closingCurly,\n                        { includeComments: true, filter: astUtils.isCommentToken }\n                    ).forEach(token => offsets.ignoreToken(token));\n                }\n            },\n\n            SwitchCase(node) {\n                if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n                    const caseKeyword = sourceCode.getFirstToken(node);\n                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n\n                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n                }\n            },\n\n            TemplateLiteral(node) {\n                node.expressions.forEach((expression, index) => {\n                    const previousQuasi = node.quasis[index];\n                    const nextQuasi = node.quasis[index + 1];\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line\n                        ? sourceCode.getFirstToken(previousQuasi)\n                        : null;\n\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n                });\n            },\n\n            VariableDeclaration(node) {\n                let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind)\n                    ? options.VariableDeclarator[node.kind]\n                    : DEFAULT_VARIABLE_INDENT;\n\n                const firstToken = sourceCode.getFirstToken(node),\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (options.VariableDeclarator[node.kind] === \"first\") {\n                    if (node.declarations.length > 1) {\n                        addElementListIndent(\n                            node.declarations,\n                            firstToken,\n                            lastToken,\n                            \"first\"\n                        );\n                        return;\n                    }\n\n                    variableIndent = DEFAULT_VARIABLE_INDENT;\n                }\n\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n                } else {\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n                }\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    offsets.ignoreToken(lastToken);\n                }\n            },\n\n            VariableDeclarator(node) {\n                if (node.init) {\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n\n                    offsets.ignoreToken(equalOperator);\n                    offsets.ignoreToken(tokenAfterOperator);\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n                }\n            },\n\n            \"JSXAttribute[value]\"(node) {\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n            },\n\n            JSXElement(node) {\n                if (node.closingElement) {\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n                }\n            },\n\n            JSXOpeningElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                let closingToken;\n\n                if (node.selfClosing) {\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n                } else {\n                    closingToken = sourceCode.getLastToken(node);\n                }\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\n            },\n\n            JSXClosingElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n            },\n\n            JSXFragment(node) {\n                const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n                const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n\n                addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n            },\n\n            JSXOpeningFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const closingToken = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, closingToken);\n            },\n\n            JSXClosingFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const slashToken = sourceCode.getLastToken(node, { skip: 1 });\n                const closingToken = sourceCode.getLastToken(node);\n                const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, tokenToMatch);\n            },\n\n            JSXExpressionContainer(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            JSXSpreadAttribute(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            \"*\"(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // Ensure that the children of every node are indented at least as much as the first token.\n                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n                    offsets.setDesiredOffsets(node.range, firstToken, 0);\n                }\n            }\n        };\n\n        const listenerCallQueue = [];\n\n        /*\n         * To ignore the indentation of a node:\n         * 1. Don't call the node's listener when entering it (if it has a listener)\n         * 2. Don't set any offsets against the first token of the node.\n         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n         */\n        const offsetListeners = lodash.mapValues(\n            baseOffsetListeners,\n\n            /*\n             * Offset listener calls are deferred until traversal is finished, and are called as\n             * part of the final `Program:exit` listener. This is necessary because a node might\n             * be matched by multiple selectors.\n             *\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n             * should not have been called at all. Without doing extra selector matching, we don't know\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n             * `MemberExpression > Identifier` listener is called.\n             *\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n             * ignored nodes are known.\n             */\n            listener =>\n                node =>\n                    listenerCallQueue.push({ listener, node })\n        );\n\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n        const ignoredNodes = new Set();\n\n        /**\n         * Ignores a node\n         * @param {ASTNode} node The node to ignore\n         * @returns {void}\n         */\n        function addToIgnoredNodes(node) {\n            ignoredNodes.add(node);\n            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n        }\n\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\n            {}\n        );\n\n        /*\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n         * at the end.\n         *\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n         * so those listeners wouldn't be called anyway.\n         */\n        return Object.assign(\n            offsetListeners,\n            ignoredNodeListeners,\n            {\n                \"*:exit\"(node) {\n\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n                    if (!KNOWN_NODES.has(node.type)) {\n                        addToIgnoredNodes(node);\n                    }\n                },\n                \"Program:exit\"() {\n\n                    // If ignoreComments option is enabled, ignore all comment tokens.\n                    if (options.ignoreComments) {\n                        sourceCode.getAllComments()\n                            .forEach(comment => offsets.ignoreToken(comment));\n                    }\n\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\n                    listenerCallQueue\n                        .filter(nodeInfo => !ignoredNodes.has(nodeInfo.node))\n                        .forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));\n\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n                    ignoredNodes.forEach(ignoreNode);\n\n                    addParensIndent(sourceCode.ast.tokens);\n\n                    /*\n                     * Create a Map from (tokenOrComment) => (precedingToken).\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                     */\n                    const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\n                    }, new WeakMap());\n\n                    sourceCode.lines.forEach((line, lineIndex) => {\n                        const lineNumber = lineIndex + 1;\n\n                        if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\n\n                            // Don't check indentation on blank lines\n                            return;\n                        }\n\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\n\n                        if (firstTokenOfLine.loc.start.line !== lineNumber) {\n\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n                            return;\n                        }\n\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n                            /*\n                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\n                             *\n                             * let foo\n                             * // comment\n                             * ;(async () => {})()\n                             */\n                            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n                                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n                            }\n\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n                            if (\n                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\n                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\n                            ) {\n                                return;\n                            }\n                        }\n\n                        // If the token matches the expected indentation, don't report it.\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n                            return;\n                        }\n\n                        // Otherwise, report the token/comment.\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n                    });\n                }\n            }\n        );\n    }\n};\n","/**\n * @fileoverview A rule to control the style of variable initializations.\n * @author Colin Ihrig\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a for loop.\n * @param {ASTNode} block A node to check.\n * @returns {boolean} `true` when the node is a for loop.\n */\nfunction isForLoop(block) {\n    return block.type === \"ForInStatement\" ||\n    block.type === \"ForOfStatement\" ||\n    block.type === \"ForStatement\";\n}\n\n/**\n * Checks whether or not a given declarator node has its initializer.\n * @param {ASTNode} node A declarator node to check.\n * @returns {boolean} `true` when the node has its initializer.\n */\nfunction isInitialized(node) {\n    const declaration = node.parent;\n    const block = declaration.parent;\n\n    if (isForLoop(block)) {\n        if (block.type === \"ForStatement\") {\n            return block.init === declaration;\n        }\n        return block.left === declaration;\n    }\n    return Boolean(node.init);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow initialization in variable declarations\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/init-declarations\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreForLoopInit: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n        messages: {\n            initialized: \"Variable '{{idName}}' should be initialized on declaration.\",\n            notInitialized: \"Variable '{{idName}}' should not be initialized on declaration.\"\n        }\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n        const params = context.options[1] || {};\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n\n                const kind = node.kind,\n                    declarations = node.declarations;\n\n                for (let i = 0; i < declarations.length; ++i) {\n                    const declaration = declarations[i],\n                        id = declaration.id,\n                        initialized = isInitialized(declaration),\n                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);\n                    let messageId = \"\";\n\n                    if (mode === MODE_ALWAYS && !initialized) {\n                        messageId = \"initialized\";\n                    } else if (mode === MODE_NEVER && kind !== \"const\" && initialized && !isIgnoredForLoop) {\n                        messageId = \"notInitialized\";\n                    }\n\n                    if (id.type === \"Identifier\" && messageId) {\n                        context.report({\n                            node: declaration,\n                            messageId,\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure consistent quotes used in jsx syntax.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    \"prefer-double\": {\n        quote: \"\\\"\",\n        description: \"singlequote\",\n        convert(str) {\n            return str.replace(/'/gu, \"\\\"\");\n        }\n    },\n    \"prefer-single\": {\n        quote: \"'\",\n        description: \"doublequote\",\n        convert(str) {\n            return str.replace(/\"/gu, \"'\");\n        }\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the consistent use of either double or single quotes in JSX attributes\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/jsx-quotes\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"prefer-single\", \"prefer-double\"]\n            }\n        ],\n        messages: {\n            unexpected: \"Unexpected usage of {{description}}.\"\n        }\n    },\n\n    create(context) {\n        const quoteOption = context.options[0] || \"prefer-double\",\n            setting = QUOTE_SETTINGS[quoteOption];\n\n        /**\n         * Checks if the given string literal node uses the expected quotes\n         * @param {ASTNode} node A string literal node.\n         * @returns {boolean} Whether or not the string literal used the expected quotes.\n         * @public\n         */\n        function usesExpectedQuotes(node) {\n            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);\n        }\n\n        return {\n            JSXAttribute(node) {\n                const attributeValue = node.value;\n\n                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {\n                    context.report({\n                        node: attributeValue,\n                        messageId: \"unexpected\",\n                        data: {\n                            description: setting.description\n                        },\n                        fix(fixer) {\n                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Checks whether the properties on a single line.\n * @param {ASTNode[]} properties List of Property AST nodes.\n * @returns {boolean} True if all properties is on a single line.\n */\nfunction isSingleLineProperties(properties) {\n    const [firstProp] = properties,\n        lastProp = last(properties);\n\n    return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n            return astUtils.getStaticPropertyName(property);\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n            const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n            const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n            const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifyListSpacing(properties, lineOptions) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], lineOptions);\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                const properties = group.filter(isKeyValueProperty);\n\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\n                    verifyListSpacing(properties, multiLineOptions);\n                } else {\n                    verifyGroupAlignment(properties);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n * @param {Token} token A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/keyword-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: true },\n                    after: { type: \"boolean\", default: true },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\" },\n                                    after: { type: \"boolean\" }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n            expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n            unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n            unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: { start: prevToken.loc.end, end: token.loc.start },\n                    messageId: \"unexpectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc,\n                    messageId: \"expectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         * @param {Token} token A token to report.\n         * @param {RegExp} pattern A pattern of the next token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n\n                context.report({\n                    loc: { start: token.loc.end, end: nextToken.loc.start },\n                    messageId: \"unexpectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         * @param {Object|undefined} options The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options = {}) {\n            const before = options.before !== false;\n            const after = options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         * @param {Token} token A token to report.\n         * @param {RegExp} [pattern] Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         * @param {Token} token A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         * @param {ASTNode|null} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            if (node.await) {\n                checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n                checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n            } else {\n                checkSpacingAroundFirstToken(node);\n            }\n            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.type === \"ExportDefaultDeclaration\") {\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n            }\n\n            if (node.type === \"ExportAllDeclaration\" && node.exported) {\n                const asToken = sourceCode.getTokenBefore(node.exported);\n\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\n            }\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce the position of line comments\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce position of line comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/line-comment-position\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"above\", \"beside\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            position: {\n                                enum: [\"above\", \"beside\"]\n                            },\n                            ignorePattern: {\n                                type: \"string\"\n                            },\n                            applyDefaultPatterns: {\n                                type: \"boolean\"\n                            },\n                            applyDefaultIgnorePatterns: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            above: \"Expected comment to be above code.\",\n            beside: \"Expected comment to be beside code.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n\n        let above,\n            ignorePattern,\n            applyDefaultIgnorePatterns = true;\n\n        if (!options || typeof options === \"string\") {\n            above = !options || options === \"above\";\n\n        } else {\n            above = !options.position || options.position === \"above\";\n            ignorePattern = options.ignorePattern;\n\n            if (Object.prototype.hasOwnProperty.call(options, \"applyDefaultIgnorePatterns\")) {\n                applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;\n            } else {\n                applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;\n            }\n        }\n\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const fallThroughRegExp = /^\\s*falls?\\s?through/u;\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type === \"Line\").forEach(node => {\n                    if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {\n                        return;\n                    }\n\n                    if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n                        return;\n                    }\n\n                    const previous = sourceCode.getTokenBefore(node, { includeComments: true });\n                    const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;\n\n                    if (above) {\n                        if (isOnSameLine) {\n                            context.report({\n                                node,\n                                messageId: \"above\"\n                            });\n                        }\n                    } else {\n                        if (!isOnSameLine) {\n                            context.report({\n                                node,\n                                messageId: \"beside\"\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/linebreak-style\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ],\n        messages: {\n            expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForLinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: {\n                                line: i,\n                                column: sourceCode.lines[i - 1].length\n                            },\n                            end: {\n                                line: i + 1,\n                                column: 0\n                            }\n                        },\n                        messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    afterLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowClassStart: {\n                        type: \"boolean\"\n                    },\n                    allowClassEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            after: \"Expected line after comment.\",\n            before: \"Expected line before comment.\"\n        }\n    },\n\n    create(context) {\n\n        const options = Object.assign({}, context.options[0]);\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n\n        const sourceCode = context.getSourceCode();\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            return sourceCode.getNodeByRangeIndex(token.range[0]);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    token.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class start.\n         */\n        function isCommentAtClassStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class end.\n         */\n        function isCommentAtClassEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart &&\n                    isCommentAtBlockStart(token) &&\n                    !(options.allowClassStart === false &&\n                    isCommentAtClassStart(token)),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    messageId: \"before\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    messageId: \"after\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line between class members\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const curLast = sourceCode.getLastToken(body[i]);\n                    const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return isPadded\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce a maximum number of classes per file\n * @author James Garbutt <https://github.com/43081j>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of classes per file\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-classes-per-file\"\n        },\n\n        schema: [\n            {\n                type: \"integer\",\n                minimum: 1\n            }\n        ],\n\n        messages: {\n            maximumExceeded: \"File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}.\"\n        }\n    },\n    create(context) {\n\n        const maxClasses = context.options[0] || 1;\n\n        let classCount = 0;\n\n        return {\n            Program() {\n                classCount = 0;\n            },\n            \"Program:exit\"(node) {\n                if (classCount > maxClasses) {\n                    context.report({\n                        node,\n                        messageId: \"maximumExceeded\",\n                        data: {\n                            classCount,\n                            max: maxClasses\n                        }\n                    });\n                }\n            },\n            \"ClassDeclaration, ClassExpression\"() {\n                classCount++;\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum depth block can be nested in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum depth that blocks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-depth\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            tooDeeply: \"Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0];\n        let maxDepth = 4;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            maxDepth = option.maximum || option.max;\n        }\n        if (typeof option === \"number\") {\n            maxDepth = option;\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * When parsing is done then pop out the reference\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n        }\n\n        /**\n         * Save the block and Evaluate the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function pushBlock(node) {\n            const len = ++functionStack[functionStack.length - 1];\n\n            if (len > maxDepth) {\n                context.report({ node, messageId: \"tooDeeply\", data: { depth: len, maxDepth } });\n            }\n        }\n\n        /**\n         * Pop the saved block\n         * @returns {void}\n         * @private\n         */\n        function popBlock() {\n            functionStack[functionStack.length - 1]--;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    pushBlock(node);\n                }\n            },\n            SwitchStatement: pushBlock,\n            TryStatement: pushBlock,\n            DoWhileStatement: pushBlock,\n            WhileStatement: pushBlock,\n            WithStatement: pushBlock,\n            ForStatement: pushBlock,\n            ForInStatement: pushBlock,\n            ForOfStatement: pushBlock,\n\n            \"IfStatement:exit\": popBlock,\n            \"SwitchStatement:exit\": popBlock,\n            \"TryStatement:exit\": popBlock,\n            \"DoWhileStatement:exit\": popBlock,\n            \"WhileStatement:exit\": popBlock,\n            \"WithStatement:exit\": popBlock,\n            \"ForStatement:exit\": popBlock,\n            \"ForInStatement:exit\": popBlock,\n            \"ForOfStatement:exit\": popBlock,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"Program:exit\": endFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreStrings: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\"\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-len\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ],\n        messages: {\n            max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n            maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/gu, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        const options = Object.assign({}, context.options[context.options.length - 1]);\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = typeof options.code === \"number\" ? options.code : 80,\n            tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n            ignoreComments = !!options.ignoreComments,\n            ignoreStrings = !!options.ignoreStrings,\n            ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n            ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n            ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n            ignoreUrls = !!options.ignoreUrls,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern, \"u\");\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\n         */\n        function isJSXEmptyExpressionInSingleLineContainer(node) {\n            if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitespace\n         */\n        function stripTrailingComment(line, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {*} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => (token.type === \"String\" ||\n                (token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\")));\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n\n        /**\n         * A reducer to group an AST node by line number, both start and end.\n         * @param {Object} acc the accumulator\n         * @param {ASTNode} node the AST node in question\n         * @returns {Object} the modified accumulator\n         * @private\n         */\n        function groupByLineNumber(acc, node) {\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n                ensureArrayAndPush(acc, i, node);\n            }\n            return acc;\n        }\n\n        /**\n         * Returns an array of all comments in the source code.\n         * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\n         * the element is changed with JSXExpressionContainer node.\n         * @returns {ASTNode[]} An array of comment nodes\n         */\n        function getAllComments() {\n            const comments = [];\n\n            sourceCode.getAllComments()\n                .forEach(commentNode => {\n                    const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n\n                    if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n\n                        // push a unique node only\n                        if (comments[comments.length - 1] !== containingNode.parent) {\n                            comments.push(containingNode.parent);\n                        }\n                    } else {\n                        comments.push(commentNode);\n                    }\n                });\n\n            return comments;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\n\n            // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings();\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\n\n            const templateLiterals = getAllTemplateLiterals();\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n\n            const regExpLiterals = getAllRegExpLiterals();\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n                let textToMeasure;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                        textToMeasure = line;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        textToMeasure = stripTrailingComment(line, comment);\n\n                        // ignore multiple trailing comments in the same line\n                        let lastIndex = commentsIndex;\n\n                        while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n                            textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n                        }\n                    } else {\n                        textToMeasure = line;\n                    }\n                } else {\n                    textToMeasure = line;\n                }\n                if (ignorePattern && ignorePattern.test(textToMeasure) ||\n                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(textToMeasure, tabWidth);\n                const commentLengthApplies = lineIsComment && maxCommentLength;\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                const loc = {\n                    start: {\n                        line: lineNumber,\n                        column: 0\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: textToMeasure.length\n                    }\n                };\n\n                if (commentLengthApplies) {\n                    if (lineLength > maxCommentLength) {\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"maxComment\",\n                            data: {\n                                lineLength,\n                                maxCommentLength\n                            }\n                        });\n                    }\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc,\n                        messageId: \"max\",\n                        data: {\n                            lineLength,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum number of line of code in a function.\n * @author Pete Ward <peteward44@gmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        max: {\n            type: \"integer\",\n            minimum: 0\n        },\n        skipComments: {\n            type: \"boolean\"\n        },\n        skipBlankLines: {\n            type: \"boolean\"\n        },\n        IIFEs: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    oneOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 1\n        }\n    ]\n};\n\n/**\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\n * @param {Array} comments An array of comment nodes.\n * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.\n */\nfunction getCommentLineNumbers(comments) {\n    const map = new Map();\n\n    comments.forEach(comment => {\n        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n            map.set(i, comment);\n        }\n    });\n    return map;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines of code in a function\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA\n        ],\n        messages: {\n            exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const lines = sourceCode.lines;\n\n        const option = context.options[0];\n        let maxLines = 50;\n        let skipComments = false;\n        let skipBlankLines = false;\n        let IIFEs = false;\n\n        if (typeof option === \"object\") {\n            maxLines = typeof option.max === \"number\" ? option.max : 50;\n            skipComments = !!option.skipComments;\n            skipBlankLines = !!option.skipBlankLines;\n            IIFEs = !!option.IIFEs;\n        } else if (typeof option === \"number\") {\n            maxLines = option;\n        }\n\n        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || isFirstTokenOnLine) &&\n                (end.line > lineNumber || isLastTokenOnLine);\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is part of an IIFE\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's an IIFE\n         */\n        function isIIFE(node) {\n            return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\n         */\n        function isEmbedded(node) {\n            if (!node.parent) {\n                return false;\n            }\n            if (node !== node.parent.value) {\n                return false;\n            }\n            if (node.parent.type === \"MethodDefinition\") {\n                return true;\n            }\n            if (node.parent.type === \"Property\") {\n                return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n            }\n            return false;\n        }\n\n        /**\n         * Count the lines in the function\n         * @param {ASTNode} funcNode Function AST node\n         * @returns {void}\n         * @private\n         */\n        function processFunction(funcNode) {\n            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n            if (!IIFEs && isIIFE(node)) {\n                return;\n            }\n            let lineCount = 0;\n\n            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n                const line = lines[i];\n\n                if (skipComments) {\n                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n                        continue;\n                    }\n                }\n\n                if (skipBlankLines) {\n                    if (line.match(/^\\s*$/u)) {\n                        continue;\n                    }\n                }\n\n                lineCount++;\n            }\n\n            if (lineCount > maxLines) {\n                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(funcNode));\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, lineCount, maxLines }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: processFunction,\n            FunctionExpression: processFunction,\n            ArrowFunctionExpression: processFunction\n        };\n    }\n};\n","/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed:\n                \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (\n            typeof option === \"object\" &&\n            Object.prototype.hasOwnProperty.call(option, \"max\")\n        ) {\n            max = option.max;\n        } else if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {number[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return lodash.range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({\n                    lineNumber: i + 1,\n                    text\n                }));\n\n                /*\n                 * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\n                 * That isn't a real line, so we shouldn't count it.\n                 */\n                if (lines.length > 1 && lodash.last(lines).text === \"\") {\n                    lines.pop();\n                }\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = lodash.flatten(\n                        comments.map(comment => getLinesWithoutCode(comment))\n                    );\n\n                    lines = lines.filter(\n                        l => !commentLines.includes(l.lineNumber)\n                    );\n                }\n\n                if (lines.length > max) {\n                    const loc = {\n                        start: {\n                            line: lines[max].lineNumber,\n                            column: 0\n                        },\n                        end: {\n                            line: sourceCode.lines.length,\n                            column: lodash.last(sourceCode.lines).length\n                        }\n                    };\n\n                    context.report({\n                        loc,\n                        messageId: \"exceed\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a maximum number of nested callbacks.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum depth that callbacks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-nested-callbacks\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Constants\n        //--------------------------------------------------------------------------\n        const option = context.options[0];\n        let THRESHOLD = 10;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            THRESHOLD = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const callbackStack = [];\n\n        /**\n         * Checks a given function node for too many callbacks.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"CallExpression\") {\n                callbackStack.push(node);\n            }\n\n            if (callbackStack.length > THRESHOLD) {\n                const opts = { num: callbackStack.length, max: THRESHOLD };\n\n                context.report({ node, messageId: \"exceed\", data: opts });\n            }\n        }\n\n        /**\n         * Pops the call stack.\n         * @returns {void}\n         * @private\n         */\n        function popStack() {\n            callbackStack.pop();\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            \"ArrowFunctionExpression:exit\": popStack,\n\n            FunctionExpression: checkFunction,\n            \"FunctionExpression:exit\": popStack\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when a function has too many parameters\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of parameters in function definitions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-params\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0];\n        let numParams = 3;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            numParams = option.maximum || option.max;\n        }\n        if (typeof option === \"number\") {\n            numParams = option;\n        }\n\n        /**\n         * Checks a function to see if it has too many parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            if (node.params.length > numParams) {\n                context.report({\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    node,\n                    messageId: \"exceed\",\n                    data: {\n                        name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),\n                        count: node.params.length,\n                        max: numParams\n                    }\n                });\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            ArrowFunctionExpression: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Specify the maximum number of statements allowed per line.\n * @author Kenneth Williams\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce a maximum number of statements allowed per line\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-statements-per-line\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 1,\n                        default: 1\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            exceed: \"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1;\n\n        let lastStatementLine = 0,\n            numberOfStatementsOnThisLine = 0,\n            firstExtraStatement;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;\n\n        /**\n         * Reports with the first extra statement, and clears it.\n         * @returns {void}\n         */\n        function reportFirstExtraStatementAndClear() {\n            if (firstExtraStatement) {\n                context.report({\n                    node: firstExtraStatement,\n                    messageId: \"exceed\",\n                    data: {\n                        numberOfStatementsOnThisLine,\n                        maxStatementsPerLine,\n                        statements: numberOfStatementsOnThisLine === 1 ? \"statement\" : \"statements\"\n                    }\n                });\n            }\n            firstExtraStatement = null;\n        }\n\n        /**\n         * Gets the actual last token of a given node.\n         * @param {ASTNode} node A node to get. This is a node except EmptyStatement.\n         * @returns {Token} The actual last token.\n         */\n        function getActualLastToken(node) {\n            return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n        }\n\n        /**\n         * Addresses a given node.\n         * It updates the state of this rule, then reports the node if the node violated this rule.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function enterStatement(node) {\n            const line = node.loc.start.line;\n\n            /*\n             * Skip to allow non-block statements if this is direct child of control statements.\n             * `if (a) foo();` is counted as 1.\n             * But `if (a) foo(); else foo();` should be counted as 2.\n             */\n            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&\n                node.parent.alternate !== node\n            ) {\n                return;\n            }\n\n            // Update state.\n            if (line === lastStatementLine) {\n                numberOfStatementsOnThisLine += 1;\n            } else {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n\n            // Reports if the node violated this rule.\n            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n                firstExtraStatement = firstExtraStatement || node;\n            }\n        }\n\n        /**\n         * Updates the state of this rule with the end line of leaving node to check with the next statement.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function leaveStatement(node) {\n            const line = getActualLastToken(node).loc.end.line;\n\n            // Update state.\n            if (line !== lastStatementLine) {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BreakStatement: enterStatement,\n            ClassDeclaration: enterStatement,\n            ContinueStatement: enterStatement,\n            DebuggerStatement: enterStatement,\n            DoWhileStatement: enterStatement,\n            ExpressionStatement: enterStatement,\n            ForInStatement: enterStatement,\n            ForOfStatement: enterStatement,\n            ForStatement: enterStatement,\n            FunctionDeclaration: enterStatement,\n            IfStatement: enterStatement,\n            ImportDeclaration: enterStatement,\n            LabeledStatement: enterStatement,\n            ReturnStatement: enterStatement,\n            SwitchStatement: enterStatement,\n            ThrowStatement: enterStatement,\n            TryStatement: enterStatement,\n            VariableDeclaration: enterStatement,\n            WhileStatement: enterStatement,\n            WithStatement: enterStatement,\n            ExportNamedDeclaration: enterStatement,\n            ExportDefaultDeclaration: enterStatement,\n            ExportAllDeclaration: enterStatement,\n\n            \"BreakStatement:exit\": leaveStatement,\n            \"ClassDeclaration:exit\": leaveStatement,\n            \"ContinueStatement:exit\": leaveStatement,\n            \"DebuggerStatement:exit\": leaveStatement,\n            \"DoWhileStatement:exit\": leaveStatement,\n            \"ExpressionStatement:exit\": leaveStatement,\n            \"ForInStatement:exit\": leaveStatement,\n            \"ForOfStatement:exit\": leaveStatement,\n            \"ForStatement:exit\": leaveStatement,\n            \"FunctionDeclaration:exit\": leaveStatement,\n            \"IfStatement:exit\": leaveStatement,\n            \"ImportDeclaration:exit\": leaveStatement,\n            \"LabeledStatement:exit\": leaveStatement,\n            \"ReturnStatement:exit\": leaveStatement,\n            \"SwitchStatement:exit\": leaveStatement,\n            \"ThrowStatement:exit\": leaveStatement,\n            \"TryStatement:exit\": leaveStatement,\n            \"VariableDeclaration:exit\": leaveStatement,\n            \"WhileStatement:exit\": leaveStatement,\n            \"WithStatement:exit\": leaveStatement,\n            \"ExportNamedDeclaration:exit\": leaveStatement,\n            \"ExportDefaultDeclaration:exit\": leaveStatement,\n            \"ExportAllDeclaration:exit\": leaveStatement,\n            \"Program:exit\": reportFirstExtraStatementAndClear\n        };\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum number of statements in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of statements allowed in function blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-statements\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    ignoreTopLevelFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            exceed: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0],\n            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n            topLevelFunctions = [];\n        let maxStatements = 10;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            maxStatements = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            maxStatements = option;\n        }\n\n        /**\n         * Reports a node if it has too many statements\n         * @param {ASTNode} node node to evaluate\n         * @param {int} count Number of statements in node\n         * @param {int} max Maximum number of statements allowed\n         * @returns {void}\n         * @private\n         */\n        function reportIfTooManyStatements(node, count, max) {\n            if (count > max) {\n                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, count, max }\n                });\n            }\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const count = functionStack.pop();\n\n            if (ignoreTopLevelFunctions && functionStack.length === 0) {\n                topLevelFunctions.push({ node, count });\n            } else {\n                reportIfTooManyStatements(node, count, maxStatements);\n            }\n        }\n\n        /**\n         * Increment the count of the functions\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function countStatements(node) {\n            functionStack[functionStack.length - 1] += node.body.length;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            BlockStatement: countStatements,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            \"Program:exit\"() {\n                if (topLevelFunctions.length === 1) {\n                    return;\n                }\n\n                topLevelFunctions.forEach(element => {\n                    const count = element.count;\n                    const node = element.node;\n\n                    reportIfTooManyStatements(node, count, maxStatements);\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a particular style for multiline comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [{ enum: [\"starred-block\", \"separate-lines\", \"bare-block\"] }],\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            expectedBareBlock: \"Expected a block comment without padding stars.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"starred-block\";\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks if a comment line is starred.\n         * @param {string} line A string representing a comment line.\n         * @returns {boolean} Whether or not the comment line is starred.\n         */\n        function isStarredCommentLine(line) {\n            return /^\\s*\\*/u.test(line);\n        }\n\n        /**\n         * Checks if a comment group is in starred-block form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in starred block form.\n         */\n        function isStarredBlockComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            // The first and last lines can only contain whitespace.\n            return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n        }\n\n        /**\n         * Checks if a comment group is in JSDoc form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in JSDoc form.\n         */\n        function isJSDocComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            return /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines[lines.length - 1]);\n        }\n\n        /**\n         * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n         * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processSeparateLineComments(commentGroup) {\n            const allLinesHaveLeadingSpace = commentGroup\n                .map(({ value }) => value)\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return commentGroup.map(({ value }) => (allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value));\n        }\n\n        /**\n         * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in starred-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processStarredBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER)\n                .filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1))\n                .map(line => line.replace(/^\\s*$/u, \"\"));\n            const allLinesHaveLeadingSpace = lines\n                .map(line => line.replace(/\\s*\\*/u, \"\"))\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n        }\n\n        /**\n         * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in bare-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processBareBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n            const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n            let offset = \"\";\n\n            /*\n             * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n             * The first line should not be checked because it is inline with the opening block comment delimiter.\n             */\n            for (const [i, line] of lines.entries()) {\n                if (!line.trim().length || i === 0) {\n                    continue;\n                }\n\n                const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n                    if (newOffset.length > offset.length) {\n                        offset = newOffset;\n                    }\n                }\n            }\n\n            return lines.map(line => {\n                const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n                const [, lineOffset, lineContents] = match;\n\n                if (lineOffset.length > leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n                }\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n                }\n\n                return lineContents;\n            });\n        }\n\n        /**\n         * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n         * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n         * @returns {string[]} A list of comment lines.\n         */\n        function getCommentLines(commentGroup) {\n            const [firstComment] = commentGroup;\n\n            if (firstComment.type === \"Line\") {\n                return processSeparateLineComments(commentGroup);\n            }\n\n            if (isStarredBlockComment(commentGroup)) {\n                return processStarredBlockComment(firstComment);\n            }\n\n            return processBareBlockComment(firstComment);\n        }\n\n        /**\n         * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n         * @param {Token} comment The token to check.\n         * @returns {string} The offset from the beginning of a line to the token.\n         */\n        function getInitialOffset(comment) {\n            return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = getInitialOffset(firstComment);\n\n            return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n                        }\n                    });\n                } else {\n                    const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLeadingWhitespace = getInitialOffset(firstComment);\n                    const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n\n                        context.report({\n                            loc: {\n                                start: firstComment.loc.start,\n                                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n                        context.report({\n                            loc: {\n                                start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },\n                                end: firstComment.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n                        const errorType = isStarredCommentLine(lineText)\n                            ? \"alignment\"\n                            : \"missingStar\";\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: lineText.length }\n                                },\n                                messageId: errorType,\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n\n                                    if (errorType === \"alignment\") {\n                                        const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                                        const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n\n                                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                                    }\n\n                                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                                    let offset;\n\n                                    for (const [idx, line] of lines.entries()) {\n                                        if (!/\\S+/u.test(line)) {\n                                            continue;\n                                        }\n\n                                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                                        const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n\n                                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                                        if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                                            offset += \" \";\n                                        }\n                                        break;\n                                    }\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                const [firstComment] = commentGroup;\n\n                if (firstComment.type !== \"Block\" || isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const commentLines = getCommentLines(commentGroup);\n                const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });\n\n                if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n                    return;\n                }\n\n                context.report({\n                    loc: {\n                        start: firstComment.loc.start,\n                        end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                    },\n                    messageId: \"expectedLines\",\n                    fix(fixer) {\n                        return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n                    }\n                });\n            },\n            \"bare-block\"(commentGroup) {\n                if (isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                // Disallows consecutive line comments in favor of using a block comment.\n                if (firstComment.type === \"Line\" && commentLines.length > 1 &&\n                    !commentLines.some(value => value.includes(\"*/\"))) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]],\n                                convertToBlock(firstComment, commentLines)\n                            );\n                        }\n                    });\n                }\n\n                // Prohibits block comments from having a * at the beginning of each line.\n                if (isStarredBlockComment(commentGroup)) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedBareBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n                        }\n                    });\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups[commentGroups.length - 1].push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-ternary\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"never\"]\n            }\n        ],\n\n        messages: {\n            expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n            expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n            unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n            unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n        },\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0];\n        const multiline = option !== \"never\";\n        const allowSingleLine = option === \"always-multiline\";\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n                const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n\n                const firstTokenOfTest = sourceCode.getFirstToken(node);\n                const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n                const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n                const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n                const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n\n                const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"unexpectedTestCons\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                                if (!areTestAndQuestionOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                                }\n                                if (!areQuestionAndConsOnSameLine) {\n                                    fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"unexpectedConsAlt\",\n                            fix: fixer => {\n                                if (hasComments) {\n                                    return null;\n                                }\n                                const fixers = [];\n                                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                                if (!areConsAndColonOnSameLine) {\n                                    fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                                }\n                                if (!areColonAndAltOnSameLine) {\n                                    fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                                }\n\n                                return fixers;\n                            }\n                        });\n                    }\n                } else {\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n                        return;\n                    }\n\n                    if (areTestAndConsequentOnSameLine) {\n                        context.report({\n                            node: node.test,\n                            loc: {\n                                start: firstTokenOfTest.loc.start,\n                                end: lastTokenOfTest.loc.end\n                            },\n                            messageId: \"expectedTestCons\",\n                            fix: fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfTest.range[1],\n                                        questionToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            ))\n                        });\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        context.report({\n                            node: node.consequent,\n                            loc: {\n                                start: firstTokenOfConsequent.loc.start,\n                                end: lastTokenOfConsequent.loc.end\n                            },\n                            messageId: \"expectedConsAlt\",\n                            fix: (fixer => (hasComments ? null : (\n                                fixer.replaceTextRange(\n                                    [\n                                        lastTokenOfConsequent.range[1],\n                                        colonToken.range[0]\n                                    ],\n                                    \"\\n\"\n                                )\n                            )))\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\",\n    \"BigInt\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(`${key}, if provided, must be an Array`);\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require constructor names to begin with a capital letter\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/new-cap\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    newIsCap: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    capIsNew: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    newIsCapExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    newIsCapExceptionPattern: {\n                        type: \"string\"\n                    },\n                    capIsNewExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    capIsNewExceptionPattern: {\n                        type: \"string\"\n                    },\n                    properties: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            upper: \"A function with a name starting with an uppercase letter should only be used as a constructor.\",\n            lower: \"A constructor name should not start with a lowercase letter.\"\n        }\n    },\n\n    create(context) {\n\n        const config = Object.assign({}, context.options[0]);\n\n        config.newIsCap = config.newIsCap !== false;\n        config.capIsNew = config.capIsNew !== false;\n        const skipProperties = config.properties === false;\n\n        const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, \"u\") : null;\n\n        const capIsNewExceptions = calculateCapIsNewExceptions(config);\n        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, \"u\") : null;\n\n        const listeners = {};\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get exact callee name from expression\n         * @param {ASTNode} node CallExpression or NewExpression node\n         * @returns {string} name\n         */\n        function extractNameFromExpression(node) {\n            return node.callee.type === \"Identifier\"\n                ? node.callee.name\n                : astUtils.getStaticPropertyName(node.callee) || \"\";\n        }\n\n        /**\n         * Returns the capitalization state of the string -\n         * Whether the first character is uppercase, lowercase, or non-alphabetic\n         * @param {string} str String\n         * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n         */\n        function getCap(str) {\n            const firstChar = str.charAt(0);\n\n            const firstCharLower = firstChar.toLowerCase();\n            const firstCharUpper = firstChar.toUpperCase();\n\n            if (firstCharLower === firstCharUpper) {\n\n                // char has no uppercase variant, so it's non-alphabetic\n                return \"non-alpha\";\n            }\n            if (firstChar === firstCharLower) {\n                return \"lower\";\n            }\n            return \"upper\";\n\n        }\n\n        /**\n         * Check if capitalization is allowed for a CallExpression\n         * @param {Object} allowedMap Object mapping calleeName to a Boolean\n         * @param {ASTNode} node CallExpression node\n         * @param {string} calleeName Capitalized callee name from a CallExpression\n         * @param {Object} pattern RegExp object from options pattern\n         * @returns {boolean} Returns true if the callee may be capitalized\n         */\n        function isCapAllowed(allowedMap, node, calleeName, pattern) {\n            const sourceText = sourceCode.getText(node.callee);\n\n            if (allowedMap[calleeName] || allowedMap[sourceText]) {\n                return true;\n            }\n\n            if (pattern && pattern.test(sourceText)) {\n                return true;\n            }\n\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (calleeName === \"UTC\" && callee.type === \"MemberExpression\") {\n\n                // allow if callee is Date.UTC\n                return callee.object.type === \"Identifier\" &&\n                    callee.object.name === \"Date\";\n            }\n\n            return skipProperties && callee.type === \"MemberExpression\";\n        }\n\n        /**\n         * Reports the given messageId for the given node. The location will be the start of the property or the callee.\n         * @param {ASTNode} node CallExpression or NewExpression node.\n         * @param {string} messageId The messageId to report.\n         * @returns {void}\n         */\n        function report(node, messageId) {\n            let callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                callee = callee.property;\n            }\n\n            context.report({ node, loc: callee.loc, messageId });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        if (config.newIsCap) {\n            listeners.NewExpression = function(node) {\n\n                const constructorName = extractNameFromExpression(node);\n\n                if (constructorName) {\n                    const capitalization = getCap(constructorName);\n                    const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"lower\");\n                    }\n                }\n            };\n        }\n\n        if (config.capIsNew) {\n            listeners.CallExpression = function(node) {\n\n                const calleeName = extractNameFromExpression(node);\n\n                if (calleeName) {\n                    const capitalization = getCap(calleeName);\n                    const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"upper\");\n                    }\n                }\n            };\n        }\n\n        return listeners;\n    }\n};\n","/**\n * @fileoverview Rule to flag when using constructor without parentheses\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce or disallow parentheses when invoking a constructor with no arguments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/new-parens\"\n        },\n\n        fixable: \"code\",\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                }\n            ]\n        },\n        messages: {\n            missing: \"Missing '()' invoking a constructor.\",\n            unnecessary: \"Unnecessary '()' invoking a constructor with no arguments.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] !== \"never\"; // Default is always\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            NewExpression(node) {\n                if (node.arguments.length !== 0) {\n                    return; // if there are arguments, there have to be parens\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n                const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);\n\n                // `hasParens` is true only if the new expression ends with its own parens, e.g., new new foo() does not end with its own parens\n                const hasParens = hasLastParen &&\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken)) &&\n                    node.callee.range[1] < node.range[1];\n\n                if (always) {\n                    if (!hasParens) {\n                        context.report({\n                            node,\n                            messageId: \"missing\",\n                            fix: fixer => fixer.insertTextAfter(node, \"()\")\n                        });\n                    }\n                } else {\n                    if (hasParens) {\n                        context.report({\n                            node,\n                            messageId: \"unnecessary\",\n                            fix: fixer => [\n                                fixer.remove(sourceCode.getTokenBefore(lastToken)),\n                                fixer.remove(lastToken),\n                                fixer.insertTextBefore(node, \"(\"),\n                                fixer.insertTextAfter(node, \")\")\n                            ]\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-after-var\"\n        },\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected blank line after variable declarations.\",\n            unexpected: \"Unexpected blank line after variable declarations.\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         * @param {ASTNode} node The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n         * Gets the last line of a group of consecutive comments\n         * @param {number} commentStartLine The starting line of the group\n         * @returns {number} The number of the last comment line of the group\n         */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            /*\n             * Some coding styles use multiple `var` statements, so do nothing if\n             * the next token is a `var` statement.\n             */\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    messageId: \"expected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n * @deprecated\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-before-return\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [],\n        messages: {\n            expected: \"Expected newline before return statement.\"\n        },\n\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node node to check\n         * @param {Array} testTokens array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(token => tokenBefore.value === token);\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            const parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                    ? node.parent.body[0] === node\n                    : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            }\n            if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            }\n            if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            }\n            return isPrecededByTokens(node, [\")\"]);\n\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node node to check for overlapping comments\n         * @param {number} lineNumTokenBefore line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            const comments = sourceCode.getCommentsBefore(node);\n            let numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(comment => {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Returns the line number of the token before the node that is passed in as an argument\n         * @param {ASTNode} node The node to use as the start of the calculation\n         * @returns {number} Line number of the token before `node`\n         * @private\n         */\n        function getLineNumberOfTokenBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            let lineNumTokenBefore;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0; // global return at beginning of script\n            }\n\n            return lineNumTokenBefore;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            const lineNumNode = node.loc.start.line;\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        /**\n         * Checks whether it is safe to apply a fix to a given return statement.\n         *\n         * The fix is not considered safe if the given return statement has leading comments,\n         * as we cannot safely determine if the newline should be added before or after the comments.\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n         * @param {ASTNode} node The return statement node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         * @private\n         */\n        function canFix(node) {\n            const leadingComments = sourceCode.getCommentsBefore(node);\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (leadingComments.length === 0) {\n                return true;\n            }\n\n            /*\n             * if the last leading comment ends in the same line as the previous token and\n             * does not share a line with the `return` node, we can consider it safe to fix.\n             * Example:\n             * function a() {\n             *     var b; //comment\n             *     return;\n             * }\n             */\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\n                return true;\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        fix(fixer) {\n                            if (canFix(node)) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n\n                                return fixer.insertTextBefore(node, newlines);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10,\n                    default: 2\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            expected: \"Expected line break before `{{callee}}`.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         * @param  {ASTNode} node A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            if (node.computed) {\n                if (node.optional) {\n                    return \"?.[\";\n                }\n                return \"[\";\n            }\n            if (node.optional) {\n                return \"?.\";\n            }\n            return \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         * @param {ASTNode} node A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = astUtils.skipChainExpression(node.callee);\n\n                if (callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                let parent = astUtils.skipChainExpression(callee.object);\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                    context.report({\n                        node: callee.property,\n                        loc: {\n                            start: firstTokenAfterObject.loc.start,\n                            end: callee.loc.end\n                        },\n                        messageId: \"expected\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of alert, confirm, prompt\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    getStaticPropertyName: getPropertyName,\n    getVariableByName,\n    skipChainExpression\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given name is a prohibited identifier.\n * @param {string} name The name to check\n * @returns {boolean} Whether or not the name is prohibited.\n */\nfunction isProhibitedIdentifier(name) {\n    return /^(alert|confirm|prompt)$/u.test(name);\n}\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\n/**\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the node is a reference to the global object.\n */\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\n    if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n        return true;\n    }\n    if (\n        node.type === \"Identifier\" &&\n        (\n            node.name === \"window\" ||\n            (node.name === \"globalThis\" && getVariableByName(scope, \"globalThis\"))\n        )\n    ) {\n        return !isShadowed(scope, node);\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-alert\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected {{name}}.\"\n        }\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const callee = skipChainExpression(node.callee),\n                    currentScope = context.getScope();\n\n                // without window.\n                if (callee.type === \"Identifier\") {\n                    const name = callee.name;\n\n                    if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { name }\n                        });\n                    }\n\n                } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\n                    const name = getPropertyName(callee);\n\n                    if (isProhibitedIdentifier(name)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { name }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow construction of dense arrays using the Array constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `Array` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-array-constructor\"\n        },\n\n        schema: [],\n\n        messages: {\n            preferLiteral: \"The array literal notation [] is preferable.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Disallow construction of dense arrays using the Array constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (\n                node.arguments.length !== 1 &&\n                node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Array\"\n            ) {\n                context.report({ node, messageId: \"preferLiteral\" });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","/**\n * @fileoverview disallow using an async function as a Promise executor\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow using an async function as a Promise executor\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-async-promise-executor\"\n        },\n\n        fixable: null,\n        schema: [],\n        messages: {\n            async: \"Promise executor functions should not be async.\"\n        }\n    },\n\n    create(context) {\n        return {\n            \"NewExpression[callee.name='Promise'][arguments.0.async=true]\"(node) {\n                context.report({\n                    node: context.getSourceCode().getFirstToken(node.arguments[0], token => token.value === \"async\"),\n                    messageId: \"async\"\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow uses of await inside of loops.\n * @author Nat Mote (nmote)\n */\n\"use strict\";\n\n/**\n * Check whether it should stop traversing ancestors at the given node.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if it should stop traversing.\n */\nfunction isBoundary(node) {\n    const t = node.type;\n\n    return (\n        t === \"FunctionDeclaration\" ||\n        t === \"FunctionExpression\" ||\n        t === \"ArrowFunctionExpression\" ||\n\n        /*\n         * Don't report the await expressions on for-await-of loop since it's\n         * asynchronous iteration intentionally.\n         */\n        (t === \"ForOfStatement\" && node.await === true)\n    );\n}\n\n/**\n * Check whether the given node is in loop.\n * @param {ASTNode} node A node to check.\n * @param {ASTNode} parent A parent node to check.\n * @returns {boolean} `true` if the node is in loop.\n */\nfunction isLooped(node, parent) {\n    switch (parent.type) {\n        case \"ForStatement\":\n            return (\n                node === parent.test ||\n                node === parent.update ||\n                node === parent.body\n            );\n\n        case \"ForOfStatement\":\n        case \"ForInStatement\":\n            return node === parent.body;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n            return node === parent.test || node === parent.body;\n\n        default:\n            return false;\n    }\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `await` inside of loops\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-await-in-loop\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedAwait: \"Unexpected `await` inside a loop.\"\n        }\n    },\n    create(context) {\n\n        /**\n         * Validate an await expression.\n         * @param {ASTNode} awaitNode An AwaitExpression or ForOfStatement node to validate.\n         * @returns {void}\n         */\n        function validate(awaitNode) {\n            if (awaitNode.type === \"ForOfStatement\" && !awaitNode.await) {\n                return;\n            }\n\n            let node = awaitNode;\n            let parent = node.parent;\n\n            while (parent && !isBoundary(parent)) {\n                if (isLooped(node, parent)) {\n                    context.report({\n                        node: awaitNode,\n                        messageId: \"unexpectedAwait\"\n                    });\n                    return;\n                }\n                node = parent;\n                parent = parent.parent;\n            }\n        }\n\n        return {\n            AwaitExpression: validate,\n            ForOfStatement: validate\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag bitwise identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n *\n * Set of bitwise operators.\n *\n */\nconst BITWISE_OPERATORS = [\n    \"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\",\n    \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\",\n    \"~\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow bitwise operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-bitwise\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            enum: BITWISE_OPERATORS\n                        },\n                        uniqueItems: true\n                    },\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected use of '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n        const int32Hint = options.int32Hint === true;\n\n        /**\n         * Reports an unexpected use of a bitwise operator.\n         * @param   {ASTNode} node Node which contains the bitwise operator.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, messageId: \"unexpected\", data: { operator: node.operator } });\n        }\n\n        /**\n         * Checks if the given node has a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function hasBitwiseOperator(node) {\n            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function allowedOperator(node) {\n            return allowed.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if the given bitwise operator is used for integer typecasting, i.e. \"|0\"\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is used in integer typecasting.\n         */\n        function isInt32Hint(node) {\n            return int32Hint && node.operator === \"|\" && node.right &&\n              node.right.type === \"Literal\" && node.right.value === 0;\n        }\n\n        /**\n         * Report if the given node contains a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNodeForBitwiseOperator(node) {\n            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            AssignmentExpression: checkNodeForBitwiseOperator,\n            BinaryExpression: checkNodeForBitwiseOperator,\n            UnaryExpression: checkNodeForBitwiseOperator\n        };\n\n    }\n};\n","/**\n * @fileoverview disallow use of the Buffer() constructor\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow use of the `Buffer()` constructor\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-buffer-constructor\"\n        },\n\n        schema: [],\n\n        messages: {\n            deprecated: \"{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.\"\n        }\n    },\n\n    create(context) {\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            \"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']\"(node) {\n                context.report({\n                    node,\n                    messageId: \"deprecated\",\n                    data: { expr: node.type === \"CallExpression\" ? \"Buffer()\" : \"new Buffer()\" }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of arguments.callee and arguments.caller.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `arguments.caller` or `arguments.callee`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-caller\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Avoid arguments.{{prop}}.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"arguments\" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {\n                    context.report({ node, messageId: \"unexpected\", data: { prop: propertyName } });\n                }\n\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of an lexical declarations inside a case clause\n * @author Erik Arvidsson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow lexical declarations in case clauses\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-case-declarations\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected lexical declaration in case block.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether or not a node is a lexical declaration.\n         * @param {ASTNode} node A direct child statement of a switch case.\n         * @returns {boolean} Whether or not the node is a lexical declaration.\n         */\n        function isLexicalDeclaration(node) {\n            switch (node.type) {\n                case \"FunctionDeclaration\":\n                case \"ClassDeclaration\":\n                    return true;\n                case \"VariableDeclaration\":\n                    return node.kind !== \"var\";\n                default:\n                    return false;\n            }\n        }\n\n        return {\n            SwitchCase(node) {\n                for (let i = 0; i < node.consequent.length; i++) {\n                    const statement = node.consequent[i];\n\n                    if (isLexicalDeclaration(statement)) {\n                        context.report({\n                            node: statement,\n                            messageId: \"unexpected\"\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier\n * @author Ian Christian Myers\n * @deprecated in ESLint v5.1.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `catch` clause parameters from shadowing variables in the outer scope\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-catch-shadow\"\n        },\n\n        replacedBy: [\"no-shadow\"],\n\n        deprecated: true,\n        schema: [],\n\n        messages: {\n            mutable: \"Value of '{{name}}' may be overwritten in IE 8 and earlier.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the parameters are been shadowed\n         * @param {Object} scope current scope\n         * @param {string} name parameter name\n         * @returns {boolean} True is its been shadowed\n         */\n        function paramIsShadowing(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"CatchClause[param!=null]\"(node) {\n                let scope = context.getScope();\n\n                /*\n                 * When ecmaVersion >= 6, CatchClause creates its own scope\n                 * so start from one upper scope to exclude the current node\n                 */\n                if (scope.block === node) {\n                    scope = scope.upper;\n                }\n\n                if (paramIsShadowing(scope, node.param.name)) {\n                    context.report({ node, messageId: \"mutable\", data: { name: node.param.name } });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow modifying variables of class declarations\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning class members\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-class-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            class: \"'{{name}}' is a class.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"class\", data: { name: reference.identifier.name } });\n\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {ASTNode} node A ClassDeclaration/ClassExpression node to check.\n         * @returns {void}\n         */\n        function checkForClass(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            ClassDeclaration: checkForClass,\n            ClassExpression: checkForClass\n        };\n\n    }\n};\n","/**\n * @fileoverview The rule should warn against code that tries to compare against -0.\n * @author Aladdin-ADD <hh_2013@foxmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow comparing against -0\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-compare-neg-zero\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            unexpected: \"Do not use the '{{operator}}' operator to compare against -0.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks a given node is -0\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is -0.\n         */\n        function isNegZero(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.argument.type === \"Literal\" && node.argument.value === 0;\n        }\n        const OPERATORS_TO_CHECK = new Set([\">\", \">=\", \"<\", \"<=\", \"==\", \"===\", \"!=\", \"!==\"]);\n\n        return {\n            BinaryExpression(node) {\n                if (OPERATORS_TO_CHECK.has(node.operator)) {\n                    if (isNegZero(node.left) || isNegZero(node.right)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { operator: node.operator }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected assignment within {{type}}.\",\n\n            // must match JSHint's error message\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\n        }\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                TEST_CONDITION_PARENT_TYPES.has(node.parent.type) &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                context.report({\n                    node: node.test,\n                    messageId: \"missing\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign,\n            ConditionalExpression: testForAssign\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to warn against using arrow functions when they could be\n * confused with comparisons\n * @author Jxck <https://github.com/Jxck>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a conditional expression.\n * @param {ASTNode} node node to test\n * @returns {boolean} `true` if the node is a conditional expression.\n */\nfunction isConditional(node) {\n    return node && node.type === \"ConditionalExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow arrow functions where they could be confused with comparisons\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-confusing-arrow\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowParens: { type: \"boolean\", default: true }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            confusing: \"Arrow function used ambiguously with a conditional expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {};\n        const allowParens = config.allowParens || (config.allowParens === void 0);\n        const sourceCode = context.getSourceCode();\n\n\n        /**\n         * Reports if an arrow function contains an ambiguous conditional.\n         * @param {ASTNode} node A node to check and report.\n         * @returns {void}\n         */\n        function checkArrowFunc(node) {\n            const body = node.body;\n\n            if (isConditional(body) && !(allowParens && astUtils.isParenthesised(sourceCode, body))) {\n                context.report({\n                    node,\n                    messageId: \"confusing\",\n                    fix(fixer) {\n\n                        // if `allowParens` is not set to true don't bother wrapping in parens\n                        return allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);\n                    }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkArrowFunc\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `console`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-console\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected console statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is 'console' or not.\n         * @param {eslint-scope.Reference} reference The reference to check.\n         * @returns {boolean} `true` if the reference is 'console'.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         * @param {eslint-scope.Reference} reference The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         * @param {eslint-scope.Reference} reference The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /*\n                 * 'scope.through' includes all references to undefined\n                 * variables. If the variable 'console' is not defined, it uses\n                 * 'scope.through'.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow modifying variables that are declared using `const`\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning `const` variables\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-const-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            const: \"'{{name}}' is constant.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"const\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        return {\n            VariableDeclaration(node) {\n                if (node.kind === \"const\") {\n                    context.getDeclaredVariables(node).forEach(checkVariable);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-constant-condition\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected constant condition.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Returns literal's value converted to the Boolean type\n         * @param {ASTNode} node any `Literal` node\n         * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\n         *  `null` when it cannot be determined.\n         */\n        function getBooleanValue(node) {\n            if (node.value === null) {\n\n                /*\n                 * it might be a null literal or bigint/regex literal in unsupported environments .\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\n                 */\n\n                if (node.raw === \"null\") {\n                    return false;\n                }\n\n                // regex is always truthy\n                if (typeof node.regex === \"object\") {\n                    return true;\n                }\n\n                return null;\n            }\n\n            return !!node.value;\n        }\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && getBooleanValue(node) === true) ||\n                           (operator === \"&&\" && getBooleanValue(node) === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n\n                    /*\n                     * handles `a && false || b`\n                     * `false` is an identity element of `&&` but not `||`\n                     */\n                    return operator === node.operator &&\n                             (\n                                 isLogicalIdentity(node.left, operator) ||\n                                 isLogicalIdentity(node.right, operator)\n                             );\n\n                case \"AssignmentExpression\":\n                    return [\"||=\", \"&&=\"].includes(node.operator) &&\n                        operator === node.operator.slice(0, -1) &&\n                        isLogicalIdentity(node.right, operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n\n            // node.elements can return null values in the case of sparse arrays ex. [,]\n            if (!node) {\n                return true;\n            }\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                    return true;\n                case \"TemplateLiteral\":\n                    return (inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length)) ||\n                        node.expressions.every(exp => isConstant(exp, inBooleanPosition));\n\n                case \"ArrayExpression\": {\n                    if (node.parent.type === \"BinaryExpression\" && node.parent.operator === \"+\") {\n                        return node.elements.every(element => isConstant(element, false));\n                    }\n                    return true;\n                }\n\n                case \"UnaryExpression\":\n                    if (\n                        node.operator === \"void\" ||\n                        node.operator === \"typeof\" && inBooleanPosition\n                    ) {\n                        return true;\n                    }\n\n                    if (node.operator === \"!\") {\n                        return isConstant(node.argument, true);\n                    }\n\n                    return isConstant(node.argument, false);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) ||\n                        isLeftShortCircuit ||\n                        isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    if (node.operator === \"=\") {\n                        return isConstant(node.right, inBooleanPosition);\n                    }\n\n                    if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n                        return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n                    }\n\n                    return false;\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow returning value from constructor.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow returning value from constructor\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-constructor-return\"\n        },\n\n        schema: {},\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected return statement in constructor.\"\n        }\n    },\n\n    create(context) {\n        const stack = [];\n\n        return {\n            onCodePathStart(_, node) {\n                stack.push(node);\n            },\n            onCodePathEnd() {\n                stack.pop();\n            },\n            ReturnStatement(node) {\n                const last = stack[stack.length - 1];\n\n                if (!last.parent) {\n                    return;\n                }\n\n                if (\n                    last.parent.type === \"MethodDefinition\" &&\n                    last.parent.kind === \"constructor\" &&\n                    (node.parent.parent === last || node.argument)\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"unexpected\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of continue statement\n * @author Borislav Zhivkov\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `continue` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-continue\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected use of continue statement.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            ContinueStatement(node) {\n                context.report({ node, messageId: \"unexpected\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to forbid control characters from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst collector = new (class {\n    constructor() {\n        this._source = \"\";\n        this._controlChars = [];\n        this._validator = new RegExpValidator(this);\n    }\n\n    onPatternEnter() {\n        this._controlChars = [];\n    }\n\n    onCharacter(start, end, cp) {\n        if (cp >= 0x00 &&\n            cp <= 0x1F &&\n            (\n                this._source.codePointAt(start) === cp ||\n                this._source.slice(start, end).startsWith(\"\\\\x\") ||\n                this._source.slice(start, end).startsWith(\"\\\\u\")\n            )\n        ) {\n            this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n        }\n    }\n\n    collectControlChars(regexpStr) {\n        try {\n            this._source = regexpStr;\n            this._validator.validatePattern(regexpStr); // Call onCharacter hook\n        } catch {\n\n            // Ignore syntax errors in RegExp.\n        }\n        return this._controlChars;\n    }\n})();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow control characters in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-control-regex\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node node to evaluate\n         * @returns {RegExp|null} Regex if found else null\n         * @private\n         */\n        function getRegExpPattern(node) {\n            if (node.regex) {\n                return node.regex.pattern;\n            }\n            if (typeof node.value === \"string\" &&\n                (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") &&\n                node.parent.callee.type === \"Identifier\" &&\n                node.parent.callee.name === \"RegExp\" &&\n                node.parent.arguments[0] === node\n            ) {\n                return node.value;\n            }\n\n            return null;\n        }\n\n        return {\n            Literal(node) {\n                const pattern = getRegExpPattern(node);\n\n                if (pattern) {\n                    const controlCharacters = collector.collectControlChars(pattern);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of a debugger statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of `debugger`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-debugger\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected 'debugger' statement.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            DebuggerStatement(node) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\"\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when deleting variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow deleting variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-delete-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Variables should not be deleted.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            UnaryExpression(node) {\n                if (node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for ambiguous div operator in regexes\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow division operators explicitly at the beginning of regular expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-div-regex\"\n        },\n\n        fixable: \"code\",\n\n        schema: [],\n\n        messages: {\n            unexpected: \"A regular expression literal can be confused with '/='.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && token.value[1] === \"=\") {\n                    context.report({\n                        node,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange([token.range[0] + 1, token.range[0] + 2], \"[=]\");\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag duplicate arguments\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate arguments in `function` definitions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-args\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate param '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether or not a given definition is a parameter's.\n         * @param {eslint-scope.DefEntry} def A definition to check.\n         * @returns {boolean} `true` if the definition is a parameter's.\n         */\n        function isParameter(def) {\n            return def.type === \"Parameter\";\n        }\n\n        /**\n         * Determines if a given node has duplicate parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkParams(node) {\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Checks and reports duplications.\n                const defs = variable.defs.filter(isParameter);\n\n                if (defs.length >= 2) {\n                    context.report({\n                        node,\n                        messageId: \"unexpected\",\n                        data: { name: variable.name }\n                    });\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkParams,\n            FunctionExpression: checkParams\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow duplicate name in class members.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate class members\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-class-members\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate name '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Gets state of a given member name.\n         * @param {string} name A name of a member.\n         * @param {boolean} isStatic A flag which specifies that is a static member.\n         * @returns {Object} A state of a given member name.\n         *   - retv.init {boolean} A flag which shows the name is declared as normal member.\n         *   - retv.get {boolean} A flag which shows the name is declared as getter.\n         *   - retv.set {boolean} A flag which shows the name is declared as setter.\n         */\n        function getState(name, isStatic) {\n            const stateMap = stack[stack.length - 1];\n            const key = `$${name}`; // to avoid \"__proto__\".\n\n            if (!stateMap[key]) {\n                stateMap[key] = {\n                    nonStatic: { init: false, get: false, set: false },\n                    static: { init: false, get: false, set: false }\n                };\n            }\n\n            return stateMap[key][isStatic ? \"static\" : \"nonStatic\"];\n        }\n\n        return {\n\n            // Initializes the stack of state of member declarations.\n            Program() {\n                stack = [];\n            },\n\n            // Initializes state of member declarations for the class.\n            ClassBody() {\n                stack.push(Object.create(null));\n            },\n\n            // Disposes the state for the class.\n            \"ClassBody:exit\"() {\n                stack.pop();\n            },\n\n            // Reports the node if its name has been declared already.\n            MethodDefinition(node) {\n                const name = astUtils.getStaticPropertyName(node);\n\n                if (name === null || node.kind === \"constructor\") {\n                    return;\n                }\n\n                const state = getState(name, node.static);\n                let isDuplicate = false;\n\n                if (node.kind === \"get\") {\n                    isDuplicate = (state.init || state.get);\n                    state.get = true;\n                } else if (node.kind === \"set\") {\n                    isDuplicate = (state.init || state.set);\n                    state.set = true;\n                } else {\n                    isDuplicate = (state.init || state.get || state.set);\n                    state.init = true;\n                }\n\n                if (isDuplicate) {\n                    context.report({ node, messageId: \"unexpected\", data: { name } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n    }\n    return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate conditions in if-else-if chains\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            if (\n                a.type === \"LogicalExpression\" &&\n                (a.operator === \"||\" || a.operator === \"&&\") &&\n                a.operator === b.operator\n            ) {\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\n                    equal(a.left, b.right) && equal(a.right, b.left);\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n\n        const isSubset = isSubsetByComparator.bind(null, equal);\n\n        return {\n            IfStatement(node) {\n                const test = node.test,\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\n                        ? [test, ...splitByAnd(test)]\n                        : [test];\n                let current = node,\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n                    current = current.parent;\n\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\n                    ));\n\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\n                        context.report({ node: test, messageId: \"unexpected\" });\n                        break;\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of duplicate keys in an object.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst GET_KIND = /^(?:init|get)$/u;\nconst SET_KIND = /^(?:init|set)$/u;\n\n/**\n * The class which stores properties' information of an object.\n */\nclass ObjectInfo {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {ObjectInfo|null} upper The information of the outer object.\n     * @param {ASTNode} node The ObjectExpression node of this information.\n     */\n    constructor(upper, node) {\n        this.upper = upper;\n        this.node = node;\n        this.properties = new Map();\n    }\n\n    /**\n     * Gets the information of the given Property node.\n     * @param {ASTNode} node The Property node to get.\n     * @returns {{get: boolean, set: boolean}} The information of the property.\n     */\n    getPropertyInfo(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (!this.properties.has(name)) {\n            this.properties.set(name, { get: false, set: false });\n        }\n        return this.properties.get(name);\n    }\n\n    /**\n     * Checks whether the given property has been defined already or not.\n     * @param {ASTNode} node The Property node to check.\n     * @returns {boolean} `true` if the property has been defined.\n     */\n    isPropertyDefined(node) {\n        const entry = this.getPropertyInfo(node);\n\n        return (\n            (GET_KIND.test(node.kind) && entry.get) ||\n            (SET_KIND.test(node.kind) && entry.set)\n        );\n    }\n\n    /**\n     * Defines the given property.\n     * @param {ASTNode} node The Property node to define.\n     * @returns {void}\n     */\n    defineProperty(node) {\n        const entry = this.getPropertyInfo(node);\n\n        if (GET_KIND.test(node.kind)) {\n            entry.get = true;\n        }\n        if (SET_KIND.test(node.kind)) {\n            entry.set = true;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate keys in object literals\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-keys\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate key '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        let info = null;\n\n        return {\n            ObjectExpression(node) {\n                info = new ObjectInfo(info, node);\n            },\n            \"ObjectExpression:exit\"() {\n                info = info.upper;\n            },\n\n            Property(node) {\n                const name = astUtils.getStaticPropertyName(node);\n\n                // Skip destructuring.\n                if (node.parent.type !== \"ObjectExpression\") {\n                    return;\n                }\n\n                // Skip if the name is not static.\n                if (name === null) {\n                    return;\n                }\n\n                // Reports if the name is defined already.\n                if (info.isPropertyDefined(node)) {\n                    context.report({\n                        node: info.node,\n                        loc: node.key.loc,\n                        messageId: \"unexpected\",\n                        data: { name }\n                    });\n                }\n\n                // Update info.\n                info.defineProperty(node);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow a duplicate case label.\n * @author Dieter Oberkofler\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate case labels\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-duplicate-case\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate case label.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the two given nodes are considered to be equal.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n        return {\n            SwitchStatement(node) {\n                const previousTests = [];\n\n                for (const switchCase of node.cases) {\n                    if (switchCase.test) {\n                        const test = switchCase.test;\n\n                        if (previousTests.some(previousTest => equal(previousTest, test))) {\n                            context.report({ node: switchCase, messageId: \"unexpected\" });\n                        } else {\n                            previousTests.push(test);\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} the name of the module, or empty string if no name.\n */\nfunction getValue(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n\n    return \"\";\n}\n\n/**\n * Checks if the name of the import or export exists in the given array, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {string} value The name of the imported or exported module.\n * @param {string[]} array The array containing other imports or exports in the file.\n * @param {string} messageId A messageId to be reported after the name of the module\n *\n * @returns {void} No return value\n */\nfunction checkAndReport(context, node, value, array, messageId) {\n    if (array.indexOf(value) !== -1) {\n        context.report({\n            node,\n            messageId,\n            data: {\n                module: value\n            }\n        });\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the imports of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @param {string[]} importsInFile The array containing other imports in the file.\n * @param {string[]} exportsInFile The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImports(context, includeExports, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, importsInFile, \"import\");\n\n            if (includeExports) {\n                checkAndReport(context, node, value, exportsInFile, \"importAs\");\n            }\n\n            importsInFile.push(value);\n        }\n    };\n}\n\n/**\n * Returns a function handling the exports of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {string[]} importsInFile The array containing other imports in the file.\n * @param {string[]} exportsInFile The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleExports(context, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, exportsInFile, \"export\");\n            checkAndReport(context, node, value, importsInFile, \"exportAs\");\n\n            exportsInFile.push(value);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                includeExports: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            import: \"'{{module}}' import is duplicated.\",\n            importAs: \"'{{module}}' import is duplicated as export.\",\n            export: \"'{{module}}' export is duplicated.\",\n            exportAs: \"'{{module}}' export is duplicated as import.\"\n        }\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            importsInFile = [],\n            exportsInFile = [];\n\n        const handlers = {\n            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);\n            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);\n        }\n\n        return handlers;\n    }\n};\n","/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n","/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether the given names can be safely used to declare block-scoped variables\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\n         * or silently change references and modify behavior of the original code.\n         *\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\n         * @param {string[]} names Array of variable names.\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\n         */\n        function isSafeToDeclare(names, scope) {\n\n            if (names.length === 0) {\n                return true;\n            }\n\n            const functionScope = scope.variableScope;\n\n            /*\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n             *\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n             */\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\n\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            // Redeclaring a catch variable would also cause a syntax error.\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\n                    return false;\n                }\n            }\n\n            /*\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n             * However, if the variable was used, declaring a new one with the same name would change references\n             * and modify behavior.\n             */\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\n                defs.length === 0 && references.length > 0);\n\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            /*\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\n             * would change references and modify behavior.\n             */\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\n                return false;\n            }\n\n            /*\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n             *\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\n             */\n            if (scope !== functionScope) {\n                const scopeNodeRange = scope.block.range;\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\n\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n\n        /**\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n         * @param {Node} node The 'else' node.\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n         * @returns {boolean} True if it is safe, false otherwise.\n         */\n        function isSafeFromNameCollisions(node, scope) {\n\n            if (node.type === \"FunctionDeclaration\") {\n\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n                return false;\n            }\n\n            if (node.type !== \"BlockStatement\") {\n                return true;\n            }\n\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\n\n            if (!elseBlockScope) {\n\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n                return true;\n            }\n\n            /*\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n             * only block-scoped variables (such as let and const variables or class and function declarations)\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n             */\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\n\n            return isSafeToDeclare(namesToCheck, scope);\n        }\n\n        /**\n         * Display the context report if rule is violated\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            const currentScope = context.getScope();\n\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                fix: fixer => {\n\n                    if (!isSafeFromNameCollisions(node, currentScope)) {\n                        return null;\n                    }\n\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     *\n                     * Also, to avoid name collisions between two else blocks.\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag the use of empty character classes in regular expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/*\n * plain-English description of the following regexp:\n * 0. `^` fix the match at the beginning of the string\n * 1. `\\/`: the `/` that begins the regexp\n * 2. `([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*`: regexp contents; 0 or more of the following\n * 2.0. `[^\\\\[]`: any character that's not a `\\` or a `[` (anything but escape sequences and character classes)\n * 2.1. `\\\\.`: an escape sequence\n * 2.2. `\\[([^\\\\\\]]|\\\\.)+\\]`: a character class that isn't empty\n * 3. `\\/` the `/` that ends the regexp\n * 4. `[gimuy]*`: optional regexp flags\n * 5. `$`: fix the match at the end of the string\n */\nconst regex = /^\\/([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*\\/[gimuys]*$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow empty character classes in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Empty class.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && !regex.test(token.value)) {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\",\n    \"asyncFunctions\",\n    \"asyncMethods\"\n]);\n\n/**\n * Gets the kind of a given function node.\n * @param {ASTNode} node A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-empty-function\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected empty {{name}}.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         * @param {ASTNode} node A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc,\n                    messageId: \"unexpected\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow an empty pattern\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow empty destructuring patterns\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty-pattern\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected empty {{type}} pattern.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ObjectPattern(node) {\n                if (node.properties.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"object\" } });\n                }\n            },\n            ArrayPattern(node) {\n                if (node.elements.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"array\" } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of an empty block statement\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty block statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyCatch: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Empty {{type}} statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            allowEmptyCatch = options.allowEmptyCatch || false;\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BlockStatement(node) {\n\n                // if the body is not empty, we can just return immediately\n                if (node.body.length !== 0) {\n                    return;\n                }\n\n                // a function is generally allowed to be empty\n                if (astUtils.isFunction(node.parent)) {\n                    return;\n                }\n\n                if (allowEmptyCatch && node.parent.type === \"CatchClause\") {\n                    return;\n                }\n\n                // any other block is only allowed to be empty, if it contains a comment\n                if (sourceCode.getCommentsInside(node).length > 0) {\n                    return;\n                }\n\n                context.report({ node, messageId: \"unexpected\", data: { type: \"block\" } });\n            },\n\n            SwitchStatement(node) {\n\n                if (typeof node.cases === \"undefined\" || node.cases.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"switch\" } });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag comparisons to null without a type-checking\n * operator.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `null` comparisons without type-checking operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eq-null\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Use '===' to compare with null.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                const badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n                if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator ||\n                        node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\",\n    \"globalThis\"\n]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    /*\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n                     */\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (astUtils.isSpecificId(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag assignment of the exception parameter\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning exceptions in `catch` clauses\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-ex-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Do not assign to the exception parameter.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"unexpected\" });\n            });\n        }\n\n        return {\n            CatchClause(node) {\n                context.getDeclaredVariables(node).forEach(checkVariable);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Check if it's an assignment to the property of the given node.\n         * Example: `*.prop = 0` // the `*` is the given node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if an assignment to the property of the node.\n         */\n        function isAssigningToPropertyOf(node) {\n            return (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.object === node &&\n                node.parent.parent.type === \"AssignmentExpression\" &&\n                node.parent.parent.left === node.parent\n            );\n        }\n\n        /**\n         * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         */\n        function isInDefinePropertyCall(node) {\n            return (\n                node.parent.type === \"CallExpression\" &&\n                node.parent.arguments[0] === node &&\n                astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (!isPrototypePropertyAccessed(identifierNode)) {\n                return; // This is not `*.prototype` access.\n            }\n\n            /*\n             * `identifierNode.parent` is a MemberExpression `*.prototype`.\n             * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n             */\n            const prototypeNode =\n                identifierNode.parent.parent.type === \"ChainExpression\"\n                    ? identifierNode.parent.parent\n                    : identifierNode.parent;\n\n            if (isAssigningToPropertyOf(prototypeNode)) {\n\n                // `*.prototype` -> MemberExpression -> AssignmentExpression\n                reportNode(prototypeNode.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(prototypeNode)) {\n\n                // `*.prototype` -> CallExpression\n                reportNode(prototypeNode.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence Dányi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary calls to `.bind()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-bind\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"The function binding is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks if a node is free of side effects.\n         *\n         * This check is stricter than it needs to be, in order to keep the implementation simple.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\n         */\n        function isSideEffectFree(node) {\n            return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n        }\n\n        /**\n         * Reports a given function node.\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            const memberNode = node.parent;\n            const callNode = memberNode.parent.type === \"ChainExpression\"\n                ? memberNode.parent.parent\n                : memberNode.parent;\n\n            context.report({\n                node: callNode,\n                messageId: \"unexpected\",\n                loc: memberNode.property.loc,\n\n                fix(fixer) {\n                    if (!isSideEffectFree(callNode.arguments[0])) {\n                        return null;\n                    }\n\n                    /*\n                     * The list of the first/last token pair of a removal range.\n                     * This is two parts because closing parentheses may exist between the method name and arguments.\n                     * E.g. `(function(){}.bind ) (obj)`\n                     *                    ^^^^^   ^^^^^ < removal ranges\n                     * E.g. `(function(){}?.['bind'] ) ?.(obj)`\n                     *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\n                     */\n                    const tokenPairs = [\n                        [\n\n                            // `.`, `?.`, or `[` token.\n                            sourceCode.getTokenAfter(\n                                memberNode.object,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // property name or `]` token.\n                            sourceCode.getLastToken(memberNode)\n                        ],\n                        [\n\n                            // `?.` or `(` token of arguments.\n                            sourceCode.getTokenAfter(\n                                memberNode,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // `)` token of arguments.\n                            sourceCode.getLastToken(callNode)\n                        ]\n                    ];\n                    const firstTokenToRemove = tokenPairs[0][0];\n                    const lastTokenToRemove = tokenPairs[1][1];\n\n                    if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                        return null;\n                    }\n\n                    return tokenPairs.map(([start, end]) =>\n                        fixer.removeRange([start.range[0], end.range[1]]));\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n                return false;\n            }\n\n            // The node of `*.bind` member access.\n            const bindNode = node.parent.parent.type === \"ChainExpression\"\n                ? node.parent.parent\n                : node.parent;\n\n            return (\n                bindNode.parent.type === \"CallExpression\" &&\n                bindNode.parent.callee === bindNode &&\n                bindNode.parent.arguments.length === 1 &&\n                bindNode.parent.arguments[0].type !== \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         * @param {ASTNode} node A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         * @param {ASTNode} node A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         * @param {ASTNode} node A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\nconst precedence = astUtils.getPrecedence;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForLogicalOperands: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is a Boolean function or constructor.\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is Boolean function or constructor\n         */\n        function isBooleanFunctionOrConstructorCall(node) {\n\n            // Boolean(<bool>) and new Boolean(<bool>)\n            return (node.type === \"CallExpression\" || node.type === \"NewExpression\") &&\n                    node.callee.type === \"Identifier\" &&\n                        node.callee.name === \"Boolean\";\n        }\n\n        /**\n         * Checks whether the node is a logical expression and that the option is enabled\n         * @param {ASTNode} node the node\n         * @returns {boolean} if the node is a logical expression and option is enabled\n         */\n        function isLogicalContext(node) {\n            return node.type === \"LogicalExpression\" &&\n            (node.operator === \"||\" || node.operator === \"&&\") &&\n            (context.options.length && context.options[0].enforceForLogicalOperands === true);\n\n        }\n\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         * @param {ASTNode} node The node\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node) {\n            return (\n                (isBooleanFunctionOrConstructorCall(node.parent) &&\n                node === node.parent.arguments[0]) ||\n\n                (BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 &&\n                    node === node.parent.test) ||\n\n                // !<bool>\n                (node.parent.type === \"UnaryExpression\" &&\n                    node.parent.operator === \"!\")\n            );\n        }\n\n        /**\n         * Checks whether the node is a context that should report an error\n         * Acts recursively if it is in a logical context\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is in one of the flagged contexts\n         */\n        function isInFlaggedContext(node) {\n            if (node.parent.type === \"ChainExpression\") {\n                return isInFlaggedContext(node.parent);\n            }\n\n            return isInBooleanContext(node) ||\n            (isLogicalContext(node.parent) &&\n\n            // For nested logical statements\n            isInFlaggedContext(node.parent)\n            );\n        }\n\n\n        /**\n         * Check if a node has comments inside.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if it has comments inside.\n         */\n        function hasCommentsInside(node) {\n            return Boolean(sourceCode.getCommentsInside(node).length);\n        }\n\n        /**\n         * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is parenthesized.\n         * @private\n         */\n        function isParenthesized(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Determines whether the given node needs to be parenthesized when replacing the previous node.\n         * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n         * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n         * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\n         * @param {ASTNode} previousNode Previous node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node needs to be parenthesized.\n         */\n        function needsParens(previousNode, node) {\n            if (previousNode.parent.type === \"ChainExpression\") {\n                return needsParens(previousNode.parent, node);\n            }\n            if (isParenthesized(previousNode)) {\n\n                // parentheses around the previous node will stay, so there is no need for an additional pair\n                return false;\n            }\n\n            // parent of the previous node will become parent of the replacement node\n            const parent = previousNode.parent;\n\n            switch (parent.type) {\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.type === \"SequenceExpression\";\n                case \"IfStatement\":\n                case \"DoWhileStatement\":\n                case \"WhileStatement\":\n                case \"ForStatement\":\n                    return false;\n                case \"ConditionalExpression\":\n                    return precedence(node) <= precedence(parent);\n                case \"UnaryExpression\":\n                    return precedence(node) < precedence(parent);\n                case \"LogicalExpression\":\n                    if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n                        return true;\n                    }\n                    if (previousNode === parent.left) {\n                        return precedence(node) < precedence(parent);\n                    }\n                    return precedence(node) <= precedence(parent);\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(`Unexpected parent type: ${parent.type}`);\n            }\n        }\n\n        return {\n            UnaryExpression(node) {\n                const parent = node.parent;\n\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                          parent.type !== \"UnaryExpression\" ||\n                          parent.operator !== \"!\") {\n                    return;\n                }\n\n\n                if (isInFlaggedContext(parent)) {\n                    context.report({\n                        node: parent,\n                        messageId: \"unexpectedNegation\",\n                        fix(fixer) {\n                            if (hasCommentsInside(parent)) {\n                                return null;\n                            }\n\n                            if (needsParens(parent, node.argument)) {\n                                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n                            }\n\n                            let prefix = \"\";\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === parent.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n                        }\n                    });\n                }\n            },\n\n            CallExpression(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInFlaggedContext(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix(fixer) {\n                            const parent = node.parent;\n\n                            if (node.arguments.length === 0) {\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n\n                                    /*\n                                     * !Boolean() -> true\n                                     */\n\n                                    if (hasCommentsInside(parent)) {\n                                        return null;\n                                    }\n\n                                    const replacement = \"true\";\n                                    let prefix = \"\";\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                                    if (\n                                        tokenBefore &&\n                                        tokenBefore.range[1] === parent.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                                    ) {\n                                        prefix = \" \";\n                                    }\n\n                                    return fixer.replaceText(parent, prefix + replacement);\n                                }\n\n                                /*\n                                 * Boolean() -> false\n                                 */\n\n                                if (hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, \"false\");\n                            }\n\n                            if (node.arguments.length === 1) {\n                                const argument = node.arguments[0];\n\n                                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                /*\n                                 * Boolean(expression) -> expression\n                                 */\n\n                                if (needsParens(node, argument)) {\n                                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                                }\n\n                                return fixer.replaceText(node, sourceCode.getText(argument));\n                            }\n\n                            // two or more arguments\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary labels\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-label\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"This label '{{name}}' is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         * @param {ASTNode} node A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         * @param {ASTNode} node A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         * @param {ASTNode} node A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         * @param {ASTNode} node A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            messageId: \"unexpected\",\n                            data: labelNode,\n                            fix(fixer) {\n                                const breakOrContinueToken = sourceCode.getFirstToken(node);\n\n                                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {\n                                    return null;\n                                }\n\n                                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);\n                            }\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n","/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst { isParenthesized: isParenthesizedRaw } = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" },\n                                enforceForSequenceExpressions: { type: \"boolean\" },\n                                enforceForNewInMemberExpressions: { type: \"boolean\" },\n                                enforceForFunctionPrototypeMethods: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unnecessary parentheses around expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const tokensToIgnore = new WeakSet();\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForSequenceExpressions === false;\n        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForNewInMemberExpressions === false;\n        const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForFunctionPrototypeMethods === false;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        let reportsBuffer;\n\n        /**\n         * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\n         * Example: function(){}.call()\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\n         * @private\n         */\n        function isImmediateFunctionPrototypeMethodCall(node) {\n            const callNode = astUtils.skipChainExpression(node);\n\n            if (callNode.type !== \"CallExpression\") {\n                return false;\n            }\n            const callee = astUtils.skipChainExpression(callNode.callee);\n\n            return (\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee))\n            );\n        }\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n                return false;\n            }\n\n            if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n                return false;\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is parenthesised.\n         * @private\n         */\n        function isParenthesised(node) {\n            return isParenthesizedRaw(1, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            return isParenthesizedRaw(2, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses with considering precedence level of the node.\n         * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\n         * whether the node is surrounded by parentheses twice or not.\n         * @param {ASTNode} node The node to be checked.\n         * @param {number} precedenceLowerLimit The lower limit of precedence.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n            if (ruleApplies(node) && isParenthesised(node)) {\n                if (\n                    precedence(node) >= precedenceLowerLimit ||\n                    isParenthesisedTwice(node)\n                ) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n                if (\n                    currentNode.type === \"ReturnStatement\" ||\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 ||\n                (\n\n                    // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n                    astUtils.isOpeningParenToken(penultimateToken) &&\n                    astUtils.isClosingParenToken(lastToken) &&\n                    newExpression.callee.range[1] < newExpression.range[1]\n                );\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            }\n            if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            }\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            }\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === tokenAfterLeftParen.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            const maybeCallNode = astUtils.skipChainExpression(node);\n\n            return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\n         * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\n         * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\n         * @param {ASTNode} [node] The node to check\n         * @returns {boolean} `true` if the given node can be a valid assignment target\n         */\n        function canBeAssignmentTarget(node) {\n            return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n            }\n\n            /**\n             * Finishes reporting\n             * @returns {void}\n             * @private\n             */\n            function finishReport() {\n                context.report({\n                    node,\n                    loc: leftParenToken.loc,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                        return fixer.replaceTextRange([\n                            leftParenToken.range[0],\n                            rightParenToken.range[1]\n                        ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                    }\n                });\n            }\n\n            if (reportsBuffer) {\n                reportsBuffer.reports.push({ node, finishReport });\n                return;\n            }\n\n            finishReport();\n        }\n\n        /**\n         * Evaluate a argument of the node.\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkArgumentWithPrecedence(node) {\n            if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !(\n                        isIIFE(node) ||\n\n                        // (new A)(); new (new A)();\n                        (\n                            callee.type === \"NewExpression\" &&\n                            !isNewExpressionWithParens(callee) &&\n                            !(\n                                node.type === \"NewExpression\" &&\n                                !isNewExpressionWithParens(node)\n                            )\n                        ) ||\n\n                        // new (a().b)(); new (a.b().c);\n                        (\n                            node.type === \"NewExpression\" &&\n                            callee.type === \"MemberExpression\" &&\n                            doesMemberExpressionContainCallExpression(callee)\n                        ) ||\n\n                        // (a?.b)(); (a?.())();\n                        (\n                            !node.optional &&\n                            callee.type === \"ChainExpression\"\n                        )\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            node.arguments\n                .filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                .forEach(report);\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left)) {\n                if (\n                    !([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) &&\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) &&\n                    (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation)) ||\n                    isParenthesisedTwice(node.left)\n                ) {\n                    report(node.left);\n                }\n            }\n\n            if (!shouldSkipRight && hasExcessParens(node.right)) {\n                if (\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) &&\n                    (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation)) ||\n                    isParenthesisedTwice(node.right)\n                ) {\n                    report(node.right);\n                }\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            /*\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n             * Otherwise, parentheses are needed.\n             */\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" &&\n                            tokenAfterClosingParens &&\n                            (\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\n                                tokenAfterClosingParens.type === \"Identifier\"\n                            )\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\"\n                ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                : hasExcessParens(node);\n\n            if (hasExtraParens) {\n                report(node);\n            }\n        }\n\n        /**\n         * Finds the path from the given node to the specified ancestor.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} ancestor Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified ancestor.\n         */\n        function pathToAncestor(node, ancestor) {\n            const path = [node];\n            let currentNode = node;\n\n            while (currentNode !== ancestor) {\n\n                currentNode = currentNode.parent;\n\n                /* istanbul ignore if */\n                if (currentNode === null) {\n                    throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n                }\n\n                path.push(currentNode);\n            }\n\n            return path;\n        }\n\n        /**\n         * Finds the path from the given node to the specified descendant.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} descendant Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified descendant.\n         */\n        function pathToDescendant(node, descendant) {\n            return pathToAncestor(descendant, node).reverse();\n        }\n\n        /**\n         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n         * @param {ASTNode} node Ancestor of an 'in' expression.\n         * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n         * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n         */\n        function isSafelyEnclosingInExpression(node, child) {\n            switch (node.type) {\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                case \"BlockStatement\":\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                case \"TemplateLiteral\":\n                    return true;\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                    return node.params.includes(child);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.arguments.includes(child);\n                case \"MemberExpression\":\n                    return node.computed && node.property === child;\n                case \"ConditionalExpression\":\n                    return node.consequent === child;\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n         * @returns {void}\n         */\n        function startNewReportsBuffering() {\n            reportsBuffer = {\n                upper: reportsBuffer,\n                inExpressionNodes: [],\n                reports: []\n            };\n        }\n\n        /**\n         * Ends the current reports buffering.\n         * @returns {void}\n         */\n        function endCurrentReportsBuffering() {\n            const { upper, inExpressionNodes, reports } = reportsBuffer;\n\n            if (upper) {\n                upper.inExpressionNodes.push(...inExpressionNodes);\n                upper.reports.push(...reports);\n            } else {\n\n                // flush remaining reports\n                reports.forEach(({ finishReport }) => finishReport());\n            }\n\n            reportsBuffer = upper;\n        }\n\n        /**\n         * Checks whether the given node is in the current reports buffer.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is in the current buffer, false otherwise.\n         */\n        function isInCurrentReportsBuffer(node) {\n            return reportsBuffer.reports.some(r => r.node === node);\n        }\n\n        /**\n         * Removes the given node from the current reports buffer.\n         * @param {ASTNode} node Node to remove.\n         * @returns {void}\n         */\n        function removeFromCurrentReportsBuffer(node) {\n            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n        }\n\n        /**\n         * Checks whether a node is a MemberExpression at NewExpression's callee.\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\n         */\n        function isMemberExpInNewCallee(node) {\n            if (node.type === \"MemberExpression\") {\n                return node.parent.type === \"NewExpression\" && node.parent.callee === node\n                    ? true\n                    : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(report);\n            },\n\n            ArrayPattern(node) {\n                node.elements\n                    .filter(e => canBeAssignmentTarget(e) && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression(node) {\n                if (reportsBuffer && node.operator === \"in\") {\n                    reportsBuffer.inExpressionNodes.push(node);\n                }\n\n                checkBinaryLogical(node);\n            },\n\n            CallExpression: checkCallNew,\n\n            ClassBody(node) {\n                node.body\n                    .filter(member => member.type === \"MethodDefinition\" && member.computed && member.key)\n                    .filter(member => hasExcessParensWithPrecedence(member.key, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(member => report(member.key));\n            },\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n                if (\n                    !isCondAssignException(node) &&\n                    hasExcessParensWithPrecedence(node.test, precedence({ type: \"LogicalExpression\", operator: \"||\" }))\n                ) {\n                    report(node.test);\n                }\n\n                if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            ForInStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" &&\n                        astUtils.isOpeningBracketToken(\n                            sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                        )\n                    ) {\n\n                        // ForInStatement#left expression cannot start with `let[`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForOfStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (firstLeftToken.value === \"let\") {\n\n                        // ForOfStatement#left expression cannot start with `let`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.right);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n\n                if (node.init) {\n\n                    if (node.init.type !== \"VariableDeclaration\") {\n                        const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n\n                        if (\n                            firstToken.value === \"let\" &&\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken)\n                            )\n                        ) {\n\n                            // ForStatement#init expression cannot start with `let[`.\n                            tokensToIgnore.add(firstToken);\n                        }\n                    }\n\n                    startNewReportsBuffering();\n\n                    if (hasExcessParens(node.init)) {\n                        report(node.init);\n                    }\n                }\n            },\n\n            \"ForStatement > *.init:exit\"(node) {\n\n                /*\n                 * Removing parentheses around `in` expressions might change semantics and cause errors.\n                 *\n                 * For example, this valid for loop:\n                 *      for (let a = (b in c); ;);\n                 * after removing parentheses would be treated as an invalid for-in loop:\n                 *      for (let a = b in c; ;);\n                 */\n\n                if (reportsBuffer.reports.length) {\n                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n                        const path = pathToDescendant(node, inExpressionNode);\n                        let nodeToExclude;\n\n                        for (let i = 0; i < path.length; i++) {\n                            const pathNode = path[i];\n\n                            if (i < path.length - 1) {\n                                const nextPathNode = path[i + 1];\n\n                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n\n                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                                    return;\n                                }\n                            }\n\n                            if (isParenthesised(pathNode)) {\n                                if (isInCurrentReportsBuffer(pathNode)) {\n\n                                    // This node was supposed to be reported, but parentheses might be necessary.\n\n                                    if (isParenthesisedTwice(pathNode)) {\n\n                                        /*\n                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                                         * The remaining pair is safely enclosing the 'in' expression.\n                                         */\n                                        return;\n                                    }\n\n                                    // Exclude the outermost node only.\n                                    if (!nodeToExclude) {\n                                        nodeToExclude = pathNode;\n                                    }\n\n                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                                } else {\n\n                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                                    return;\n                                }\n                            }\n                        }\n\n                        // Exclude the node from the list (i.e. treat parentheses as necessary)\n                        removeFromCurrentReportsBuffer(nodeToExclude);\n                    });\n                }\n\n                endCurrentReportsBuffering();\n            },\n\n            IfStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ImportExpression(node) {\n                const { source } = node;\n\n                if (source.type === \"SequenceExpression\") {\n                    if (hasDoubleExcessParens(source)) {\n                        report(source);\n                    }\n                } else if (hasExcessParens(source)) {\n                    report(source);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const shouldAllowWrapOnce = isMemberExpInNewCallee(node) &&\n                  doesMemberExpressionContainCallExpression(node);\n                const nodeObjHasExcessParens = shouldAllowWrapOnce\n                    ? hasDoubleExcessParens(node.object)\n                    : hasExcessParens(node.object) &&\n                    !(\n                        isImmediateFunctionPrototypeMethodCall(node.parent) &&\n                        node.parent.callee === node &&\n                        IGNORE_FUNCTION_PROTOTYPE_METHODS\n                    );\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  !IGNORE_NEW_IN_MEMBER_EXPR &&\n                  node.object.type === \"NewExpression\" &&\n                  isNewExpressionWithParens(node.object)) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                    node.optional &&\n                    node.object.type === \"ChainExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(property => report(property.value));\n            },\n\n            ObjectPattern(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return canBeAssignmentTarget(value) && hasExcessParens(value);\n                    }).forEach(property => report(property.value));\n            },\n\n            Property(node) {\n                if (node.computed) {\n                    const { key } = node;\n\n                    if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(key);\n                    }\n                }\n            },\n\n            RestElement(node) {\n                const argument = node.argument;\n\n                if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n                    report(argument);\n                }\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                const precedenceOfNode = precedence(node);\n\n                node.expressions\n                    .filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkArgumentWithPrecedence,\n            UpdateExpression(node) {\n                if (node.prefix) {\n                    checkArgumentWithPrecedence(node);\n                } else {\n                    const { argument } = node;\n                    const operatorToken = sourceCode.getLastToken(node);\n\n                    if (argument.loc.end.line === operatorToken.loc.start.line) {\n                        checkArgumentWithPrecedence(node);\n                    } else {\n                        if (hasDoubleExcessParens(argument)) {\n                            report(argument);\n                        }\n                    }\n                }\n            },\n            AwaitExpression: checkArgumentWithPrecedence,\n\n            VariableDeclarator(node) {\n                if (\n                    node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) &&\n\n                    // RegExp literal is allowed to have parens (#1589)\n                    !(node.init.type === \"Literal\" && node.init.regex)\n                ) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator,\n\n            TemplateLiteral(node) {\n                node.expressions\n                    .filter(e => e && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            AssignmentPattern(node) {\n                const { left, right } = node;\n\n                if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n                    report(left);\n                }\n\n                if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(right);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary semicolons\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-semi\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unexpected: \"Unnecessary semicolon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                messageId: \"unexpected\",\n                fix(fixer) {\n\n                    /*\n                     * Expand the replacement range to include the surrounding\n                     * tokens to avoid conflicting with semi.\n                     * https://github.com/eslint/eslint/issues/7928\n                     */\n                    return new FixTracker(fixer, context.getSourceCode())\n                        .retainSurroundingTokens(nodeOrToken)\n                        .remove(nodeOrToken);\n                }\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         * @param {Token} firstToken The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (allowedParentTypes.indexOf(parent.type) === -1) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            MethodDefinition(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node A SwitchCase node to get comments.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n    const comment = lodash.last(sourceCode.getCommentsBefore(node));\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow leading or trailing decimal points in numeric literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-floating-decimal\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n        messages: {\n            leading: \"A leading decimal point can be confused with a dot.\",\n            trailing: \"A trailing decimal point can be confused with a dot.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Literal(node) {\n\n                if (typeof node.value === \"number\") {\n                    if (node.raw.startsWith(\".\")) {\n                        context.report({\n                            node,\n                            messageId: \"leading\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const needsSpaceBefore = tokenBefore &&\n                                    tokenBefore.range[1] === node.range[0] &&\n                                    !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);\n\n                                return fixer.insertTextBefore(node, needsSpaceBefore ? \" 0\" : \"0\");\n                            }\n                        });\n                    }\n                    if (node.raw.indexOf(\".\") === node.raw.length - 1) {\n                        context.report({\n                            node,\n                            messageId: \"trailing\",\n                            fix: fixer => fixer.insertTextAfter(node, \"0\")\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of function declaration identifiers as variables.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning `function` declarations\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-func-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            isAFunction: \"'{{name}}' is a function.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {References} references Collection of reference to check.\n         * @returns {void}\n         */\n        function checkReference(references) {\n            astUtils.getModifyingReferences(references).forEach(reference => {\n                context.report({\n                    node: reference.identifier,\n                    messageId: \"isAFunction\",\n                    data: {\n                        name: reference.identifier.name\n                    }\n                });\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"FunctionName\") {\n                checkReference(variable.references);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            FunctionDeclaration: checkForFunction,\n            FunctionExpression: checkForFunction\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-global-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            globalShouldNotBeModified: \"Read-only global '{{name}}' should not be modified.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    messageId: \"globalShouldNotBeModified\",\n                    data: {\n                        name: identifier.name\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    if (node.operator !== \"~\") {\n        return false;\n    }\n    const callNode = astUtils.skipChainExpression(node.argument);\n\n    return (\n        callNode.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||\n        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useRecommendation: \"use `{{recommendation}}` instead.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                messageId: \"useRecommendation\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for implicit global variables, functions and classes.\n * @author Joshua Peek\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow declarations in the global scope\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-globals\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                lexicalBindings: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            globalNonLexicalBinding: \"Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.\",\n            globalLexicalBinding: \"Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.\",\n            globalVariableLeak: \"Global variable leak, declare the variable if it is intended to be local.\",\n            assignmentToReadonlyGlobal: \"Unexpected assignment to read-only global variable.\",\n            redeclarationOfReadonlyGlobal: \"Unexpected redeclaration of read-only global variable.\"\n        }\n    },\n\n    create(context) {\n\n        const checkLexicalBindings = context.options[0] && context.options[0].lexicalBindings === true;\n\n        /**\n         * Reports the node.\n         * @param {ASTNode} node Node to report.\n         * @param {string} messageId Id of the message to report.\n         * @param {string|undefined} kind Declaration kind, can be 'var', 'const', 'let', function or class.\n         * @returns {void}\n         */\n        function report(node, messageId, kind) {\n            context.report({\n                node,\n                messageId,\n                data: {\n                    kind\n                }\n            });\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                scope.variables.forEach(variable => {\n\n                    // Only ESLint global variables have the `writable` key.\n                    const isReadonlyEslintGlobalVariable = variable.writeable === false;\n                    const isWritableEslintGlobalVariable = variable.writeable === true;\n\n                    if (isWritableEslintGlobalVariable) {\n\n                        // Everything is allowed with writable ESLint global variables.\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        const defNode = def.node;\n\n                        if (def.type === \"FunctionName\" || (def.type === \"Variable\" && def.parent.kind === \"var\")) {\n                            if (isReadonlyEslintGlobalVariable) {\n                                report(defNode, \"redeclarationOfReadonlyGlobal\");\n                            } else {\n                                report(\n                                    defNode,\n                                    \"globalNonLexicalBinding\",\n                                    def.type === \"FunctionName\" ? \"function\" : `'${def.parent.kind}'`\n                                );\n                            }\n                        }\n\n                        if (checkLexicalBindings) {\n                            if (def.type === \"ClassName\" ||\n                                    (def.type === \"Variable\" && (def.parent.kind === \"let\" || def.parent.kind === \"const\"))) {\n                                if (isReadonlyEslintGlobalVariable) {\n                                    report(defNode, \"redeclarationOfReadonlyGlobal\");\n                                } else {\n                                    report(\n                                        defNode,\n                                        \"globalLexicalBinding\",\n                                        def.type === \"ClassName\" ? \"class\" : `'${def.parent.kind}'`\n                                    );\n                                }\n                            }\n                        }\n                    });\n                });\n\n                // Undeclared assigned variables.\n                scope.implicit.variables.forEach(variable => {\n                    const scopeVariable = scope.set.get(variable.name);\n                    let messageId;\n\n                    if (scopeVariable) {\n\n                        // ESLint global variable\n                        if (scopeVariable.writeable) {\n                            return;\n                        }\n                        messageId = \"assignmentToReadonlyGlobal\";\n\n                    } else {\n\n                        // Reference to an unknown variable, possible global leak.\n                        messageId = \"globalVariableLeak\";\n                    }\n\n                    // def.node is an AssignmentExpression, ForInStatement or ForOfStatement.\n                    variable.defs.forEach(def => {\n                        report(def.node, messageId);\n                    });\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { getStaticValue } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\n        },\n\n        schema: [],\n\n        messages: {\n            impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n        }\n    },\n\n    create(context) {\n        const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n\n        /**\n         * Checks whether a node is evaluated as a string or not.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is evaluated as a string.\n         */\n        function isEvaluatedString(node) {\n            if (\n                (node.type === \"Literal\" && typeof node.value === \"string\") ||\n                node.type === \"TemplateLiteral\"\n            ) {\n                return true;\n            }\n            if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n                return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n            }\n            return false;\n        }\n\n        /**\n         * Reports if the `CallExpression` node has evaluated argument.\n         * @param {ASTNode} node A CallExpression to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalCallExpression(node) {\n            const [firstArgument] = node.arguments;\n\n            if (firstArgument) {\n\n                const staticValue = getStaticValue(firstArgument, context.getScope());\n                const isStaticString = staticValue && typeof staticValue.value === \"string\";\n                const isString = isStaticString || isEvaluatedString(firstArgument);\n\n                if (isString) {\n                    context.report({\n                        node,\n                        messageId: \"impliedEval\"\n                    });\n                }\n            }\n\n        }\n\n        /**\n         * Reports calls of `implied eval` via the global references.\n         * @param {Variable} globalVar A global variable to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalViaGlobal(globalVar) {\n            const { references, name } = globalVar;\n\n            references.forEach(ref => {\n                const identifier = ref.identifier;\n                let node = identifier.parent;\n\n                while (astUtils.isSpecificMemberAccess(node, null, name)) {\n                    node = node.parent;\n                }\n\n                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n                    const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n                    const parent = calleeNode.parent;\n\n                    if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n                        reportImpliedEvalCallExpression(parent);\n                    }\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n                    reportImpliedEvalCallExpression(node);\n                }\n            },\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                GLOBAL_CANDIDATES\n                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))\n                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)\n                    .forEach(reportImpliedEvalViaGlobal);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // Destructuring assignments\n        parent.type === \"ArrayPattern\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n    const argumentNode = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n    const { parent } = argumentNode;\n\n    return (\n        (\n            parent.type === \"UpdateExpression\" &&\n            parent.argument === argumentNode\n        ) ||\n        (\n            parent.type === \"UnaryExpression\" &&\n            parent.operator === \"delete\" &&\n            parent.argument === argumentNode\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"ForInStatement\" &&\n            parent.left === node\n        ) ||\n        (\n            parent.type === \"ForOfStatement\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n    const { parent } = node;\n\n    if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n        return false;\n    }\n    const callee = astUtils.skipChainExpression(parent.callee);\n\n    if (\n        !astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) &&\n        !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)\n    ) {\n        return false;\n    }\n    const variable = findVariable(scope, callee.object);\n\n    return variable !== null && variable.scope.type === \"global\";\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n    const { parent } = id;\n\n    return (\n        (\n            parent.type === \"MemberExpression\" &&\n            parent.object === id &&\n            (\n                isAssignmentLeft(parent) ||\n                isOperandOfMutationUnaryOperator(parent) ||\n                isIterationVariable(parent)\n            )\n        ) ||\n        isArgumentOfWellKnownMutationFunction(id, scope)\n    );\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n    let node = id.parent;\n\n    while (\n        node &&\n        node.type !== \"AssignmentExpression\" &&\n        node.type !== \"UpdateExpression\" &&\n        node.type !== \"UnaryExpression\" &&\n        node.type !== \"CallExpression\" &&\n        node.type !== \"ForInStatement\" &&\n        node.type !== \"ForOfStatement\"\n    ) {\n        node = node.parent;\n    }\n\n    return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assigning to imported bindings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-import-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            readonly: \"'{{name}}' is read-only.\",\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ImportDeclaration(node) {\n                const scope = context.getScope();\n\n                for (const variable of context.getDeclaredVariables(node)) {\n                    const shouldCheckMembers = variable.defs.some(\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\n                    );\n                    let prevIdNode = null;\n\n                    for (const reference of variable.references) {\n                        const idNode = reference.identifier;\n\n                        /*\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n                         * references for the same identifier. This should skip\n                         * the one of the two in order to prevent redundant reports.\n                         */\n                        if (idNode === prevIdNode) {\n                            continue;\n                        }\n                        prevIdNode = idNode;\n\n                        if (reference.isWrite()) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonly\",\n                                data: { name: idNode.name }\n                            });\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonlyMember\",\n                                data: { name: idNode.name }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow inline comments after code\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-inline-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignorePattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedInlineComment: \"Unexpected comment inline with code.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0];\n        let customIgnoreRegExp;\n\n        if (options && options.ignorePattern) {\n            customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\n        }\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n                endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n                preamble = startLine.slice(0, node.loc.start.column).trim(),\n                postamble = endLine.slice(node.loc.end.column).trim(),\n                isPreambleEmpty = !preamble,\n                isPostambleEmpty = !postamble;\n\n            // Nothing on both sides\n            if (isPreambleEmpty && isPostambleEmpty) {\n                return;\n            }\n\n            // Matches the ignore pattern\n            if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n                return;\n            }\n\n            // JSX Exception\n            if (\n                (isPreambleEmpty || preamble === \"{\") &&\n                (isPostambleEmpty || postamble === \"}\")\n            ) {\n                const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n\n                if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n                    return;\n                }\n            }\n\n            // Don't report ESLint directive comments\n            if (astUtils.isDirectiveComment(node)) {\n                return;\n            }\n\n            context.report({\n                node,\n                messageId: \"unexpectedInlineComment\"\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.getAllComments()\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(testCodeAroundComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validParent = new Set([\"Program\", \"ExportNamedDeclaration\", \"ExportDefaultDeclaration\"]);\nconst validBlockStatementParent = new Set([\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"]);\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow variable or `function` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-inner-declarations\"\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ],\n\n        messages: {\n            moveDeclToRoot: \"Move {{type}} declaration to {{body}} root.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const parent = node.parent;\n\n            if (\n                parent.type === \"BlockStatement\" && validBlockStatementParent.has(parent.parent.type)\n            ) {\n                return;\n            }\n\n            if (validParent.has(parent.type)) {\n                return;\n            }\n\n            const upperFunction = astUtils.getUpperFunction(parent);\n\n            context.report({\n                node,\n                messageId: \"moveDeclToRoot\",\n                data: {\n                    type: (node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\"),\n                    body: (upperFunction === null ? \"program\" : \"function body\")\n                }\n            });\n        }\n\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            regexMessage: \"{{message}}.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n         * Examples:\n         *     new RegExp(\".\")         // => \"\"\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\n         *     new RegExp(\".\", flags)  // => null\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\n         * @returns {string|null} flags if they can be determined, `null` otherwise\n         * @private\n         */\n        function getFlags(node) {\n            if (node.arguments.length < 2) {\n                return \"\";\n            }\n\n            if (isString(node.arguments[1])) {\n                return node.arguments[1].value;\n            }\n\n            return null;\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {boolean} uFlag The Unicode flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, uFlag) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            try {\n                validator.validateFlags(flags);\n                return null;\n            } catch {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n                    return;\n                }\n                const pattern = node.arguments[0].value;\n                let flags = getFlags(node);\n\n                if (flags && allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                const message =\n                    (\n                        flags && validateRegExpFlags(flags)\n                    ) ||\n                    (\n\n                        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n                        flags === null\n                            ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\n                            : validateRegExpPattern(pattern, flags.includes(\"u\"))\n                    );\n\n                if (message) {\n                    context.report({\n                        node,\n                        messageId: \"regexMessage\",\n                        data: { message }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-invalid-this\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    capIsConstructor: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedThis: \"Unexpected 'this'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const capIsConstructor = options.capIsConstructor !== false;\n        const stack = [],\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode,\n                    { capIsConstructor }\n                );\n            }\n            return current;\n        };\n\n        /**\n         * Pushs new checking context into the stack.\n         *\n         * The checking context is not initialized yet.\n         * Because most functions don't have `this` keyword.\n         * When `this` keyword was found, the checking context is initialized.\n         * @param {ASTNode} node A function node that was entered.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n\n            // `this` can be invalid only under strict mode.\n            stack.push({\n                init: !context.getScope().isStrict,\n                node,\n                valid: true\n            });\n        }\n\n        /**\n         * Pops the current checking context from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            stack.pop();\n        }\n\n        return {\n\n            /*\n             * `this` is invalid only under strict mode.\n             * Modules is always strict mode.\n             */\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {};\n\n                stack.push({\n                    init: true,\n                    node,\n                    valid: !(\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict)\n                    )\n                });\n            },\n\n            \"Program:exit\"() {\n                stack.pop();\n            },\n\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (current && !current.valid) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedThis\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow irregular whitespace\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipStrings: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    skipTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipRegExps: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n        }\n    },\n\n    create(context) {\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        const options = context.options[0] || {};\n        const skipComments = !!options.skipComments;\n        const skipStrings = options.skipStrings !== false;\n        const skipRegExps = !!options.skipRegExps;\n        const skipTemplates = !!options.skipTemplates;\n\n        const sourceCode = context.getSourceCode();\n        const commentNodes = sourceCode.getAllComments();\n\n        /**\n         * Removes errors that occur inside the given node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(({ loc: { start: errorLocStart } }) => (\n                errorLocStart.line < locStart.line ||\n                errorLocStart.line === locStart.line && errorLocStart.column < locStart.column ||\n                errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column ||\n                errorLocStart.line > locEnd.line\n            ));\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    errors.push({\n                        node,\n                        messageId: \"noIrregularWhitespace\",\n                        loc: {\n                            start: {\n                                line: lineNumber,\n                                column: match.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: match.index + match[0].length\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n\n                errors.push({\n                    node,\n                    messageId: \"noIrregularWhitespace\",\n                    loc: {\n                        start: {\n                            line: lineIndex + 1,\n                            column: sourceLines[lineIndex].length\n                        },\n                        end: {\n                            line: lineIndex + 2,\n                            column: 0\n                        }\n                    }\n                });\n\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes[\"Program:exit\"] = function() {\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => context.report(error));\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n","/**\n * @fileoverview Rule to flag usage of __iterator__ property\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getStaticPropertyName } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of the `__iterator__` property\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-iterator\"\n        },\n\n        schema: [],\n\n        messages: {\n            noIterator: \"Reserved name '__iterator__'.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (getStaticPropertyName(node) === \"__iterator__\") {\n                    context.report({\n                        node,\n                        messageId: \"noIterator\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag labels that are the same as an identifier\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow labels that share a name with a variable\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-label-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            identifierClashWithLabel: \"Found identifier with same name as label.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the identifier is present inside current scope\n         * @param {Object} scope current scope\n         * @param {string} name To evaluate\n         * @returns {boolean} True if its present\n         * @private\n         */\n        function findIdentifier(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LabeledStatement(node) {\n\n                // Fetch the innermost scope.\n                const scope = context.getScope();\n\n                /*\n                 * Recursively find the identifier walking up the scope, starting\n                 * with the innermost scope.\n                 */\n                if (findIdentifier(scope, node.label.name)) {\n                    context.report({\n                        node,\n                        messageId: \"identifierClashWithLabel\"\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow labeled statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-labels\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowLoop: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSwitch: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLabel: \"Unexpected labeled statement.\",\n            unexpectedLabelInBreak: \"Unexpected label in break statement.\",\n            unexpectedLabelInContinue: \"Unexpected label in continue statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const allowLoop = options && options.allowLoop;\n        const allowSwitch = options && options.allowSwitch;\n        let scopeInfo = null;\n\n        /**\n         * Gets the kind of a given node.\n         * @param {ASTNode} node A node to get.\n         * @returns {string} The kind of the node.\n         */\n        function getBodyKind(node) {\n            if (astUtils.isLoop(node)) {\n                return \"loop\";\n            }\n            if (node.type === \"SwitchStatement\") {\n                return \"switch\";\n            }\n            return \"other\";\n        }\n\n        /**\n         * Checks whether the label of a given kind is allowed or not.\n         * @param {string} kind A kind to check.\n         * @returns {boolean} `true` if the kind is allowed.\n         */\n        function isAllowed(kind) {\n            switch (kind) {\n                case \"loop\": return allowLoop;\n                case \"switch\": return allowSwitch;\n                default: return false;\n            }\n        }\n\n        /**\n         * Checks whether a given name is a label of a loop or not.\n         * @param {string} label A name of a label to check.\n         * @returns {boolean} `true` if the name is a label of a loop.\n         */\n        function getKind(label) {\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    return info.kind;\n                }\n                info = info.upper;\n            }\n\n            /* istanbul ignore next: syntax error */\n            return \"other\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LabeledStatement(node) {\n                scopeInfo = {\n                    label: node.label.name,\n                    kind: getBodyKind(node.body),\n                    upper: scopeInfo\n                };\n            },\n\n            \"LabeledStatement:exit\"(node) {\n                if (!isAllowed(scopeInfo.kind)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabel\"\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            BreakStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabelInBreak\"\n                    });\n                }\n            },\n\n            ContinueStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLabelInContinue\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n        },\n\n        schema: [],\n\n        messages: {\n            redundantBlock: \"Block is redundant.\",\n            redundantNestedBlock: \"Nested block is redundant.\"\n        }\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node The node to be reported.\n         * @returns {void}\n         */\n        function report(node) {\n            const messageId = node.parent.type === \"BlockStatement\" ? \"redundantNestedBlock\" : \"redundantBlock\";\n\n            context.report({\n                node,\n                messageId\n            });\n        }\n\n        /**\n         * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n         */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n         */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings, or that's only child of another block\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    } else if (\n                        node.parent.type === \"BlockStatement\" &&\n                        node.parent.body.length === 1\n                    ) {\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function() {\n                if (context.getScope().isStrict) {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n","/**\n * @fileoverview Rule to disallow if as the only statement in an else block\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `if` statements as the only statement in `else` blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-lonely-if\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedLonelyIf: \"Unexpected if as the only statement in an else block.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            IfStatement(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                if (parent && parent.type === \"BlockStatement\" &&\n                        parent.body.length === 1 && grandparent &&\n                        grandparent.type === \"IfStatement\" &&\n                        parent === grandparent.alternate) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLonelyIf\",\n                        fix(fixer) {\n                            const openingElseCurly = sourceCode.getFirstToken(parent);\n                            const closingElseCurly = sourceCode.getLastToken(parent);\n                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n                            const lastIfToken = sourceCode.getLastToken(node.consequent);\n                            const sourceText = sourceCode.getText();\n\n                            if (sourceText.slice(openingElseCurly.range[1],\n                                node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n\n                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)\n                                return null;\n                            }\n\n                            if (\n                                node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock &&\n                                (\n                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||\n                                    /^[([/+`-]/u.test(tokenAfterElseBlock.value) ||\n                                    lastIfToken.value === \"++\" ||\n                                    lastIfToken.value === \"--\"\n                                )\n                            ) {\n\n                                /*\n                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing\n                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [openingElseCurly.range[0], closingElseCurly.range[1]],\n                                (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node)\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n * @param {ASTNode} node An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param {ASTNode} node A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    const border = excludedNode ? excludedNode.range[1] : 0;\n    let retv = node;\n    let containingLoopNode = node;\n\n    while (containingLoopNode && containingLoopNode.range[0] >= border) {\n        retv = containingLoopNode;\n        containingLoopNode = getContainingLoopNode(containingLoopNode);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param {ASTNode} loopNode A containing loop node.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    /*\n     * Variables which are declared by `let` in the loop is safe.\n     * It's a different instance from the next loop step's.\n     */\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    /*\n     * WriteReferences which exist after this border are unsafe because those\n     * can modify the variable.\n     */\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     * @param {eslint-scope.Reference} upperRef A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow function declarations that contain unsafe references inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loop-func\"\n        },\n\n        schema: [],\n\n        messages: {\n            unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n            const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n            if (unsafeRefs.length > 0) {\n                context.report({\n                    node,\n                    messageId: \"unsafeRefs\",\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow literal numbers that lose precision\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n        },\n        schema: [],\n        messages: {\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n         * @param {Node} node the number `Literal` node\n         * @returns {string} raw source code of the literal, without numeric separators\n         */\n        function getRaw(node) {\n            return node.raw.replace(/_/gu, \"\");\n        }\n\n        /**\n         * Checks whether the number is  base ten\n         * @param {ASTNode} node the node being evaluated\n         * @returns {boolean} true if the node is in base ten\n         */\n        function isBaseTen(node) {\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\n            !/^0[0-7]+$/u.test(node.raw);\n        }\n\n        /**\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function notBaseTenLosesPrecision(node) {\n            const rawString = getRaw(node).toUpperCase();\n            let base = 0;\n\n            if (rawString.startsWith(\"0B\")) {\n                base = 2;\n            } else if (rawString.startsWith(\"0X\")) {\n                base = 16;\n            } else {\n                base = 8;\n            }\n\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\n        }\n\n        /**\n         * Adds a decimal point to the numeric string at index 1\n         * @param {string} stringNumber the numeric string without any decimal point\n         * @returns {string} the numeric string with a decimal point in the proper place\n         */\n        function addDecimalPointToNumber(stringNumber) {\n            return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n        }\n\n        /**\n         * Returns the number stripped of leading zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeLeadingZeros(numberAsString) {\n            return numberAsString.replace(/^0*/u, \"\");\n        }\n\n        /**\n         * Returns the number stripped of trailing zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeTrailingZeros(numberAsString) {\n            return numberAsString.replace(/0*$/u, \"\");\n        }\n\n        /**\n         * Converts an integer to to an object containing the integer's coefficient and order of magnitude\n         * @param {string} stringInteger the string representation of the integer being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeInteger(stringInteger) {\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n\n            return {\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n                coefficient: addDecimalPointToNumber(significantDigits)\n            };\n        }\n\n        /**\n         *\n         * Converts a float to to an object containing the floats's coefficient and order of magnitude\n         * @param {string} stringFloat the string representation of the float being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeFloat(stringFloat) {\n            const trimmedFloat = removeLeadingZeros(stringFloat);\n\n            if (trimmedFloat.startsWith(\".\")) {\n                const decimalDigits = trimmedFloat.split(\".\").pop();\n                const significantDigits = removeLeadingZeros(decimalDigits);\n\n                return {\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\n                    coefficient: addDecimalPointToNumber(significantDigits)\n                };\n\n            }\n            return {\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n\n            };\n        }\n\n\n        /**\n         * Converts a base ten number to proper scientific notation\n         * @param {string} stringNumber the string representation of the base ten number to be converted\n         * @returns {string} the number converted to scientific notation\n         */\n        function convertNumberToScientificNotation(stringNumber) {\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n            const originalCoefficient = splitNumber[0];\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\n                : normalizeInteger(originalCoefficient);\n            const normalizedCoefficient = normalizedNumber.coefficient;\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\n                : normalizedNumber.magnitude;\n\n            return `${normalizedCoefficient}e${magnitude}`;\n\n        }\n\n        /**\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function baseTenLosesPrecision(node) {\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n            if (requestedPrecision > 100) {\n                return true;\n            }\n            const storedNumber = node.value.toPrecision(requestedPrecision);\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n\n            return normalizedRawNumber !== normalizedStoredNumber;\n        }\n\n\n        /**\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function losesPrecision(node) {\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n        }\n\n\n        return {\n            Literal(node) {\n                if (node.value && isNumber(node) && losesPrecision(node)) {\n                    context.report({\n                        messageId: \"noLossOfPrecision\",\n                        node\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n    if (typeof x === \"string\") {\n        return BigInt(x.slice(0, -1));\n    }\n    return x;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        anyOf: [\n                            { type: \"number\" },\n                            { type: \"string\", pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\" }\n                        ]\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreDefaultValues: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = (config.ignore || []).map(normalizeIgnoreValue),\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n            ignoreDefaultValues = !!config.ignoreDefaultValues;\n\n        const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n        /**\n         * Returns whether the rule is configured to ignore the given value\n         * @param {bigint|number} value The value to check\n         * @returns {boolean} true if the value is ignored\n         */\n        function isIgnoredValue(value) {\n            return ignore.indexOf(value) !== -1;\n        }\n\n        /**\n         * Returns whether the number is a default value assignment.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is a default value\n         */\n        function isDefaultValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is radix\n         */\n        function isParseIntRadix(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] &&\n                (\n                    astUtils.isSpecificId(parent.callee, \"parseInt\") ||\n                    astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\")\n                );\n        }\n\n        /**\n         * Returns whether the given node is a direct child of a JSX node.\n         * In particular, it aims to detect numbers used as prop values in JSX tags.\n         * Example: <input maxLength={10} />\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is a JSX number\n         */\n        function isJSXNumber(fullNumberNode) {\n            return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the given node is used as an array index.\n         * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n         * which can be created and accessed on an array in addition to the array index properties,\n         * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n         *\n         * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n         * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n         *\n         * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * Valid examples:\n         * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n         * a[-0] (same as a[0] because -0 coerces to \"0\")\n         * a[-0n] (-0n evaluates to 0n)\n         *\n         * Invalid examples:\n         * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n         * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n         * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n         * a[1e310] (same as a[\"Infinity\"])\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @param {bigint|number} value Value expressed by the fullNumberNode\n         * @returns {boolean} true if the node is a valid array index\n         */\n        function isArrayIndex(fullNumberNode, value) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"MemberExpression\" && parent.property === fullNumberNode &&\n                (Number.isInteger(value) || typeof value === \"bigint\") &&\n                value >= 0 && value < MAX_ARRAY_LENGTH;\n        }\n\n        return {\n            Literal(node) {\n                if (!astUtils.isNumericLiteral(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let value;\n                let raw;\n\n                // Treat unary minus as a part of the number\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                const parent = fullNumberNode.parent;\n\n                // Always allow radix arguments and JSX props\n                if (\n                    isIgnoredValue(value) ||\n                    (ignoreDefaultValues && isDefaultValue(fullNumberNode)) ||\n                    isParseIntRadix(fullNumberNode) ||\n                    isJSXNumber(fullNumberNode) ||\n                    (ignoreArrayIndexes && isArrayIndex(fullNumberNode, value))\n                ) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n/**\n * Check whether a given character is a combining mark or not.\n * @param {number} codePoint The character code to check.\n * @returns {boolean} `true` if the character belongs to the category, any of `Mc`, `Me`, and `Mn`.\n */\nmodule.exports = function isCombiningCharacter(codePoint) {\n    return /^[\\p{Mc}\\p{Me}\\p{Mn}]$/u.test(String.fromCodePoint(codePoint));\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n/**\n * Check whether a given character is an emoji modifier.\n * @param {number} code The character code to check.\n * @returns {boolean} `true` if the character is an emoji modifier.\n */\nmodule.exports = function isEmojiModifier(code) {\n    return code >= 0x1F3FB && code <= 0x1F3FF;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n/**\n * Check whether a given character is a regional indicator symbol.\n * @param {number} code The character code to check.\n * @returns {boolean} `true` if the character is a regional indicator symbol.\n */\nmodule.exports = function isRegionalIndicatorSymbol(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\n/**\n * Check whether given two characters are a surrogate pair.\n * @param {number} lead The code of the lead character.\n * @param {number} tail The code of the tail character.\n * @returns {boolean} `true` if the character pair is a surrogate pair.\n */\nmodule.exports = function isSurrogatePair(lead, tail) {\n    return lead >= 0xD800 && lead < 0xDC00 && tail >= 0xDC00 && tail < 0xE000;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nmodule.exports = {\n    isCombiningCharacter: require(\"./is-combining-character\"),\n    isEmojiModifier: require(\"./is-emoji-modifier\"),\n    isRegionalIndicatorSymbol: require(\"./is-regional-indicator-symbol\"),\n    isSurrogatePair: require(\"./is-surrogate-pair\")\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\"\n        }\n    },\n    create(context) {\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags) {\n            const has = {\n                surrogatePairWithoutUFlag: false,\n                combiningClass: false,\n                variationSelector: false,\n                emojiModifier: false,\n                regionalIndicatorSymbol: false,\n                zwj: false\n            };\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    flags.includes(\"u\")\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n                        }\n                    }\n                }\n            });\n\n            for (const kind of kinds) {\n                if (has[kind]) {\n                    context.report({ node, messageId: kind });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags);\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS,\n    TERNARY_OPERATOR,\n    COALESCE_OPERATOR\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array.<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (getChildNode(parent) === node) ? node : parent;\n            const right = (getChildNode(parent) !== node) ? node : parent;\n            const data = {\n                leftOperator: left.operator || \"?:\",\n                rightOperator: right.operator || \"?:\"\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (\n                TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"boolean\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            grouping: {\n                                type: \"boolean\"\n                            },\n                            allowCall: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            noMixRequire: \"Do not mix 'require' and other declarations.\",\n            noMixCoreModuleFileComputed: \"Do not mix core, module, file and computed requires.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let grouping = false,\n            allowCall = false;\n\n        if (typeof options === \"object\") {\n            grouping = options.grouping;\n            allowCall = options.allowCall;\n        } else {\n            grouping = !!options;\n        }\n\n        /**\n         * Returns the list of built-in modules.\n         * @returns {string[]} An array of built-in Node.js modules.\n         */\n        function getBuiltinModules() {\n\n            /*\n             * This list is generated using:\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n             */\n            return [\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\n            ];\n        }\n\n        const BUILTIN_MODULES = getBuiltinModules();\n\n        const DECL_REQUIRE = \"require\",\n            DECL_UNINITIALIZED = \"uninitialized\",\n            DECL_OTHER = \"other\";\n\n        const REQ_CORE = \"core\",\n            REQ_FILE = \"file\",\n            REQ_MODULE = \"module\",\n            REQ_COMPUTED = \"computed\";\n\n        /**\n         * Determines the type of a declaration statement.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The type of declaration represented by the expression.\n         */\n        function getDeclarationType(initExpression) {\n            if (!initExpression) {\n\n                // \"var x;\"\n                return DECL_UNINITIALIZED;\n            }\n\n            if (initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"Identifier\" &&\n                initExpression.callee.name === \"require\"\n            ) {\n\n                // \"var x = require('util');\"\n                return DECL_REQUIRE;\n            }\n            if (allowCall &&\n                initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"CallExpression\"\n            ) {\n\n                // \"var x = require('diagnose')('sub-module');\"\n                return getDeclarationType(initExpression.callee);\n            }\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return getDeclarationType(initExpression.object);\n            }\n\n            // \"var x = 42;\"\n            return DECL_OTHER;\n        }\n\n        /**\n         * Determines the type of module that is loaded via require.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The module type.\n         */\n        function inferModuleType(initExpression) {\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return inferModuleType(initExpression.object);\n            }\n            if (initExpression.arguments.length === 0) {\n\n                // \"var x = require();\"\n                return REQ_COMPUTED;\n            }\n\n            const arg = initExpression.arguments[0];\n\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n\n                // \"var x = require(42);\"\n                return REQ_COMPUTED;\n            }\n\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n\n                // \"var fs = require('fs');\"\n                return REQ_CORE;\n            }\n            if (/^\\.{0,2}\\//u.test(arg.value)) {\n\n                // \"var utils = require('./utils');\"\n                return REQ_FILE;\n            }\n\n            // \"var async = require('async');\"\n            return REQ_MODULE;\n\n        }\n\n        /**\n         * Check if the list of variable declarations is mixed, i.e. whether it\n         * contains both require and other declarations.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are mixed, false if not.\n         */\n        function isMixed(declarations) {\n            const contains = {};\n\n            declarations.forEach(declaration => {\n                const type = getDeclarationType(declaration.init);\n\n                contains[type] = true;\n            });\n\n            return !!(\n                contains[DECL_REQUIRE] &&\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\n            );\n        }\n\n        /**\n         * Check if all require declarations in the given list are of the same\n         * type.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are grouped, false if not.\n         */\n        function isGrouped(declarations) {\n            const found = {};\n\n            declarations.forEach(declaration => {\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n                    found[inferModuleType(declaration.init)] = true;\n                }\n            });\n\n            return Object.keys(found).length <= 1;\n        }\n\n\n        return {\n\n            VariableDeclaration(node) {\n\n                if (isMixed(node.declarations)) {\n                    context.report({\n                        node,\n                        messageId: \"noMixRequire\"\n                    });\n                } else if (grouping && !isGrouped(node.declarations)) {\n                    context.report({\n                        node,\n                        messageId: \"noMixCoreModuleFileComputed\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow mixed spaces and tabs for indentation\n * @author Jary Niebur\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow mixed spaces and tabs for indentation\",\n            category: \"Stylistic Issues\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-mixed-spaces-and-tabs\"\n        },\n\n        schema: [\n            {\n                enum: [\"smart-tabs\", true, false]\n            }\n        ],\n\n        messages: {\n            mixedSpacesAndTabs: \"Mixed spaces and tabs.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        let smartTabs;\n\n        switch (context.options[0]) {\n            case true: // Support old syntax, maybe add deprecation warning here\n            case \"smart-tabs\":\n                smartTabs = true;\n                break;\n            default:\n                smartTabs = false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"Program:exit\"(node) {\n                const lines = sourceCode.lines,\n                    comments = sourceCode.getAllComments(),\n                    ignoredCommentLines = new Set();\n\n                // Add all lines except the first ones.\n                comments.forEach(comment => {\n                    for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {\n                        ignoredCommentLines.add(i);\n                    }\n                });\n\n                /*\n                 * At least one space followed by a tab\n                 * or the reverse before non-tab/-space\n                 * characters begin.\n                 */\n                let regex = /^(?=( +|\\t+))\\1(?:\\t| )/u;\n\n                if (smartTabs) {\n\n                    /*\n                     * At least one space followed by a tab\n                     * before non-tab/-space characters begin.\n                     */\n                    regex = /^(?=(\\t*))\\1(?=( +))\\2\\t/u;\n                }\n\n                lines.forEach((line, i) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        const lineNumber = i + 1;\n                        const loc = {\n                            start: {\n                                line: lineNumber,\n                                column: match[0].length - 2\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: match[0].length\n                            }\n                        };\n\n                        if (!ignoredCommentLines.has(lineNumber)) {\n                            const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));\n\n                            if (!(containingNode && [\"Literal\", \"TemplateElement\"].includes(containingNode.type))) {\n                                context.report({\n                                    node,\n                                    loc,\n                                    messageId: \"mixedSpacesAndTabs\"\n                                });\n                            }\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check use of chained assignment expressions\n * @author Stewart Rand\n */\n\n\"use strict\";\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of chained assignment expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedChain: \"Unexpected chained assignment.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            AssignmentExpression(node) {\n                if ([\"AssignmentExpression\", \"VariableDeclarator\"].indexOf(node.parent.type) !== -1) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedChain\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            multipleSpaces: \"Multiple spaces found before '{{displayValue}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: { start: leftToken.loc.end, end: rightToken.loc.start },\n                        messageId: \"multipleSpaces\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when using multiline strings\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow multiline strings\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-str\"\n        },\n\n        schema: [],\n\n        messages: {\n            multilineString: \"Multiline support is limited to browsers supporting ES5 only.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a JSX node, false if not.\n         * @private\n         */\n        function isJSXElement(node) {\n            return node.type.indexOf(\"JSX\") === 0;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Literal(node) {\n                if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {\n                    context.report({\n                        node,\n                        messageId: \"multilineString\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n            blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n            consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n        }\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let messageId, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            messageId = \"blankBeginningOfFile\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            messageId = \"blankEndOfFile\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            messageId = \"consecutiveBlank\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: {\n                                    start: { line: lastLineNumber + maxAllowed + 1, column: 0 },\n                                    end: { line: lineNumber, column: 0 }\n                                },\n                                messageId,\n                                data: {\n                                    max: maxAllowed,\n                                    pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n                                },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-native-reassign\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"no-global-assign\"],\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            nativeReassign: \"Read-only global '{{name}}' should not be modified.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    messageId: \"nativeReassign\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow a negated condition\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow negated conditions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-negated-condition\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedNegated: \"Unexpected negated condition.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is an if-else without a condition on the else\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has an else without an if.\n         * @private\n         */\n        function hasElseWithoutCondition(node) {\n            return node.alternate && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * Determines if a given node is a negated unary expression\n         * @param {Object} test The test object to check.\n         * @returns {boolean} True if the node is a negated unary expression.\n         * @private\n         */\n        function isNegatedUnaryExpression(test) {\n            return test.type === \"UnaryExpression\" && test.operator === \"!\";\n        }\n\n        /**\n         * Determines if a given node is a negated binary expression\n         * @param {Test} test The test to check.\n         * @returns {boolean} True if the node is a negated binary expression.\n         * @private\n         */\n        function isNegatedBinaryExpression(test) {\n            return test.type === \"BinaryExpression\" &&\n                (test.operator === \"!=\" || test.operator === \"!==\");\n        }\n\n        /**\n         * Determines if a given node has a negated if expression\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has a negated if expression.\n         * @private\n         */\n        function isNegatedIf(node) {\n            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);\n        }\n\n        return {\n            IfStatement(node) {\n                if (!hasElseWithoutCondition(node)) {\n                    return;\n                }\n\n                if (isNegatedIf(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedNegated\"\n                    });\n                }\n            },\n            ConditionalExpression(node) {\n                if (isNegatedIf(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedNegated\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow negated left operands of the `in` operator\n * @author Michael Ficarra\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand in `in` expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-negated-in-lhs\"\n        },\n\n        replacedBy: [\"no-unsafe-negation\"],\n\n        deprecated: true,\n        schema: [],\n\n        messages: {\n            negatedLHS: \"The 'in' expression's left operand is negated.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                if (node.operator === \"in\" && node.left.type === \"UnaryExpression\" && node.left.operator === \"!\") {\n                    context.report({ node, messageId: \"negatedLHS\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag nested ternary expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow nested ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-nested-ternary\"\n        },\n\n        schema: [],\n\n        messages: {\n            noNestedTernary: \"Do not nest ternary expressions.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            ConditionalExpression(node) {\n                if (node.alternate.type === \"ConditionalExpression\" ||\n                        node.consequent.type === \"ConditionalExpression\") {\n                    context.report({\n                        node,\n                        messageId: \"noNestedTernary\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when using new Function\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with the `Function` object\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-func\"\n        },\n\n        schema: [],\n\n        messages: {\n            noFunctionConstructor: \"The Function constructor is eval.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const variable = globalScope.set.get(\"Function\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(ref => {\n                        const node = ref.identifier;\n                        const { parent } = node;\n\n                        if (\n                            parent &&\n                            (parent.type === \"NewExpression\" || parent.type === \"CallExpression\") &&\n                            node === parent.callee\n                        ) {\n                            context.report({\n                                node: parent,\n                                messageId: \"noFunctionConstructor\"\n                            });\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow calls to the Object constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `Object` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-object\"\n        },\n\n        schema: [],\n\n        messages: {\n            preferLiteral: \"The object literal notation {} is preferrable.\"\n        }\n    },\n\n    create(context) {\n        return {\n            NewExpression(node) {\n                const variable = astUtils.getVariableByName(\n                    context.getScope(),\n                    node.callee.name\n                );\n\n                if (variable && variable.identifiers.length > 0) {\n                    return;\n                }\n\n                if (node.callee.name === \"Object\") {\n                    context.report({\n                        node,\n                        messageId: \"preferLiteral\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of new operator with the `require` function\n * @author Wil Moore III\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with calls to `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-require\"\n        },\n\n        schema: [],\n\n        messages: {\n            noNewRequire: \"Unexpected use of new with require.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.type === \"Identifier\" && node.callee.name === \"require\") {\n                    context.report({\n                        node,\n                        messageId: \"noNewRequire\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of the new operator with the `Symbol` object\n * @author Alberto Rodríguez\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `new` operators with the `Symbol` object\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-new-symbol\"\n        },\n\n        schema: [],\n\n        messages: {\n            noNewSymbol: \"`Symbol` cannot be called as a constructor.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const variable = globalScope.set.get(\"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(ref => {\n                        const node = ref.identifier;\n                        const parent = node.parent;\n\n                        if (parent && parent.type === \"NewExpression\" && parent.callee === node) {\n                            context.report({\n                                node,\n                                messageId: \"noNewSymbol\"\n                            });\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when using constructor for wrapper objects\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with the `String`, `Number`, and `Boolean` objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-wrappers\"\n        },\n\n        schema: [],\n\n        messages: {\n            noConstructor: \"Do not use {{fn}} as a constructor.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                const wrapperObjects = [\"String\", \"Number\", \"Boolean\"];\n\n                if (wrapperObjects.indexOf(node.callee.name) > -1) {\n                    context.report({\n                        node,\n                        messageId: \"noConstructor\",\n                        data: { fn: node.callee.name }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag statements with function invocation preceded by\n * \"new\" and not part of assignment\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators outside of assignments or comparisons\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new\"\n        },\n\n        schema: [],\n\n        messages: {\n            noNewStatement: \"Do not use 'new' for side effects.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            \"ExpressionStatement > NewExpression\"(node) {\n                context.report({\n                    node: node.parent,\n                    messageId: \"noNewStatement\"\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow `\\8` and `\\9` escape sequences in string literals.\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst QUICK_TEST_REGEX = /\\\\[89]/u;\n\n/**\n * Returns unicode escape sequence that represents the given character.\n * @param {string} character A single code unit.\n * @returns {string} \"\\uXXXX\" sequence.\n */\nfunction getUnicodeEscape(character) {\n    return `\\\\u${character.charCodeAt(0).toString(16).padStart(4, \"0\")}`;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `\\\\8` and `\\\\9` escape sequences in string literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-nonoctal-decimal-escape\",\n            suggestion: true\n        },\n\n        schema: [],\n\n        messages: {\n            decimalEscape: \"Don't use '{{decimalEscape}}' escape sequence.\",\n\n            // suggestions\n            refactor: \"Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.\",\n            escapeBackslash: \"Replace '{{original}}' with '{{replacement}}' to include the actual backslash character.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Creates a new Suggestion object.\n         * @param {string} messageId \"refactor\" or \"escapeBackslash\".\n         * @param {int[]} range The range to replace.\n         * @param {string} replacement New text for the range.\n         * @returns {Object} Suggestion\n         */\n        function createSuggestion(messageId, range, replacement) {\n            return {\n                messageId,\n                data: {\n                    original: sourceCode.getText().slice(...range),\n                    replacement\n                },\n                fix(fixer) {\n                    return fixer.replaceTextRange(range, replacement);\n                }\n            };\n        }\n\n        return {\n            Literal(node) {\n                if (typeof node.value !== \"string\") {\n                    return;\n                }\n\n                if (!QUICK_TEST_REGEX.test(node.raw)) {\n                    return;\n                }\n\n                const regex = /(?:[^\\\\]|(?<previousEscape>\\\\.))*?(?<decimalEscape>\\\\[89])/suy;\n                let match;\n\n                while ((match = regex.exec(node.raw))) {\n                    const { previousEscape, decimalEscape } = match.groups;\n                    const decimalEscapeRangeEnd = node.range[0] + match.index + match[0].length;\n                    const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;\n                    const decimalEscapeRange = [decimalEscapeRangeStart, decimalEscapeRangeEnd];\n                    const suggest = [];\n\n                    // When `regex` is matched, `previousEscape` can only capture characters adjacent to `decimalEscape`\n                    if (previousEscape === \"\\\\0\") {\n\n                        /*\n                         * Now we have a NULL escape \"\\0\" immediately followed by a decimal escape, e.g.: \"\\0\\8\".\n                         * Fixing this to \"\\08\" would turn \"\\0\" into a legacy octal escape. To avoid producing\n                         * an octal escape while fixing a decimal escape, we provide different suggestions.\n                         */\n                        suggest.push(\n                            createSuggestion( // \"\\0\\8\" -> \"\\u00008\"\n                                \"refactor\",\n                                [decimalEscapeRangeStart - previousEscape.length, decimalEscapeRangeEnd],\n                                `${getUnicodeEscape(\"\\0\")}${decimalEscape[1]}`\n                            ),\n                            createSuggestion( // \"\\8\" -> \"\\u0038\"\n                                \"refactor\",\n                                decimalEscapeRange,\n                                getUnicodeEscape(decimalEscape[1])\n                            )\n                        );\n                    } else {\n                        suggest.push(\n                            createSuggestion( // \"\\8\" -> \"8\"\n                                \"refactor\",\n                                decimalEscapeRange,\n                                decimalEscape[1]\n                            )\n                        );\n                    }\n\n                    suggest.push(\n                        createSuggestion( // \"\\8\" -> \"\\\\8\"\n                            \"escapeBackslash\",\n                            decimalEscapeRange,\n                            `\\\\${decimalEscape}`\n                        )\n                    );\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: sourceCode.getLocFromIndex(decimalEscapeRangeStart),\n                            end: sourceCode.getLocFromIndex(decimalEscapeRangeEnd)\n                        },\n                        messageId: \"decimalEscape\",\n                        data: {\n                            decimalEscape\n                        },\n                        suggest\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { CALL, CONSTRUCT, ReferenceTracker } = require(\"eslint-utils\");\nconst getPropertyName = require(\"./utils/ast-utils\").getStaticPropertyName;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst nonCallableGlobals = [\"Atomics\", \"JSON\", \"Math\", \"Reflect\"];\n\n/**\n * Returns the name of the node to report\n * @param {ASTNode} node A node to report\n * @returns {string} name to report\n */\nfunction getReportNodeName(node) {\n    if (node.type === \"ChainExpression\") {\n        return getReportNodeName(node.expression);\n    }\n    if (node.type === \"MemberExpression\") {\n        return getPropertyName(node);\n    }\n    return node.name;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow calling global object properties as functions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-obj-calls\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedCall: \"'{{name}}' is not a function.\",\n            unexpectedRefCall: \"'{{name}}' is reference to '{{ref}}', which is not a function.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {};\n\n                for (const g of nonCallableGlobals) {\n                    traceMap[g] = {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    };\n                }\n\n                for (const { node, path } of tracker.iterateGlobalReferences(traceMap)) {\n                    const name = getReportNodeName(node.callee);\n                    const ref = path[0];\n                    const messageId = name === ref ? \"unexpectedCall\" : \"unexpectedRefCall\";\n\n                    context.report({ node, messageId, data: { name, ref } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag octal escape sequences in string literals.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow octal escape sequences in string literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-octal-escape\"\n        },\n\n        schema: [],\n\n        messages: {\n            octalEscapeSequence: \"Don't use octal: '\\\\{{sequence}}'. Use '\\\\u....' instead.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value !== \"string\") {\n                    return;\n                }\n\n                // \\0 represents a valid NULL character if it isn't followed by a digit.\n                const match = node.raw.match(\n                    /^(?:[^\\\\]|\\\\.)*?\\\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su\n                );\n\n                if (match) {\n                    context.report({\n                        node,\n                        messageId: \"octalEscapeSequence\",\n                        data: { sequence: match[1] }\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when initializing octal literal\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow octal literals\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-octal\"\n        },\n\n        schema: [],\n\n        messages: {\n            noOcatal: \"Octal literals should not be used.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value === \"number\" && /^0[0-9]/u.test(node.raw)) {\n                    context.report({\n                        node,\n                        messageId: \"noOcatal\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            },\n                            ignorePropertyModificationsForRegex: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n            assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && (!stopNodePattern.test(parent.type) ||\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // e.g. for (foo.a in b) {}\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n                        if (parent.left === node) {\n                            return true;\n                        }\n\n                        // this is a stop node for parent.right and parent.body\n                        return false;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Tests that an identifier name matches any of the ignored property assignments.\n         * First we test strings in ignoredPropertyAssignmentsFor.\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n         * @param {string} identifierName A string that describes the name of an identifier to\n         * ignore property assignments for.\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n         */\n        function isIgnoredPropertyAssignment(identifierName) {\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParam\",\n                        data: { name: identifier.name }\n                    });\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParamProp\",\n                        data: { name: identifier.name }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow string concatenation when using __dirname and __filename\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow string concatenation with `__dirname` and `__filename`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-path-concat\"\n        },\n\n        schema: [],\n\n        messages: {\n            usePathFunctions: \"Use path.join() or path.resolve() instead of + to create paths.\"\n        }\n    },\n\n    create(context) {\n\n        const MATCHER = /^__(?:dir|file)name$/u;\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            BinaryExpression(node) {\n\n                const left = node.left,\n                    right = node.right;\n\n                if (node.operator === \"+\" &&\n                        ((left.type === \"Identifier\" && MATCHER.test(left.name)) ||\n                        (right.type === \"Identifier\" && MATCHER.test(right.name)))\n                ) {\n\n                    context.report({\n                        node,\n                        messageId: \"usePathFunctions\"\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of unary increment and decrement operators.\n * @author Ian Christian Myers\n * @author Brody McKee (github.com/mrmckeb)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is the update node of a `ForStatement`.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is `ForStatement` update.\n */\nfunction isForStatementUpdate(node) {\n    const parent = node.parent;\n\n    return parent.type === \"ForStatement\" && parent.update === node;\n}\n\n/**\n * Determines whether the given node is considered to be a for loop \"afterthought\" by the logic of this rule.\n * In particular, it returns `true` if the given node is either:\n *   - The update node of a `ForStatement`: for (;; i++) {}\n *   - An operand of a sequence expression that is the update node: for (;; foo(), i++) {}\n *   - An operand of a sequence expression that is child of another sequence expression, etc.,\n *     up to the sequence expression that is the update node: for (;; foo(), (bar(), (baz(), i++))) {}\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a for loop afterthought.\n */\nfunction isForLoopAfterthought(node) {\n    const parent = node.parent;\n\n    if (parent.type === \"SequenceExpression\") {\n        return isForLoopAfterthought(parent);\n    }\n\n    return isForStatementUpdate(node);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the unary operators `++` and `--`\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-plusplus\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowForLoopAfterthoughts: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedUnaryOp: \"Unary operator '{{operator}}' used.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n        let allowForLoopAfterthoughts = false;\n\n        if (typeof config === \"object\") {\n            allowForLoopAfterthoughts = config.allowForLoopAfterthoughts === true;\n        }\n\n        return {\n\n            UpdateExpression(node) {\n                if (allowForLoopAfterthoughts && isForLoopAfterthought(node)) {\n                    return;\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnaryOp\",\n                    data: {\n                        operator: node.operator\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow the use of process.env()\n * @author Vignesh Anand\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `process.env`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-process-env\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedProcessEnv: \"Unexpected use of process.env.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"process\" && !node.computed && propertyName && propertyName === \"env\") {\n                    context.report({ node, messageId: \"unexpectedProcessEnv\" });\n                }\n\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow the use of process.exit()\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `process.exit()`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-process-exit\"\n        },\n\n        schema: [],\n\n        messages: {\n            noProcessExit: \"Don't use process.exit(); throw an error instead.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']\"(node) {\n                context.report({ node: node.parent, messageId: \"noProcessExit\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow returning values from Promise executor functions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst functionTypesToCheck = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\n\n/**\n * Determines whether the given identifier node is a reference to a global variable.\n * @param {ASTNode} node `Identifier` node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} True if the identifier is a reference to a global variable.\n */\nfunction isGlobalReference(node, scope) {\n    const variable = findVariable(scope, node);\n\n    return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\n/**\n * Finds function's outer scope.\n * @param {Scope} scope Function's own scope.\n * @returns {Scope} Function's outer scope.\n */\nfunction getOuterScope(scope) {\n    const upper = scope.upper;\n\n    if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n    }\n    return upper;\n}\n\n/**\n * Determines whether the given function node is used as a Promise executor.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Function's own scope.\n * @returns {boolean} `true` if the node is a Promise executor.\n */\nfunction isPromiseExecutor(node, scope) {\n    const parent = node.parent;\n\n    return parent.type === \"NewExpression\" &&\n        parent.arguments[0] === node &&\n        parent.callee.type === \"Identifier\" &&\n        parent.callee.name === \"Promise\" &&\n        isGlobalReference(parent.callee, getOuterScope(scope));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow returning values from Promise executor functions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-promise-executor-return\"\n        },\n\n        schema: [],\n\n        messages: {\n            returnsValue: \"Return values from promise executor functions cannot be read.\"\n        }\n    },\n\n    create(context) {\n\n        let funcInfo = null;\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node Node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, messageId: \"returnsValue\" });\n        }\n\n        return {\n\n            onCodePathStart(_, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, context.getScope())\n                };\n\n                if (funcInfo.shouldCheck && node.type === \"ArrowFunctionExpression\" && node.expression) {\n                    report(node.body);\n                }\n            },\n\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck && node.argument) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag usage of __proto__ property\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getStaticPropertyName } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of the `__proto__` property\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-proto\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedProto: \"The '__proto__' property is deprecated.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                if (getStaticPropertyName(node) === \"__proto__\") {\n                    context.report({ node, messageId: \"unexpectedProto\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of Object.prototype builtins on objects\n * @author Andrew Levine\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow calling some `Object.prototype` methods directly on objects\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-prototype-builtins\"\n        },\n\n        schema: [],\n\n        messages: {\n            prototypeBuildIn: \"Do not access Object.prototype method '{{prop}}' from target object.\"\n        }\n    },\n\n    create(context) {\n        const DISALLOWED_PROPS = [\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\"\n        ];\n\n        /**\n         * Reports if a disallowed property is used in a CallExpression\n         * @param {ASTNode} node The CallExpression node.\n         * @returns {void}\n         */\n        function disallowBuiltIns(node) {\n\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type !== \"MemberExpression\") {\n                return;\n            }\n\n            const propName = astUtils.getStaticPropertyName(callee);\n\n            if (propName !== null && DISALLOWED_PROPS.indexOf(propName) > -1) {\n                context.report({\n                    messageId: \"prototypeBuildIn\",\n                    loc: callee.property.loc,\n                    data: { prop: propName },\n                    node\n                });\n            }\n        }\n\n        return {\n            CallExpression: disallowBuiltIns\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when the same variable is declared more then once.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable redeclaration\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-redeclare\"\n        },\n\n        messages: {\n            redeclared: \"'{{id}}' is already defined.\",\n            redeclaredAsBuiltin: \"'{{id}}' is already defined as a built-in global variable.\",\n            redeclaredBySyntax: \"'{{id}}' is already defined by a variable declaration.\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: true }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {\n            builtinGlobals: Boolean(\n                context.options.length === 0 ||\n                context.options[0].builtinGlobals\n            )\n        };\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Iterate declarations of a given variable.\n         * @param {escope.variable} variable The variable object to iterate declarations.\n         * @returns {IterableIterator<{type:string,node:ASTNode,loc:SourceLocation}>} The declarations.\n         */\n        function *iterateDeclarations(variable) {\n            if (options.builtinGlobals && (\n                variable.eslintImplicitGlobalSetting === \"readonly\" ||\n                variable.eslintImplicitGlobalSetting === \"writable\"\n            )) {\n                yield { type: \"builtin\" };\n            }\n\n            for (const id of variable.identifiers) {\n                yield { type: \"syntax\", node: id, loc: id.loc };\n            }\n\n            if (variable.eslintExplicitGlobalComments) {\n                for (const comment of variable.eslintExplicitGlobalComments) {\n                    yield {\n                        type: \"comment\",\n                        node: comment,\n                        loc: astUtils.getNameLocationInGlobalDirectiveComment(\n                            sourceCode,\n                            comment,\n                            variable.name\n                        )\n                    };\n                }\n            }\n        }\n\n        /**\n         * Find variables in a given scope and flag redeclared ones.\n         * @param {Scope} scope An eslint-scope scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            for (const variable of scope.variables) {\n                const [\n                    declaration,\n                    ...extraDeclarations\n                ] = iterateDeclarations(variable);\n\n                if (extraDeclarations.length === 0) {\n                    continue;\n                }\n\n                /*\n                 * If the type of a declaration is different from the type of\n                 * the first declaration, it shows the location of the first\n                 * declaration.\n                 */\n                const detailMessageId = declaration.type === \"builtin\"\n                    ? \"redeclaredAsBuiltin\"\n                    : \"redeclaredBySyntax\";\n                const data = { id: variable.name };\n\n                // Report extra declarations.\n                for (const { type, node, loc } of extraDeclarations) {\n                    const messageId = type === declaration.type\n                        ? \"redeclared\"\n                        : detailMessageId;\n\n                    context.report({ node, loc, messageId, data });\n                }\n            }\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @param {ASTNode} node The node of the current scope.\n         * @returns {void}\n         * @private\n         */\n        function checkForBlock(node) {\n            const scope = context.getScope();\n\n            /*\n             * In ES5, some node type such as `BlockStatement` doesn't have that scope.\n             * `scope.block` is a different node in such a case.\n             */\n            if (scope.block === node) {\n                findVariablesInScope(scope);\n            }\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                findVariablesInScope(scope);\n\n                // Node.js or ES modules has a special scope.\n                if (\n                    scope.type === \"global\" &&\n                    scope.childScopes[0] &&\n\n                    // The special scope's block is the Program node.\n                    scope.block === scope.childScopes[0].block\n                ) {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            },\n\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            ArrowFunctionExpression: checkForBlock,\n\n            BlockStatement: checkForBlock,\n            ForStatement: checkForBlock,\n            ForInStatement: checkForBlock,\n            ForOfStatement: checkForBlock,\n            SwitchStatement: checkForBlock\n        };\n    }\n};\n","/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst regexpp = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst regExpParser = new regexpp.RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n\n/**\n * Check if node is a string\n * @param {ASTNode} node node to evaluate\n * @returns {boolean} True if its a string\n * @private\n */\nfunction isString(node) {\n    return node && node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow multiple spaces in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-regex-spaces\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Validate regular expression\n         * @param {ASTNode} nodeToReport Node to report.\n         * @param {string} pattern Regular expression pattern to validate.\n         * @param {string} rawPattern Raw representation of the pattern in the source code.\n         * @param {number} rawPatternStartRange Start range of the pattern in the source code.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n\n            // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\n            if (!DOUBLE_SPACE.test(rawPattern)) {\n                return;\n            }\n\n            const characterClassNodes = [];\n            let regExpAST;\n\n            try {\n                regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(regExpAST, {\n                onCharacterClassEnter(ccNode) {\n                    characterClassNodes.push(ccNode);\n                }\n            });\n\n            const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\n            let match;\n\n            while ((match = spacesPattern.exec(pattern))) {\n                const { 1: { length }, index } = match;\n\n                // Report only consecutive spaces that are not in character classes.\n                if (\n                    characterClassNodes.every(({ start, end }) => index < start || end <= index)\n                ) {\n                    context.report({\n                        node: nodeToReport,\n                        messageId: \"multipleSpaces\",\n                        data: { length },\n                        fix(fixer) {\n                            if (pattern !== rawPattern) {\n                                return null;\n                            }\n                            return fixer.replaceTextRange(\n                                [rawPatternStartRange + index, rawPatternStartRange + index + length],\n                                ` {${length}}`\n                            );\n                        }\n                    });\n\n                    // Report only the first occurrence of consecutive spaces\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            if (node.regex) {\n                const pattern = node.regex.pattern;\n                const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n                const rawPatternStartRange = node.range[0] + 1;\n                const flags = node.regex.flags;\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = context.getScope();\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n            const patternNode = node.arguments[0];\n            const flagsNode = node.arguments[1];\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n                const pattern = patternNode.value;\n                const rawPattern = patternNode.raw.slice(1, -1);\n                const rawPatternStartRange = patternNode.range[0] + 1;\n                const flags = isString(flagsNode) ? flagsNode.value : \"\";\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow specified names in exports\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified names in exports\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-exports\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                restrictedNamedExports: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            restrictedNamed: \"'{{name}}' is restricted from being used as an exported name.\"\n        }\n    },\n\n    create(context) {\n\n        const restrictedNames = new Set(context.options[0] && context.options[0].restrictedNamedExports);\n\n        /**\n         * Checks and reports given exported identifier.\n         * @param {ASTNode} node exported `Identifier` node to check.\n         * @returns {void}\n         */\n        function checkExportedName(node) {\n            const name = node.name;\n\n            if (restrictedNames.has(name)) {\n                context.report({\n                    node,\n                    messageId: \"restrictedNamed\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ExportAllDeclaration(node) {\n                if (node.exported) {\n                    checkExportedName(node.exported);\n                }\n            },\n\n            ExportNamedDeclaration(node) {\n                const declaration = node.declaration;\n\n                if (declaration) {\n                    if (declaration.type === \"FunctionDeclaration\" || declaration.type === \"ClassDeclaration\") {\n                        checkExportedName(declaration.id);\n                    } else if (declaration.type === \"VariableDeclaration\") {\n                        context.getDeclaredVariables(declaration)\n                            .map(v => v.defs.find(d => d.parent === declaration))\n                            .map(d => d.name) // Identifier nodes\n                            .forEach(checkExportedName);\n                    }\n                } else {\n                    node.specifiers\n                        .map(s => s.exported)\n                        .forEach(checkExportedName);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified globals.\n * @author Benoît Zugmeyer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified global variables\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-globals\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            name: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"name\"],\n                        additionalProperties: false\n                    }\n                ]\n            },\n            uniqueItems: true,\n            minItems: 0\n        },\n\n        messages: {\n            defaultMessage: \"Unexpected use of '{{name}}'.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            customMessage: \"Unexpected use of '{{name}}'. {{customMessage}}\"\n        }\n    },\n\n    create(context) {\n\n        // If no globals are restricted, we don't need to do anything\n        if (context.options.length === 0) {\n            return {};\n        }\n\n        const restrictedGlobalMessages = context.options.reduce((memo, option) => {\n            if (typeof option === \"string\") {\n                memo[option] = null;\n            } else {\n                memo[option.name] = option.message;\n            }\n\n            return memo;\n        }, {});\n\n        /**\n         * Report a variable to be used as a restricted global.\n         * @param {Reference} reference the variable reference\n         * @returns {void}\n         * @private\n         */\n        function reportReference(reference) {\n            const name = reference.identifier.name,\n                customMessage = restrictedGlobalMessages[name],\n                messageId = customMessage\n                    ? \"customMessage\"\n                    : \"defaultMessage\";\n\n            context.report({\n                node: reference.identifier,\n                messageId,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted global name.\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted global or not\n         * @private\n         */\n        function isRestricted(name) {\n            return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                // Report variables declared elsewhere (ex: variables defined as \"global\" by eslint)\n                scope.variables.forEach(variable => {\n                    if (!variable.defs.length && isRestricted(variable.name)) {\n                        variable.references.forEach(reportReference);\n                    }\n                });\n\n                // Report variables not declared at all\n                scope.through.forEach(reference => {\n                    if (isRestricted(reference.identifier.name)) {\n                        reportReference(reference);\n                    }\n                });\n\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        const restrictedPatternsMatcher = ignore().add(restrictedPatterns);\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                return;\n            }\n\n            const customMessage = restrictedPathMessages[importSource].message;\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n            if (restrictedImportNames) {\n                if (importNames.has(\"*\")) {\n                    const specifierData = importNames.get(\"*\")[0];\n\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                        loc: specifierData.loc,\n                        data: {\n                            importSource,\n                            importNames: restrictedImportNames,\n                            customMessage\n                        }\n                    });\n                }\n\n                restrictedImportNames.forEach(importName => {\n                    if (importNames.has(importName)) {\n                        const specifiers = importNames.get(importName);\n\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n            }\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node) {\n            const importSource = node.source.value.trim();\n\n            context.report({\n                node,\n                messageId: \"patterns\",\n                data: {\n                    importSource\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource) {\n            return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = specifier.imported.name;\n                    } else if (specifier.local) {\n                        name = specifier.local.name;\n                    }\n\n                    if (name) {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n\n            if (isRestrictedPattern(importSource)) {\n                reportPathForPatterns(node);\n            }\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    },\n                    additionalItems: false\n                }\n            ]\n        },\n\n        messages: {\n            defaultMessage: \"'{{name}}' module is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n            patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n            if (typeof importName === \"string\") {\n                memo[importName] = null;\n            } else {\n                memo[importName.name] = importName.message;\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a static string template literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string template literal.\n         */\n        function isStaticTemplateLiteral(node) {\n            return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        /**\n         * Extract string from Literal or TemplateLiteral node\n         * @param {ASTNode} node The node to extract from\n         * @returns {string|null} Extracted string or null if node doesn't represent a string\n         */\n        function getFirstArgumentString(node) {\n            if (isStringLiteral(node)) {\n                return node.value.trim();\n            }\n\n            if (isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked.trim();\n            }\n\n            return null;\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @param {string} name restricted path\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node, name) {\n            const customMessage = restrictedPathMessages[name];\n            const messageId = customMessage\n                ? \"customMessage\"\n                : \"defaultMessage\";\n\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted path name\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(name) {\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments\n                    if (node.arguments.length) {\n                        const name = getFirstArgumentString(node.arguments[0]);\n\n                        // if first argument is a string literal or a static string template literal\n                        if (name) {\n\n                            // check if argument value is in restricted modules array\n                            if (isRestrictedPath(name)) {\n                                reportPath(node, name);\n                            }\n\n                            if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                                context.report({\n                                    node,\n                                    messageId: \"patternMessage\",\n                                    data: { name }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow certain object properties\n * @author Will Klein & Eli White\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow certain properties on certain objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-properties\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"object\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"property\"]\n                    }\n                ]\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            restrictedObjectProperty: \"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}\",\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            restrictedProperty: \"'{{propertyName}}' is restricted from being used.{{message}}\"\n        }\n    },\n\n    create(context) {\n        const restrictedCalls = context.options;\n\n        if (restrictedCalls.length === 0) {\n            return {};\n        }\n\n        const restrictedProperties = new Map();\n        const globallyRestrictedObjects = new Map();\n        const globallyRestrictedProperties = new Map();\n\n        restrictedCalls.forEach(option => {\n            const objectName = option.object;\n            const propertyName = option.property;\n\n            if (typeof objectName === \"undefined\") {\n                globallyRestrictedProperties.set(propertyName, { message: option.message });\n            } else if (typeof propertyName === \"undefined\") {\n                globallyRestrictedObjects.set(objectName, { message: option.message });\n            } else {\n                if (!restrictedProperties.has(objectName)) {\n                    restrictedProperties.set(objectName, new Map());\n                }\n\n                restrictedProperties.get(objectName).set(propertyName, {\n                    message: option.message\n                });\n            }\n        });\n\n        /**\n         * Checks to see whether a property access is restricted, and reports it if so.\n         * @param {ASTNode} node The node to report\n         * @param {string} objectName The name of the object\n         * @param {string} propertyName The name of the property\n         * @returns {undefined}\n         */\n        function checkPropertyAccess(node, objectName, propertyName) {\n            if (propertyName === null) {\n                return;\n            }\n            const matchedObject = restrictedProperties.get(objectName);\n            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);\n            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);\n\n            if (matchedObjectProperty) {\n                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    messageId: \"restrictedObjectProperty\",\n                    data: {\n                        objectName,\n                        propertyName,\n                        message\n                    }\n                });\n            } else if (globalMatchedProperty) {\n                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    messageId: \"restrictedProperty\",\n                    data: {\n                        propertyName,\n                        message\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`\n         * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node\n         * @returns {undefined}\n         */\n        function checkDestructuringAssignment(node) {\n            if (node.right.type === \"Identifier\") {\n                const objectName = node.right.name;\n\n                if (node.left.type === \"ObjectPattern\") {\n                    node.left.properties.forEach(property => {\n                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));\n                    });\n                }\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));\n            },\n            VariableDeclarator(node) {\n                if (node.init && node.init.type === \"Identifier\") {\n                    const objectName = node.init.name;\n\n                    if (node.id.type === \"ObjectPattern\") {\n                        node.id.properties.forEach(property => {\n                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));\n                        });\n                    }\n                }\n            },\n            AssignmentExpression: checkDestructuringAssignment,\n            AssignmentPattern: checkDestructuringAssignment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of certain node types\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified syntax\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-syntax\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            selector: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"selector\"],\n                        additionalProperties: false\n                    }\n                ]\n            },\n            uniqueItems: true,\n            minItems: 0\n        },\n\n        messages: {\n            // eslint-disable-next-line eslint-plugin/report-message-format\n            restrictedSyntax: \"{{message}}\"\n        }\n    },\n\n    create(context) {\n        return context.options.reduce((result, selectorOrObject) => {\n            const isStringFormat = (typeof selectorOrObject === \"string\");\n            const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);\n\n            const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;\n            const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;\n\n            return Object.assign(result, {\n                [selector](node) {\n                    context.report({\n                        node,\n                        messageId: \"restrictedSyntax\",\n                        data: { message }\n                    });\n                }\n            });\n        }, {});\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when return statement contains assignment\n * @author Ilya Volodin\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignment operators in `return` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-return-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            returnAssignment: \"Return statement should not contain assignment.\",\n            arrowAssignment: \"Arrow function should not return assignment.\"\n        }\n    },\n\n    create(context) {\n        const always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n        const sourceCode = context.getSourceCode();\n\n        return {\n            AssignmentExpression(node) {\n                if (!always && astUtils.isParenthesised(sourceCode, node)) {\n                    return;\n                }\n\n                let currentChild = node;\n                let parent = currentChild.parent;\n\n                // Find ReturnStatement or ArrowFunctionExpression in ancestors.\n                while (parent && !SENTINEL_TYPE.test(parent.type)) {\n                    currentChild = parent;\n                    parent = parent.parent;\n                }\n\n                // Reports.\n                if (parent && parent.type === \"ReturnStatement\") {\n                    context.report({\n                        node: parent,\n                        messageId: \"returnAssignment\"\n                    });\n                } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === currentChild) {\n                    context.report({\n                        node: parent,\n                        messageId: \"arrowAssignment\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary `return await`\",\n            category: \"Best Practices\",\n\n            recommended: false,\n\n            url: \"https://eslint.org/docs/rules/no-return-await\"\n        },\n\n        fixable: null,\n\n        schema: [\n        ],\n\n        messages: {\n            redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.getSourceCode().getFirstToken(node),\n                loc: node.loc,\n                messageId: \"redundantUseOfAwait\"\n            });\n        }\n\n        /**\n         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n         * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n         * a `catch` block will only have an error handler if there is also a `finally` block.\n         * @param {ASTNode} node A node representing a location where an could be thrown\n         * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n         */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when using javascript: urls\n * @author Ilya Volodin\n */\n/* jshint scripturl: true */\n/* eslint no-script-url: 0 */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `javascript:` urls\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-script-url\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedScriptURL: \"Script URL is a form of eval.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Check whether a node's static value starts with \"javascript:\" or not.\n         * And report an error for unexpected script URL.\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function check(node) {\n            const value = astUtils.getStaticStringValue(node);\n\n            if (typeof value === \"string\" && value.toLowerCase().indexOf(\"javascript:\") === 0) {\n                context.report({ node, messageId: \"unexpectedScriptURL\" });\n            }\n        }\n        return {\n            Literal(node) {\n                if (node.value && typeof node.value === \"string\") {\n                    check(node);\n                }\n            },\n            TemplateLiteral(node) {\n                if (!(node.parent && node.parent.type === \"TaggedTemplateExpression\")) {\n                    check(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/gu;\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const leftElement = left.elements[i];\n            const rightElement = right.elements[i];\n\n            // Avoid cases such as [...a] = [...a, 1]\n            if (\n                leftElement &&\n                leftElement.type === \"RestElement\" &&\n                i < right.elements.length - 1\n            ) {\n                break;\n            }\n\n            eachSelfAssignment(leftElement, rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        /*\n         * Gets the index of the last spread property.\n         * It's possible to overwrite properties followed by it.\n         */\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            const propType = right.properties[i].type;\n\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        right.kind === \"init\" &&\n        !right.method\n    ) {\n        const leftName = astUtils.getStaticPropertyName(left);\n\n        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n            eachSelfAssignment(left.value, right.value, props, report);\n        }\n    } else if (\n        props &&\n        astUtils.skipChainExpression(left).type === \"MemberExpression\" &&\n        astUtils.skipChainExpression(right).type === \"MemberExpression\" &&\n        astUtils.isSameReference(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-self-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            selfAssignment: \"'{{name}}' is assigned to itself.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const [{ props = true } = {}] = context.options;\n\n        /**\n         * Reports a given node as self assignments.\n         * @param {ASTNode} node A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"selfAssignment\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag comparison where left part is the same as the right\n * part.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow comparisons where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-self-compare\"\n        },\n\n        schema: [],\n\n        messages: {\n            comparingToSelf: \"Comparing to itself is potentially pointless.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether two nodes are composed of the same tokens.\n         * @param {ASTNode} nodeA The first node\n         * @param {ASTNode} nodeB The second node\n         * @returns {boolean} true if the nodes have identical token representations\n         */\n        function hasSameTokens(nodeA, nodeB) {\n            const tokensA = sourceCode.getTokens(nodeA);\n            const tokensB = sourceCode.getTokens(nodeB);\n\n            return tokensA.length === tokensB.length &&\n                tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);\n        }\n\n        return {\n\n            BinaryExpression(node) {\n                const operators = new Set([\"===\", \"==\", \"!==\", \"!=\", \">\", \"<\", \">=\", \"<=\"]);\n\n                if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {\n                    context.report({ node, messageId: \"comparingToSelf\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = {\n    allowInParentheses: true\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-sequences\"\n        },\n\n        schema: [{\n            properties: {\n                allowInParentheses: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            unexpectedCommaExpression: \"Unexpected use of comma operator.\"\n        }\n    },\n\n    create(context) {\n        const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        const parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            /*\n             * Omitting CallExpression - commas are parsed as argument separators\n             * Omitting NewExpression - commas are parsed as argument separators\n             * Omitting ForInStatement - parts aren't individually parenthesised\n             * Omitting ForStatement - parts aren't individually parenthesised\n             */\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (options.allowInParentheses) {\n                    if (requiresExtraParens(node)) {\n                        if (isParenthesisedTwice(node)) {\n                            return;\n                        }\n                    } else {\n                        if (isParenthesised(node)) {\n                            return;\n                        }\n                    }\n                }\n\n                const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\n\n                context.report({ node, loc: firstCommaToken.loc, messageId: \"unexpectedCommaExpression\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow returning values from setters\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given identifier node is a reference to a global variable.\n * @param {ASTNode} node `Identifier` node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} True if the identifier is a reference to a global variable.\n */\nfunction isGlobalReference(node, scope) {\n    const variable = findVariable(scope, node);\n\n    return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\n/**\n * Determines whether the given node is an argument of the specified global method call, at the given `index` position.\n * E.g., for given `index === 1`, this function checks for `objectName.methodName(foo, node)`, where objectName is a global variable.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @param {string} objectName Name of the global object.\n * @param {string} methodName Name of the method.\n * @param {number} index The given position.\n * @returns {boolean} `true` if the node is argument at the given position.\n */\nfunction isArgumentOfGlobalMethodCall(node, scope, objectName, methodName, index) {\n    const callNode = node.parent;\n\n    return callNode.type === \"CallExpression\" &&\n        callNode.arguments[index] === node &&\n        astUtils.isSpecificMemberAccess(callNode.callee, objectName, methodName) &&\n        isGlobalReference(astUtils.skipChainExpression(callNode.callee).object, scope);\n}\n\n/**\n * Determines whether the given node is used as a property descriptor.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node, scope) {\n    if (\n        isArgumentOfGlobalMethodCall(node, scope, \"Object\", \"defineProperty\", 2) ||\n        isArgumentOfGlobalMethodCall(node, scope, \"Reflect\", \"defineProperty\", 2)\n    ) {\n        return true;\n    }\n\n    const parent = node.parent;\n\n    if (\n        parent.type === \"Property\" &&\n        parent.value === node\n    ) {\n        const grandparent = parent.parent;\n\n        if (\n            grandparent.type === \"ObjectExpression\" &&\n            (\n                isArgumentOfGlobalMethodCall(grandparent, scope, \"Object\", \"create\", 1) ||\n                isArgumentOfGlobalMethodCall(grandparent, scope, \"Object\", \"defineProperties\", 1)\n            )\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Determines whether the given function node is used as a setter function.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} `true` if the node is a setter.\n */\nfunction isSetter(node, scope) {\n    const parent = node.parent;\n\n    if (\n        parent.kind === \"set\" &&\n        parent.value === node\n    ) {\n\n        // Setter in an object literal or in a class\n        return true;\n    }\n\n    if (\n        parent.type === \"Property\" &&\n        parent.value === node &&\n        astUtils.getStaticPropertyName(parent) === \"set\" &&\n        parent.parent.type === \"ObjectExpression\" &&\n        isPropertyDescriptor(parent.parent, scope)\n    ) {\n\n        // Setter in a property descriptor\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Finds function's outer scope.\n * @param {Scope} scope Function's own scope.\n * @returns {Scope} Function's outer scope.\n */\nfunction getOuterScope(scope) {\n    const upper = scope.upper;\n\n    if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n    }\n\n    return upper;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow returning values from setters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-setter-return\"\n        },\n\n        schema: [],\n\n        messages: {\n            returnsValue: \"Setter cannot return a value.\"\n        }\n    },\n\n    create(context) {\n        let funcInfo = null;\n\n        /**\n         * Creates and pushes to the stack a function info object for the given function node.\n         * @param {ASTNode} node The function node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const outerScope = getOuterScope(context.getScope());\n\n            funcInfo = {\n                upper: funcInfo,\n                isSetter: isSetter(node, outerScope)\n            };\n        }\n\n        /**\n         * Pops the current function info object from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node Node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, messageId: \"returnsValue\" });\n        }\n\n        return {\n\n            /*\n             * Function declarations cannot be setters, but we still have to track them in the `funcInfo` stack to avoid\n             * false positives, because a ReturnStatement node can belong to a function declaration inside a setter.\n             *\n             * Note: A previously declared function can be referenced and actually used as a setter in a property descriptor,\n             * but that's out of scope for this rule.\n             */\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression(node) {\n                enterFunction(node);\n\n                if (funcInfo.isSetter && node.expression) {\n\n                    // { set: foo => bar } property descriptor. Report implicit return 'bar' as the equivalent for a return statement.\n                    report(node.body);\n                }\n            },\n\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            \"ArrowFunctionExpression:exit\": exitFunction,\n\n            ReturnStatement(node) {\n\n                // Global returns (e.g., at the top level of a Node module) don't have `funcInfo`.\n                if (funcInfo && funcInfo.isSetter && node.argument) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)\n * @author Michael Ficarra\n */\n\"use strict\";\n\n/**\n * Determines if a variable safely shadows undefined.\n * This is the case when a variable named `undefined` is never assigned to a value (i.e. it always shares the same value\n * as the global).\n * @param {eslintScope.Variable} variable The variable to check\n * @returns {boolean} true if this variable safely shadows `undefined`\n */\nfunction safelyShadowsUndefined(variable) {\n    return variable.name === \"undefined\" &&\n        variable.references.every(ref => !ref.isWrite()) &&\n        variable.defs.every(def => def.node.type === \"VariableDeclarator\" && def.node.init === null);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow identifiers from shadowing restricted names\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-shadow-restricted-names\"\n        },\n\n        schema: [],\n\n        messages: {\n            shadowingRestrictedName: \"Shadowing of global property '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n\n\n        const RESTRICTED = new Set([\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"]);\n\n        return {\n            \"VariableDeclaration, :function, CatchClause\"(node) {\n                for (const variable of context.getDeclaredVariables(node)) {\n                    if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {\n                        context.report({\n                            node: variable.defs[0].name,\n                            messageId: \"shadowingRestrictedName\",\n                            data: {\n                                name: variable.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-shadow\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: false },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"], default: \"functions\" },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n            noShadowGlobal: \"'{{name}}' is already a global variable.\"\n        }\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || []\n        };\n\n        /**\n         * Check if variable name is allowed.\n         * @param  {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.indexOf(variable.name) !== -1;\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Get declared line and column of a variable.\n         * @param {eslint-scope.Variable} variable The variable to get.\n         * @returns {Object} The declared line and column of the variable.\n         */\n        function getDeclaredLocation(variable) {\n            const identifier = variable.identifiers[0];\n            let obj;\n\n            if (identifier) {\n                obj = {\n                    global: false,\n                    line: identifier.loc.start.line,\n                    column: identifier.loc.start.column + 1\n                };\n            } else {\n                obj = {\n                    global: true\n                };\n            }\n            return obj;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                outer &&\n                inner[1] < outer[0] &&\n\n                // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                    isDuplicatedClassNameVariable(variable) ||\n                    isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    const location = getDeclaredLocation(shadowed);\n                    const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n                    const data = { name: variable.name };\n\n                    if (!location.global) {\n                        data.shadowedLine = location.line;\n                        data.shadowedColumn = location.column;\n                    }\n                    context.report({\n                        node: variable.identifiers[0],\n                        messageId,\n                        data\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check that spaced function application\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow spacing between function identifiers and their applications (deprecated)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-spaced-func\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"func-call-spacing\"],\n\n        fixable: \"whitespace\",\n        schema: [],\n\n        messages: {\n            noSpacedFunction: \"Unexpected space between function name and paren.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function detectOpenSpaces(node) {\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            let prevToken = lastCalleeToken,\n                parenToken = sourceCode.getTokenAfter(lastCalleeToken);\n\n            // advances to an open parenthesis.\n            while (\n                parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                parenToken.value !== \"(\"\n            ) {\n                prevToken = parenToken;\n                parenToken = sourceCode.getTokenAfter(parenToken);\n            }\n\n            // look for a space between the callee and the open paren\n            if (parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)\n            ) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    messageId: \"noSpacedFunction\",\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: detectOpenSpaces,\n            NewExpression: detectOpenSpaces\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow sparse arrays\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow sparse arrays\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-sparse-arrays\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedSparseArray: \"Unexpected comma in middle of array.\"\n        }\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            ArrayExpression(node) {\n\n                const emptySpot = node.elements.indexOf(null) > -1;\n\n                if (emptySpot) {\n                    context.report({ node, messageId: \"unexpectedSparseArray\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for properties whose identifier ends with the string Sync\n * @author Matt DuVall<http://mattduvall.com/>\n */\n\n/* jshint node:true */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        deprecated: true,\n\n        replacedBy: [],\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow synchronous methods\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-sync\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAtRootLevel: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noSync: \"Unexpected sync method: '{{propertyName}}'.\"\n        }\n    },\n\n    create(context) {\n        const selector = context.options[0] && context.options[0].allowAtRootLevel\n            ? \":function MemberExpression[property.name=/.*Sync$/]\"\n            : \"MemberExpression[property.name=/.*Sync$/]\";\n\n        return {\n            [selector](node) {\n                context.report({\n                    node,\n                    messageId: \"noSync\",\n                    data: {\n                        propertyName: node.property.name\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for tabs inside a file\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst tabRegex = /\\t+/gu;\nconst anyNonWhitespaceRegex = /\\S/u;\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow all tabs\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-tabs\"\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowIndentationTabs: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            unexpectedTab: \"Unexpected tab character.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;\n\n        return {\n            Program(node) {\n                sourceCode.getLines().forEach((line, index) => {\n                    let match;\n\n                    while ((match = tabRegex.exec(line)) !== null) {\n                        if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {\n                            continue;\n                        }\n\n                        context.report({\n                            node,\n                            loc: {\n                                start: {\n                                    line: index + 1,\n                                    column: match.index\n                                },\n                                end: {\n                                    line: index + 1,\n                                    column: match.index + match[0].length\n                                }\n                            },\n                            messageId: \"unexpectedTab\"\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Warn when using template string syntax in regular strings\n * @author Jeroen Engels\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow template literal placeholder syntax in regular strings\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-template-curly-in-string\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedTemplateExpression: \"Unexpected template string expression.\"\n        }\n    },\n\n    create(context) {\n        const regex = /\\$\\{[^}]+\\}/u;\n\n        return {\n            Literal(node) {\n                if (typeof node.value === \"string\" && regex.test(node.value)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedTemplateExpression\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of ternary operators.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-ternary\"\n        },\n\n        schema: [],\n\n        messages: {\n            noTernaryOperator: \"Ternary operator used.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            ConditionalExpression(node) {\n                context.report({ node, messageId: \"noTernaryOperator\" });\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-this-before-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass() &&\n                !funcInfo.codePath.currentSegments.every(isCalled)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this traverses all segments of this code path then reports every\n             * invalid node.\n             * @param {CodePath} codePath A code path which was ended.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\n                        const invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            messageId: \"noBeforeSuper\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to restrict what can be thrown as an exception.\n * @author Dieter Oberkofler\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow throwing literals as exceptions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-throw-literal\"\n        },\n\n        schema: [],\n\n        messages: {\n            object: \"Expected an error object to be thrown.\",\n            undef: \"Do not throw undefined.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            ThrowStatement(node) {\n                if (!astUtils.couldBeError(node.argument)) {\n                    context.report({ node, messageId: \"object\" });\n                } else if (node.argument.type === \"Identifier\") {\n                    if (node.argument.name === \"undefined\") {\n                        context.report({ node, messageId: \"undef\" });\n                    }\n                }\n\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            trailingSpace: \"Trailing spaces not allowed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                messageId: \"trailingSpace\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                const endLine = comment.type === \"Block\"\n                    ? comment.loc.end.line - 1\n                    : comment.loc.end.line;\n\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const lineNumber = i + 1;\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    const matches = re.exec(lines[i]);\n\n                    if (matches) {\n                        const location = {\n                            start: {\n                                line: lineNumber,\n                                column: matches.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: lineLength - linebreakLength\n                            }\n                        };\n\n                        const rangeStart = totalLength + location.start.column;\n                        const rangeEnd = totalLength + location.end.column;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when initializing to undefined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow initializing variables to `undefined`\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undef-init\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryUndefinedInit: \"It's not necessary to initialize '{{name}}' to undefined.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            VariableDeclarator(node) {\n                const name = sourceCode.getText(node.id),\n                    init = node.init && node.init.name,\n                    scope = context.getScope(),\n                    undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n                    shadowed = undefinedVar && undefinedVar.defs.length > 0,\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryUndefinedInit\",\n                        data: { name },\n                        fix(fixer) {\n                            if (node.parent.kind === \"var\") {\n                                return null;\n                            }\n\n                            if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n\n                                // Don't fix destructuring assignment to `undefined`.\n                                return null;\n                            }\n\n                            if (sourceCode.commentsExistBetween(node.id, lastToken)) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([node.id.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag references to undeclared variables.\n * @author Mark Macdonald\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given node is the argument of a typeof operator.\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean} Whether or not the node is the argument of a typeof operator.\n */\nfunction hasTypeOfOperator(node) {\n    const parent = node.parent;\n\n    return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of undeclared variables unless mentioned in `/*global */` comments\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-undef\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    typeof: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            undef: \"'{{name}}' is not defined.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const considerTypeOf = options && options.typeof === true || false;\n\n        return {\n            \"Program:exit\"(/* node */) {\n                const globalScope = context.getScope();\n\n                globalScope.through.forEach(ref => {\n                    const identifier = ref.identifier;\n\n                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {\n                        return;\n                    }\n\n                    context.report({\n                        node: identifier,\n                        messageId: \"undef\",\n                        data: identifier\n                    });\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `undefined` as an identifier\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undefined\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedUndefined: \"Unexpected use of undefined.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Report an invalid \"undefined\" identifier node.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"unexpectedUndefined\"\n            });\n        }\n\n        /**\n         * Checks the given scope for references to `undefined` and reports\n         * all references found.\n         * @param {eslint-scope.Scope} scope The scope to check.\n         * @returns {void}\n         */\n        function checkScope(scope) {\n            const undefinedVar = scope.set.get(\"undefined\");\n\n            if (!undefinedVar) {\n                return;\n            }\n\n            const references = undefinedVar.references;\n\n            const defs = undefinedVar.defs;\n\n            // Report non-initializing references (those are covered in defs below)\n            references\n                .filter(ref => !ref.init)\n                .forEach(ref => report(ref.identifier));\n\n            defs.forEach(def => report(def.name));\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                const stack = [globalScope];\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkScope(scope);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag dangling underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow dangling underscores in identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-underscore-dangle\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowAfterThisConstructor: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceInMethodNames: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowFunctionParams: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n        const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\n        const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n        const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return ALLOWED_VARIABLES.some(ident => ident === identifier);\n        }\n\n        /**\n         * Check if identifier has a dangling underscore\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasDanglingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if a node is a member reference of this.constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} true if it is a reference on this.constructor\n         * @private\n         */\n        function isThisConstructorReference(node) {\n            return node.object.type === \"MemberExpression\" &&\n                node.object.property.name === \"constructor\" &&\n                node.object.object.type === \"ThisExpression\";\n        }\n\n        /**\n         * Check if function parameter has a dangling underscore.\n         * @param {ASTNode} node function node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunctionParameters(node) {\n            if (!allowFunctionParams) {\n                node.params.forEach(param => {\n                    const { type } = param;\n                    let nodeToCheck;\n\n                    if (type === \"RestElement\") {\n                        nodeToCheck = param.argument;\n                    } else if (type === \"AssignmentPattern\") {\n                        nodeToCheck = param.left;\n                    } else {\n                        nodeToCheck = param;\n                    }\n\n                    if (nodeToCheck.type === \"Identifier\") {\n                        const identifier = nodeToCheck.name;\n\n                        if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                            context.report({\n                                node: param,\n                                messageId: \"unexpectedUnderscore\",\n                                data: {\n                                    identifier\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if function has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunction(node) {\n            if (node.type === \"FunctionDeclaration\" && node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedUnderscore\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n            checkForDanglingUnderscoreInFunctionParameters(node);\n        }\n\n        /**\n         * Check if variable expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInVariableExpression(node) {\n            const identifier = node.id.name;\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if member expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\",\n                isMemberOfThisConstructor = isThisConstructorReference(node);\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !(isMemberOfThisConstructor && allowAfterThisConstructor) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if method declaration or method property has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMethod(node) {\n            const identifier = node.key.name;\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n            VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\n            MemberExpression: checkForDanglingUnderscoreInMemberExpression,\n            MethodDefinition: checkForDanglingUnderscoreInMethod,\n            Property: checkForDanglingUnderscoreInMethod,\n            FunctionExpression: checkForDanglingUnderscoreInFunction,\n            ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.\n * @author Glen Mailer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow confusing multiline expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unexpected-multiline\"\n        },\n\n        schema: [],\n        messages: {\n            function: \"Unexpected newline between function and ( of function call.\",\n            property: \"Unexpected newline between object and [ of property access.\",\n            taggedTemplate: \"Unexpected newline between template tag and template literal.\",\n            division: \"Unexpected newline between numerator and division operator.\"\n        }\n    },\n\n    create(context) {\n\n        const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check to see if there is a newline between the node and the following open bracket\n         * line's expression\n         * @param {ASTNode} node The node to check.\n         * @param {string} messageId The error messageId to use.\n         * @returns {void}\n         * @private\n         */\n        function checkForBreakAfter(node, messageId) {\n            const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);\n            const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);\n\n            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {\n                context.report({\n                    node,\n                    loc: openParen.loc,\n                    messageId\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            MemberExpression(node) {\n                if (!node.computed || node.optional) {\n                    return;\n                }\n                checkForBreakAfter(node.object, \"property\");\n            },\n\n            TaggedTemplateExpression(node) {\n                const { quasi } = node;\n\n                // handles common tags, parenthesized tags, and typescript's generic type arguments\n                const tokenBefore = sourceCode.getTokenBefore(quasi);\n\n                if (tokenBefore.loc.end.line !== quasi.loc.start.line) {\n                    context.report({\n                        node,\n                        loc: {\n                            start: quasi.loc.start,\n                            end: {\n                                line: quasi.loc.start.line,\n                                column: quasi.loc.start.column + 1\n                            }\n                        },\n                        messageId: \"taggedTemplate\"\n                    });\n                }\n            },\n\n            CallExpression(node) {\n                if (node.arguments.length === 0 || node.optional) {\n                    return;\n                }\n                checkForBreakAfter(node.callee, \"function\");\n            },\n\n            \"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left\"(node) {\n                const secondSlash = sourceCode.getTokenAfter(node, token => token.value === \"/\");\n                const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);\n\n                if (\n                    tokenAfterOperator.type === \"Identifier\" &&\n                    REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) &&\n                    secondSlash.range[1] === tokenAfterOperator.range[0]\n                ) {\n                    checkForBreakAfter(node.left, \"division\");\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../shared/traverser\"),\n    astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\n\n/**\n * @typedef {Object} LoopConditionInfo\n * @property {eslint-scope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {Function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        const def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n * @param {LoopConditionInfo} condition A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n * @param {LoopConditionInfo} condition A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n * @param {ASTNode} node A node to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    const or = node.range;\n    const ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n * @param {ASTNode} node A node to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nconst isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    let node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n * @param {LoopConditionInfo[]} conditions The loop conditions to be updated.\n * @param {eslint-scope.Reference[]} modifiers The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n\n    for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n            const modifier = modifiers[j];\n            let funcNode, funcVar;\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            const inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unmodified loop conditions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unmodified-loop-condition\"\n        },\n\n        schema: [],\n\n        messages: {\n            loopConditionNotModified: \"'{{name}}' is not modified in this loop.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         * @param {LoopConditionInfo} condition A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            const node = condition.reference.identifier;\n\n            context.report({\n                node,\n                messageId: \"loopConditionNotModified\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         * @param {LoopConditionInfo[]} conditions A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (let i = 0; i < conditions.length; ++i) {\n                const condition = conditions[i];\n\n                if (condition.group) {\n                    let group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         * @param {LoopConditionInfo[]} conditions A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Checks whether or not a given group node has any dynamic elements.\n         * @param {ASTNode} root A node to check.\n         *      This node is one of BinaryExpression or ConditionalExpression.\n         * @returns {boolean} `true` if the node is dynamic.\n         */\n        function hasDynamicExpressions(root) {\n            let retv = false;\n\n            Traverser.traverse(root, {\n                visitorKeys: sourceCode.visitorKeys,\n                enter(node) {\n                    if (DYNAMIC_PATTERN.test(node.type)) {\n                        retv = true;\n                        this.break();\n                    } else if (SKIP_PATTERN.test(node.type)) {\n                        this.skip();\n                    }\n                }\n            });\n\n            return retv;\n        }\n\n        /**\n         * Creates the loop condition information from a given reference.\n         * @param {eslint-scope.Reference} reference A reference to create.\n         * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n         */\n        function toLoopCondition(reference) {\n            if (reference.init) {\n                return null;\n            }\n\n            let group = null;\n            let child = reference.identifier;\n            let node = child.parent;\n\n            while (node) {\n                if (SENTINEL_PATTERN.test(node.type)) {\n                    if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                        // This reference is inside of a loop condition.\n                        return {\n                            reference,\n                            group,\n                            isInLoop: isInLoop[node.type].bind(null, node),\n                            modified: false\n                        };\n                    }\n\n                    // This reference is outside of a loop condition.\n                    break;\n                }\n\n                /*\n                 * If it's inside of a group, OK if either operand is modified.\n                 * So stores the group this reference belongs to.\n                 */\n                if (GROUP_PATTERN.test(node.type)) {\n\n                    // If this expression is dynamic, no need to check.\n                    if (hasDynamicExpressions(node)) {\n                        break;\n                    } else {\n                        group = node;\n                    }\n                }\n\n                child = node;\n                node = node.parent;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         * @param {eslint-scope.Variable} variable A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            const conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            const modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\"() {\n                const queue = [context.getScope()];\n\n                groupMap = new Map();\n\n                let scope;\n\n                while ((scope = queue.pop())) {\n                    queue.push(...scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n            unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalExpression\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalAssignment\",\n                        fix: fixer => {\n                            const shouldParenthesizeAlternate =\n                                (\n                                    astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE ||\n                                    astUtils.isCoalesceExpression(node.alternate)\n                                ) &&\n                                !astUtils.isParenthesised(sourceCode, node.alternate);\n                            const alternateText = shouldParenthesizeAlternate\n                                ? `(${sourceCode.getText(node.alternate)})`\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n    const parent = node.parent;\n\n    if (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n                return node === parent.test;\n            case \"DoWhileStatement\":\n                return node === parent.body;\n            case \"ForStatement\":\n                return node === (parent.update || parent.test || parent.body);\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                return node === parent.left;\n\n            // no default\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n    return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow loops with a body that allows only one iteration\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        enum: allLoopTypes\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\n        }\n    },\n\n    create(context) {\n        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n            loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n            loopSelector = loopTypesToCheck.join(\",\"),\n            loopsByTargetSegments = new Map(),\n            loopsToReport = new Set();\n\n        let currentCodePath = null;\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            [loopSelector](node) {\n\n                /**\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\n                 */\n                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n                    loopsToReport.add(node);\n                }\n            },\n\n            onCodePathSegmentStart(segment, node) {\n                if (isLoopingTarget(node)) {\n                    const loop = node.parent;\n\n                    loopsByTargetSegments.set(segment, loop);\n                }\n            },\n\n            onCodePathSegmentLoop(_, toSegment, node) {\n                const loop = loopsByTargetSegments.get(toSegment);\n\n                /**\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n                 * only if there is at least one loop event with the appropriate target (which has been already\n                 * determined in the `loopsByTargetSegments` map), raised from either:\n                 *\n                 * - the end of the loop's body (in which case `node === loop`)\n                 * - a `continue` statement\n                 *\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n                 */\n                if (node === loop || node.type === \"ContinueStatement\") {\n\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n                    loopsToReport.delete(loop);\n                }\n            },\n\n            \"Program:exit\"() {\n                loopsToReport.forEach(\n                    node => context.report({ node, messageId: \"invalid\" })\n                );\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: [],\n\n        messages: {\n            unreachableCode: \"Unreachable code.\"\n        }\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    messageId: \"unreachableCode\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag unsafe statements in finally block\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;\nconst SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow control flow statements in `finally` blocks\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-finally\"\n        },\n\n        schema: [],\n\n        messages: {\n            unsafeUsage: \"Unsafe usage of {{nodeType}}.\"\n        }\n    },\n    create(context) {\n\n        /**\n         * Checks if the node is the finalizer of a TryStatement\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} - true if the node is the finalizer of a TryStatement\n         */\n        function isFinallyBlock(node) {\n            return node.parent.type === \"TryStatement\" && node.parent.finalizer === node;\n        }\n\n        /**\n         * Climbs up the tree if the node is not a sentinel node\n         * @param {ASTNode} node node to check.\n         * @param {string} label label of the break or continue statement\n         * @returns {boolean} - return whether the node is a finally block or a sentinel node\n         */\n        function isInFinallyBlock(node, label) {\n            let labelInside = false;\n            let sentinelNodeType;\n\n            if (node.type === \"BreakStatement\" && !node.label) {\n                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;\n            } else if (node.type === \"ContinueStatement\") {\n                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;\n            } else {\n                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;\n            }\n\n            for (\n                let currentNode = node;\n                currentNode && !sentinelNodeType.test(currentNode.type);\n                currentNode = currentNode.parent\n            ) {\n                if (currentNode.parent.label && label && (currentNode.parent.label.name === label.name)) {\n                    labelInside = true;\n                }\n                if (isFinallyBlock(currentNode)) {\n                    if (label && labelInside) {\n                        return false;\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the possibly-unsafe statement is inside a finally block.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (isInFinallyBlock(node, node.label)) {\n                context.report({\n                    messageId: \"unsafeUsage\",\n                    data: {\n                        nodeType: node.type\n                    },\n                    node,\n                    line: node.loc.line,\n                    column: node.loc.column\n                });\n            }\n        }\n\n        return {\n            ReturnStatement: check,\n            ThrowStatement: check,\n            BreakStatement: check,\n            ContinueStatement: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\",\n            suggestion: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForOrderingRelations: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n\n        return {\n            BinaryExpression(node) {\n                const operator = node.operator;\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n                if (\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator },\n                        suggest: [\n                            {\n                                messageId: \"suggestNegatedExpression\",\n                                data: { operator },\n                                fix(fixer) {\n                                    const negationToken = sourceCode.getFirstToken(node.left);\n                                    const fixRange = [negationToken.range[1], node.range[1]];\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\n                                }\n                            },\n                            {\n                                messageId: \"suggestParenthesisedNegation\",\n                                fix(fixer) {\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n                                }\n                            }\n                        ]\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow unsafe optional chaining\n * @author Yeon JuAn\n */\n\n\"use strict\";\n\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n\n/**\n * Checks whether a node is a destructuring pattern or not\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\n */\nfunction isDestructuringPattern(node) {\n    return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                disallowArithmeticOperators: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: null,\n        messages: {\n            unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n            unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const disallowArithmeticOperators = (options.disallowArithmeticOperators) || false;\n\n        /**\n         * Reports unsafe usage of optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeUsage(node) {\n            context.report({\n                messageId: \"unsafeOptionalChain\",\n                node\n            });\n        }\n\n        /**\n         * Reports unsafe arithmetic operation on optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeArithmetic(node) {\n            context.report({\n                messageId: \"unsafeArithmetic\",\n                node\n            });\n        }\n\n        /**\n         * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\n         * @param {ASTNode} [node] node to check\n         * @param {Function} reportFunc report function\n         * @returns {void}\n         */\n        function checkUndefinedShortCircuit(node, reportFunc) {\n            if (!node) {\n                return;\n            }\n            switch (node.type) {\n                case \"LogicalExpression\":\n                    if (node.operator === \"||\" || node.operator === \"??\") {\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    } else if (node.operator === \"&&\") {\n                        checkUndefinedShortCircuit(node.left, reportFunc);\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    }\n                    break;\n                case \"SequenceExpression\":\n                    checkUndefinedShortCircuit(\n                        node.expressions[node.expressions.length - 1],\n                        reportFunc\n                    );\n                    break;\n                case \"ConditionalExpression\":\n                    checkUndefinedShortCircuit(node.consequent, reportFunc);\n                    checkUndefinedShortCircuit(node.alternate, reportFunc);\n                    break;\n                case \"AwaitExpression\":\n                    checkUndefinedShortCircuit(node.argument, reportFunc);\n                    break;\n                case \"ChainExpression\":\n                    reportFunc(node);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /**\n         * Checks unsafe usage of optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeUsage(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeUsage);\n        }\n\n        /**\n         * Checks unsafe arithmetic operations on optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeArithmetic(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n        }\n\n        return {\n            \"AssignmentExpression, AssignmentPattern\"(node) {\n                if (isDestructuringPattern(node.left)) {\n                    checkUnsafeUsage(node.right);\n                }\n            },\n            \"ClassDeclaration, ClassExpression\"(node) {\n                checkUnsafeUsage(node.superClass);\n            },\n            CallExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.callee);\n                }\n            },\n            NewExpression(node) {\n                checkUnsafeUsage(node.callee);\n            },\n            VariableDeclarator(node) {\n                if (isDestructuringPattern(node.id)) {\n                    checkUnsafeUsage(node.init);\n                }\n            },\n            MemberExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.object);\n                }\n            },\n            TaggedTemplateExpression(node) {\n                checkUnsafeUsage(node.tag);\n            },\n            ForOfStatement(node) {\n                checkUnsafeUsage(node.right);\n            },\n            SpreadElement(node) {\n                if (node.parent && node.parent.type !== \"ObjectExpression\") {\n                    checkUnsafeUsage(node.argument);\n                }\n            },\n            BinaryExpression(node) {\n                if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n                    checkUnsafeUsage(node.right);\n                }\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                    checkUnsafeArithmetic(node.left);\n                }\n            },\n            WithStatement(node) {\n                checkUnsafeUsage(node.object);\n            },\n            UnaryExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.argument);\n                }\n            },\n            AssignmentExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n    return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceForJSX: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false,\n            enforceForJSX = config.enforceForJSX || false;\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @param {ASTNode[]} ancestors the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/u.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * The member functions return `true` if the type has no side-effects.\n         * Unknown nodes are handled as `false`, then this rule ignores those.\n         */\n        const Checker = Object.assign(Object.create(null), {\n            isDisallowed(node) {\n                return (Checker[node.type] || alwaysFalse)(node);\n            },\n\n            ArrayExpression: alwaysTrue,\n            ArrowFunctionExpression: alwaysTrue,\n            BinaryExpression: alwaysTrue,\n            ChainExpression(node) {\n                return Checker.isDisallowed(node.expression);\n            },\n            ClassExpression: alwaysTrue,\n            ConditionalExpression(node) {\n                if (allowTernary) {\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n                }\n                return true;\n            },\n            FunctionExpression: alwaysTrue,\n            Identifier: alwaysTrue,\n            JSXElement() {\n                return enforceForJSX;\n            },\n            JSXFragment() {\n                return enforceForJSX;\n            },\n            Literal: alwaysTrue,\n            LogicalExpression(node) {\n                if (allowShortCircuit) {\n                    return Checker.isDisallowed(node.right);\n                }\n                return true;\n            },\n            MemberExpression: alwaysTrue,\n            MetaProperty: alwaysTrue,\n            ObjectExpression: alwaysTrue,\n            SequenceExpression: alwaysTrue,\n            TaggedTemplateExpression() {\n                return !allowTaggedTemplates;\n            },\n            TemplateLiteral: alwaysTrue,\n            ThisExpression: alwaysTrue,\n            UnaryExpression(node) {\n                return node.operator !== \"void\" && node.operator !== \"delete\";\n            }\n        });\n\n        return {\n            ExpressionStatement(node) {\n                if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, messageId: \"unusedExpression\" });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused labels\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-labels\"\n        },\n\n        schema: [],\n\n        fixable: \"code\",\n\n        messages: {\n            unused: \"'{{name}}:' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         * @param {ASTNode} node A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         * @param {ASTNode} node A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    messageId: \"unused\",\n                    data: node.label,\n                    fix(fixer) {\n\n                        /*\n                         * Only perform a fix if there are no comments between the label and the body. This will be the case\n                         * when there is exactly one token/comment (the \":\") between the label and the body.\n                         */\n                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) ===\n                                sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                            return fixer.removeRange([node.range[0], node.body.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         * @param {ASTNode} node A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                return variable.defs.some(def => {\n                    const propertyNode = def.name.parent;\n                    const patternNode = propertyNode.parent;\n\n                    return (\n                        propertyNode.type === \"Property\" &&\n                        patternNode.type === \"ObjectPattern\" &&\n                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)\n                    );\n                });\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const grandparent = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                grandparent.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const grandparent = parent.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (// in RHS of an assignment for itself. e.g. `a = a + 1`\n                    ((\n                        parent.type === \"AssignmentExpression\" &&\n                    grandparent.type === \"ExpressionStatement\" &&\n                    parent.left === id\n                    ) ||\n                (\n                    parent.type === \"UpdateExpression\" &&\n                    grandparent.type === \"ExpressionStatement\"\n                ) || rhsNode &&\n                isInside(id, rhsNode) &&\n                !isInsideOfStorableFunction(id, rhsNode)))\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n                        context.report({\n                            node: unusedVar.references.length ? unusedVar.references[\n                                unusedVar.references.length - 1\n                            ].identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar)\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n * @param {Variable} variable A variable to check.\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                /*\n                 * Skips when the reference is:\n                 * - initialization's.\n                 * - referring to an undefined variable.\n                 * - referring to a global environment variable (there're no identifiers).\n                 * - located preceded by the variable (except in initializers).\n                 * - allowed by options.\n                 */\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    messageId: \"usedBeforeDefined\",\n                    data: reference.identifier\n                });\n            });\n\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n\n        return {\n            Program() {\n                findVariablesInScope(context.getScope());\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new RegExpParser();\n\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\nfunction getPathToRoot(node) {\n    const path = [];\n    let current = node;\n\n    do {\n        path.push(current);\n        current = current.parent;\n    } while (current);\n\n    return path;\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\nfunction isLookaround(node) {\n    return node.type === \"Assertion\" &&\n        (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\nfunction isNegativeLookaround(node) {\n    return isLookaround(node) && node.negate;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow useless backreferences in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n        },\n\n        schema: [],\n\n        messages: {\n            nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n            forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n            backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n            disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n            intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks and reports useless backreferences in the given regular expression.\n         * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n         * @param {string} pattern Regular expression pattern.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         */\n        function checkRegex(node, pattern, flags) {\n            let regExpAST;\n\n            try {\n                regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(regExpAST, {\n                onBackreferenceEnter(bref) {\n                    const group = bref.resolved,\n                        brefPath = getPathToRoot(bref),\n                        groupPath = getPathToRoot(group);\n                    let messageId = null;\n\n                    if (brefPath.includes(group)) {\n\n                        // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n                        messageId = \"nested\";\n                    } else {\n\n                        // Start from the root to find the lowest common ancestor.\n                        let i = brefPath.length - 1,\n                            j = groupPath.length - 1;\n\n                        do {\n                            i--;\n                            j--;\n                        } while (brefPath[i] === groupPath[j]);\n\n                        const indexOfLowestCommonAncestor = j + 1,\n                            groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                            commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                            lowestCommonLookaround = commonPath.find(isLookaround),\n                            isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n                        if (!isMatchingBackward && bref.end <= group.start) {\n\n                            // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n                            messageId = \"forward\";\n                        } else if (isMatchingBackward && group.end <= bref.start) {\n\n                            // the opposite of the previous when the regex is matching backward in a lookbehind context.\n                            messageId = \"backward\";\n                        } else if (lodash.last(groupCut).type === \"Alternative\") {\n\n                            // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n                            messageId = \"disjunctive\";\n                        } else if (groupCut.some(isNegativeLookaround)) {\n\n                            // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n                            messageId = \"intoNegativeLookaround\";\n                        }\n                    }\n\n                    if (messageId) {\n                        context.report({\n                            node,\n                            messageId,\n                            data: {\n                                bref: bref.raw,\n                                group: group.raw\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                const { pattern, flags } = node.regex;\n\n                checkRegex(node, pattern, flags);\n            },\n            Program() {\n                const scope = context.getScope(),\n                    tracker = new ReferenceTracker(scope),\n                    traceMap = {\n                        RegExp: {\n                            [CALL]: true,\n                            [CONSTRUCT]: true\n                        }\n                    };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const [patternNode, flagsNode] = node.arguments,\n                        pattern = getStringIfConstant(patternNode, scope),\n                        flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        checkRegex(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.call()`/`.apply()`.\n * @param {ASTNode} node A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.\n */\nfunction isCallOrNonVariadicApply(node) {\n    const callee = astUtils.skipChainExpression(node.callee);\n\n    return (\n        callee.type === \"MemberExpression\" &&\n        callee.property.type === \"Identifier\" &&\n        callee.computed === false &&\n        (\n            (callee.property.name === \"call\" && node.arguments.length >= 1) ||\n            (callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\")\n        )\n    );\n}\n\n\n/**\n * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n * @param {ASTNode|null} expectedThis The node that is the owner of the applied function.\n * @param {ASTNode} thisArg The node that is given to the first argument of the `.call()`/`.apply()`.\n * @param {SourceCode} sourceCode The ESLint source code object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, sourceCode) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return astUtils.equalTokens(expectedThis, thisArg, sourceCode);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-call\"\n        },\n\n        schema: [],\n\n        messages: {\n            unnecessaryCall: \"Unnecessary '.{{name}}()'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isCallOrNonVariadicApply(node)) {\n                    return;\n                }\n\n                const callee = astUtils.skipChainExpression(node.callee);\n                const applied = astUtils.skipChainExpression(callee.object);\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({ node, messageId: \"unnecessaryCall\", data: { name: callee.property.name } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Reports useless `catch` clauses that just rethrow their error.\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary `catch` clauses\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-catch\"\n        },\n\n        schema: [],\n\n        messages: {\n            unnecessaryCatchClause: \"Unnecessary catch clause.\",\n            unnecessaryCatch: \"Unnecessary try/catch wrapper.\"\n        }\n    },\n\n    create(context) {\n        return {\n            CatchClause(node) {\n                if (\n                    node.param &&\n                    node.param.type === \"Identifier\" &&\n                    node.body.body.length &&\n                    node.body.body[0].type === \"ThrowStatement\" &&\n                    node.body.body[0].argument.type === \"Identifier\" &&\n                    node.body.body[0].argument.name === node.param.name\n                ) {\n                    if (node.parent.finalizer) {\n                        context.report({\n                            node,\n                            messageId: \"unnecessaryCatchClause\"\n                        });\n                    } else {\n                        context.report({\n                            node: node.parent,\n                            messageId: \"unnecessaryCatch\"\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary computed property keys in objects and classes\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (!node.computed) {\n                return;\n            }\n\n            const key = node.key,\n                nodeType = typeof key.value;\n\n            let allowedKey;\n\n            if (node.type === \"MethodDefinition\") {\n                allowedKey = node.static ? \"prototype\" : \"constructor\";\n            } else {\n                allowedKey = \"__proto__\";\n            }\n\n            if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== allowedKey) {\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : lodash.noop\n        };\n    }\n};\n","/**\n * @fileoverview disallow unnecessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedConcat: \"Unexpected string concatenation of literals.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc,\n                        messageId: \"unexpectedConcat\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag the use of redundant constructors in classes.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given array of statements is a single call of `super`.\n * @param {ASTNode[]} body An array of statements to check.\n * @returns {boolean} `true` if the body is a single call of `super`.\n */\nfunction isSingleSuperCall(body) {\n    return (\n        body.length === 1 &&\n        body[0].type === \"ExpressionStatement\" &&\n        body[0].expression.type === \"CallExpression\" &&\n        body[0].expression.callee.type === \"Super\"\n    );\n}\n\n/**\n * Checks whether a given node is a pattern which doesn't have any side effects.\n * Default parameters and Destructuring parameters can have side effects.\n * @param {ASTNode} node A pattern node.\n * @returns {boolean} `true` if the node doesn't have any side effects.\n */\nfunction isSimple(node) {\n    return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\n/**\n * Checks whether a given array of expressions is `...arguments` or not.\n * `super(...arguments)` passes all arguments through.\n * @param {ASTNode[]} superArgs An array of expressions to check.\n * @returns {boolean} `true` if the superArgs is `...arguments`.\n */\nfunction isSpreadArguments(superArgs) {\n    return (\n        superArgs.length === 1 &&\n        superArgs[0].type === \"SpreadElement\" &&\n        superArgs[0].argument.type === \"Identifier\" &&\n        superArgs[0].argument.name === \"arguments\"\n    );\n}\n\n/**\n * Checks whether given 2 nodes are identifiers which have the same name or not.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes are identifiers which have the same\n *      name.\n */\nfunction isValidIdentifierPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"Identifier\" &&\n        superArg.type === \"Identifier\" &&\n        ctorParam.name === superArg.name\n    );\n}\n\n/**\n * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n *      same values.\n */\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"RestElement\" &&\n        superArg.type === \"SpreadElement\" &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n    );\n}\n\n/**\n * Checks whether given 2 nodes have the same value or not.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes have the same value or not.\n */\nfunction isValidPair(ctorParam, superArg) {\n    return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n    );\n}\n\n/**\n * Checks whether the parameters of a constructor and the arguments of `super()`\n * have the same values or not.\n * @param {ASTNode} ctorParams The parameters of a constructor to check.\n * @param {ASTNode} superArgs The arguments of `super()` to check.\n * @returns {boolean} `true` if those have the same values.\n */\nfunction isPassingThrough(ctorParams, superArgs) {\n    if (ctorParams.length !== superArgs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether the constructor body is a redundant super call.\n * @param {Array} body constructor body content.\n * @param {Array} ctorParams The params to check against super call.\n * @returns {boolean} true if the constructor body is redundant\n */\nfunction isRedundantSuperCall(body, ctorParams) {\n    return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n            isSpreadArguments(body[0].expression.arguments) ||\n            isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary constructors\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-constructor\"\n        },\n\n        schema: [],\n\n        messages: {\n            noUselessConstructor: \"Useless constructor.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether a node is a redundant constructor\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkForConstructor(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n\n            /*\n             * Prevent crashing on parsers which do not require class constructor\n             * to have a body, e.g. typescript and flow\n             */\n            if (!node.value.body) {\n                return;\n            }\n\n            const body = node.value.body.body;\n            const ctorParams = node.value.params;\n            const superClass = node.parent.parent.superClass;\n\n            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {\n                context.report({\n                    node,\n                    messageId: \"noUselessConstructor\"\n                });\n            }\n        }\n\n        return {\n            MethodDefinition: checkForConstructor\n        };\n    }\n};\n","/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({\n            text: char,\n            index,\n            escaped: state.escapeNextChar,\n            inCharClass: state.inCharClass,\n            startsCharClass: state.startingCharClass,\n            endsCharClass: false\n        });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-escape\",\n            suggestion: true\n        },\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            const rangeStart = node.range[0] + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n            const start = sourceCode.getLocFromIndex(rangeStart);\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n                        messageId: \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    {\n                        messageId: \"escapeBackslash\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange(range, \"\\\\\");\n                        }\n                    }\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow renaming import, export, and destructured assignments to the same name\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-rename\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\", default: false },\n                    ignoreImport: { type: \"boolean\", default: false },\n                    ignoreExport: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node node to report\n         * @param {ASTNode} initial node with initial name value\n         * @param {string} type the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                messageId: \"unnecessarilyRenamed\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n                    if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n                        return null;\n                    }\n\n                    // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n                    if (\n                        replacementNode.type === \"AssignmentPattern\" &&\n                        astUtils.isParenthesised(sourceCode, replacementNode.left)\n                    ) {\n                        return null;\n                    }\n\n                    return fixer.replaceText(node, sourceCode.getText(replacementNode));\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            for (const property of node.properties) {\n\n                /**\n                 * Properties using shorthand syntax and rest elements can not be renamed.\n                 * If the property is computed, we have no idea if a rename is useless or not.\n                 */\n                if (property.type !== \"Property\" || property.shorthand || property.computed) {\n                    continue;\n                }\n\n                const key = (property.key.type === \"Identifier\" && property.key.name) || (property.key.type === \"Literal\" && property.key.value);\n                const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n                if (key === renamedKey) {\n                    reportError(property, property.key, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (node.imported.name === node.local.name &&\n                    node.imported.range[0] !== node.local.range[0]) {\n                reportError(node, node.imported, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (node.local.name === node.exported.name &&\n                    node.local.range[0] !== node.exported.range[0]) {\n                reportError(node, node.local, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n","/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unnecessaryReturn: \"Unnecessary return statement.\"\n        }\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        messageId: \"unnecessaryReturn\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\nfunction isGlobal(variable) {\n    return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n * @param {eslint-scope.Scope} scope The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    let currentScope = scope;\n\n    while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n        currentScope = currentScope.upper;\n    }\n    return currentScope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n * @param {ASTNode} node A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\n/**\n * Gets the scope node which directly contains a given node.\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n * @param {ASTNode} scopeNode A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     * @param {eslint-scope.Reference} reference A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n * @param {ASTNode} node The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n/**\n * Checks whether a given variable has name that is allowed for 'var' declarations,\n * but disallowed for `let` declarations.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable has a disallowed name.\n */\nfunction hasNameDisallowedForLetDeclarations(variable) {\n    return variable.name === \"let\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-var\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedVar: \"Unexpected var, use let or const instead.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         * @param {ASTNode} declarator The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is a global variable.\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         * - A variable has name that is disallowed for `let` declarations.\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         * @param {ASTNode} node A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isGlobal) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode)) ||\n                variables.some(hasNameDisallowedForLetDeclarations)\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         * @param {ASTNode} node A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"unexpectedVar\",\n\n                fix(fixer) {\n                    const varToken = sourceCode.getFirstToken(node, { filter: t => t.value === \"var\" });\n\n                    return canFix(node)\n                        ? fixer.replaceText(varToken, \"let\")\n                        : null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of void operator.\n * @author Mike Sidorov\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `void` operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-void\"\n        },\n\n        messages: {\n            noVoid: \"Expected 'undefined' and instead saw 'void'.\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAsStatement: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const allowAsStatement =\n            context.options[0] && context.options[0].allowAsStatement;\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            'UnaryExpression[operator=\"void\"]'(node) {\n                if (\n                    allowAsStatement &&\n                    node.parent &&\n                    node.parent.type === \"ExpressionStatement\"\n                ) {\n                    return;\n                }\n                context.report({\n                    node,\n                    messageId: \"noVoid\"\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst { escapeRegExp } = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n            const wordBoundary = \"\\\\b\";\n            const eitherOrWordBoundary = `|${wordBoundary}`;\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            } else {\n                prefix = \"\";\n            }\n\n            if (location === \"start\") {\n\n                /*\n                 * For location \"start\" the regex should be\n                 * ^\\s*TERM\\b.  This checks the word boundary\n                 * at the beginning of the comment.\n                 */\n                return new RegExp(prefix + escaped + suffix, \"iu\");\n            }\n\n            /*\n             * For location \"anywhere\" the regex should be\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n             * for the term.\n             */\n            return new RegExp(\n                prefix +\n                    escaped +\n                    suffix +\n                    eitherOrWordBoundary +\n                    term +\n                    wordBoundary,\n                \"iu\"\n            );\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow whitespace before properties\n * @author Kai Cataldo\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow whitespace before properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-whitespace-before-property\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [],\n\n        messages: {\n            unexpectedWhitespace: \"Unexpected whitespace before property {{propName}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports whitespace before property token\n         * @param {ASTNode} node the node to report in the event of an error\n         * @param {Token} leftToken the left token\n         * @param {Token} rightToken the right token\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, leftToken, rightToken) {\n            context.report({\n                node,\n                messageId: \"unexpectedWhitespace\",\n                data: {\n                    propName: sourceCode.getText(node.property)\n                },\n                fix(fixer) {\n                    let replacementText = \"\";\n\n                    if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {\n\n                        /*\n                         * If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.\n                         * Don't fix this case.\n                         */\n                        return null;\n                    }\n\n                    // Don't fix if comments exist.\n                    if (sourceCode.commentsExistBetween(leftToken, rightToken)) {\n                        return null;\n                    }\n\n                    if (node.optional) {\n                        replacementText = \"?.\";\n                    } else if (!node.computed) {\n                        replacementText = \".\";\n                    }\n\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            MemberExpression(node) {\n                let rightToken;\n                let leftToken;\n\n                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n                    return;\n                }\n\n                if (node.computed) {\n                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);\n                    leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);\n                } else {\n                    rightToken = sourceCode.getFirstToken(node.property);\n                    leftToken = sourceCode.getTokenBefore(rightToken, 1);\n                }\n\n                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n                    reportError(node, leftToken, rightToken);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of with statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `with` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-with\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedWith: \"Unexpected use of 'with' statement.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            WithStatement(node) {\n                context.report({ node, messageId: \"unexpectedWith\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce the location of single-line statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst POSITION_SCHEMA = { enum: [\"beside\", \"below\", \"any\"] };\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of single-line statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/nonblock-statement-body-position\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            POSITION_SCHEMA,\n            {\n                properties: {\n                    overrides: {\n                        properties: {\n                            if: POSITION_SCHEMA,\n                            else: POSITION_SCHEMA,\n                            while: POSITION_SCHEMA,\n                            do: POSITION_SCHEMA,\n                            for: POSITION_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectNoLinebreak: \"Expected no linebreak before this statement.\",\n            expectLinebreak: \"Expected a linebreak before this statement.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Gets the applicable preference for a particular keyword\n         * @param {string} keywordName The name of a keyword, e.g. 'if'\n         * @returns {string} The applicable option for the keyword, e.g. 'beside'\n         */\n        function getOption(keywordName) {\n            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||\n                context.options[0] ||\n                \"beside\";\n        }\n\n        /**\n         * Validates the location of a single-line statement\n         * @param {ASTNode} node The single-line statement\n         * @param {string} keywordName The applicable keyword name for the single-line statement\n         * @returns {void}\n         */\n        function validateStatement(node, keywordName) {\n            const option = getOption(keywordName);\n\n            if (node.type === \"BlockStatement\" || option === \"any\") {\n                return;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore.loc.end.line === node.loc.start.line && option === \"below\") {\n                context.report({\n                    node,\n                    messageId: \"expectLinebreak\",\n                    fix: fixer => fixer.insertTextBefore(node, \"\\n\")\n                });\n            } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === \"beside\") {\n                context.report({\n                    node,\n                    messageId: \"expectNoLinebreak\",\n                    fix(fixer) {\n                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                validateStatement(node.consequent, \"if\");\n\n                // Check the `else` node, but don't check 'else if' statements.\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    validateStatement(node.alternate, \"else\");\n                }\n            },\n            WhileStatement: node => validateStatement(node.body, \"while\"),\n            DoWhileStatement: node => validateStatement(node.body, \"do\"),\n            ForStatement: node => validateStatement(node.body, \"for\"),\n            ForInStatement: node => validateStatement(node.body, \"for\"),\n            ForOfStatement: node => validateStatement(node.body, \"for\")\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);\n\n    if (lodash.isPlainObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks after opening and before closing braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n            unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n            expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n            expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        messageId: \"expectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        messageId: \"expectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    arraysInObjects: {\n                        type: \"boolean\"\n                    },\n                    objectsInObjects: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            requireSpaceBefore: \"A space is required before '{{token}}'.\",\n            requireSpaceAfter: \"A space is required after '{{token}}'.\",\n            unexpectedSpaceBefore: \"There should be no space before '{{token}}'.\",\n            unexpectedSpaceAfter: \"There should be no space after '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n            objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token) {\n            const nextToken = context.getSourceCode().getTokenAfter(token, { includeComments: true });\n\n            context.report({\n                node,\n                loc: { start: token.loc.end, end: nextToken.loc.start },\n                messageId: \"unexpectedSpaceAfter\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token) {\n            const previousToken = context.getSourceCode().getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                node,\n                loc: { start: previousToken.loc.end, end: token.loc.start },\n                messageId: \"unexpectedSpaceBefore\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"requireSpaceAfter\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"requireSpaceBefore\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if spacing in curly braces is valid.\n         * @param {ASTNode} node The AST node to check.\n         * @param {Token} first The first token to check (should be the opening brace)\n         * @param {Token} second The second token to check (should be first after the opening brace)\n         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n         * @param {Token} last The last token to check (should be closing brace)\n         * @returns {void}\n         */\n        function validateBraceSpacing(node, first, second, penultimate, last) {\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n                if (options.spaced && !firstSpaced) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!options.spaced && firstSpaced && second.type !== \"Line\") {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (astUtils.isTokenOnSameLine(penultimate, last)) {\n                const shouldCheckPenultimate = (\n                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||\n                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)\n                );\n                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;\n\n                const closingCurlyBraceMustBeSpaced = (\n                    options.arraysInObjectsException && penultimateType === \"ArrayExpression\" ||\n                    options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\")\n                ) ? !options.spaced : options.spaced;\n\n                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        /**\n         * Gets '}' token of an object node.\n         *\n         * Because the last token of object patterns might be a type annotation,\n         * this traverses tokens preceded by the last property, then returns the\n         * first '}' token.\n         * @param {ASTNode} node The node to get. This node is an\n         *      ObjectExpression or an ObjectPattern. And this node has one or\n         *      more properties.\n         * @returns {Token} '}' token.\n         */\n        function getClosingBraceOfObject(node) {\n            const lastProperty = node.properties[node.properties.length - 1];\n\n            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n        }\n\n        /**\n         * Reports a given object node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ObjectExpression or ObjectPattern node to check.\n         * @returns {void}\n         */\n        function checkForObject(node) {\n            if (node.properties.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                last = getClosingBraceOfObject(node),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given import node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ImportDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForImport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            let firstSpecifier = node.specifiers[0];\n            const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n            if (lastSpecifier.type !== \"ImportSpecifier\") {\n                return;\n            }\n            if (firstSpecifier.type !== \"ImportSpecifier\") {\n                firstSpecifier = node.specifiers[1];\n            }\n\n            const first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given export node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ExportNamedDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForExport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            const firstSpecifier = node.specifiers[0],\n                lastSpecifier = node.specifiers[node.specifiers.length - 1],\n                first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // var {x} = y;\n            ObjectPattern: checkForObject,\n\n            // var y = {x: 'y'}\n            ObjectExpression: checkForObject,\n\n            // import {y} from 'x';\n            ImportDeclaration: checkForImport,\n\n            // export {name} from 'yo';\n            ExportNamedDeclaration: checkForExport\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce placing object properties on separate lines.\n * @author Vitor Balocco\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce placing object properties on separate lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-property-newline\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAllPropertiesOnSameLine: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowMultiplePropertiesPerLine: { // Deprecated\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            propertiesOnNewlineAll: \"Object properties must go on a new line if they aren't all on the same line.\",\n            propertiesOnNewline: \"Object properties must go on a new line.\"\n        }\n    },\n\n    create(context) {\n        const allowSameLine = context.options[0] && (\n            (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine /* Deprecated */)\n        );\n        const messageId = allowSameLine\n            ? \"propertiesOnNewlineAll\"\n            : \"propertiesOnNewline\";\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            ObjectExpression(node) {\n                if (allowSameLine) {\n                    if (node.properties.length > 1) {\n                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n\n                            // All keys and values are on the same line\n                            return;\n                        }\n                    }\n                }\n\n                for (let i = 1; i < node.properties.length; i++) {\n                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n                        context.report({\n                            node,\n                            loc: firstTokenOfCurrentProperty.loc,\n                            messageId,\n                            fix(fixer) {\n                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                                // Don't perform a fix if there are any comments between the comma and the next property.\n                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n            expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n            expectedPropertyShorthand: \"Expected property shorthand.\",\n            expectedPropertyLongform: \"Expected longform property syntax.\",\n            expectedMethodShorthand: \"Expected method shorthand.\",\n            expectedMethodLongform: \"Expected longform method syntax.\",\n            unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const match = CTOR_PREFIX_REGEX.exec(name);\n\n            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n            if (!match) {\n                return false;\n            }\n\n            const firstChar = name.charAt(match.index);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         *\n         */\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n         * Checks whether a node is a string literal.\n         * @param   {ASTNode} node Any AST node.\n         * @returns {boolean} `true` if it is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         *\n         */\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         *\n         */\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         *\n         */\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                /*\n                 * If we do not have an equal number of longform properties as\n                 * shorthand properties, we are using the annotations inconsistently\n                 */\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, messageId: \"unexpectedMix\" });\n                    } else if (checkRedundancy) {\n\n                        /*\n                         * If all properties of the object contain a method or value with a name matching it's key,\n                         * all the keys are redundant.\n                         */\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, messageId: \"expectedAllPropertiesShorthanded\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a shorthand property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\n                : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\n                : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            // key: /* */ () => {}\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n                return null;\n            }\n\n            if (node.value.async) {\n                keyPrefix += \"async \";\n            }\n            if (node.value.generator) {\n                keyPrefix += \"*\";\n            }\n\n            const fixRange = [firstKeyToken.range[0], node.range[1]];\n            const methodPrefix = keyPrefix + keyText;\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    fixRange,\n                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n\n            let shouldAddParensAroundParameters = false;\n            let tokenBeforeParams;\n\n            if (node.value.params.length === 0) {\n                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n            } else {\n                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n            }\n\n            if (node.value.params.length === 1) {\n                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n\n                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n            }\n\n            const sliceStart = shouldAddParensAroundParameters\n                ? node.value.params[0].range[0]\n                : tokenBeforeParams.range[0];\n            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n\n            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n            const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n\n            return fixer.replaceTextRange(\n                fixRange,\n                methodPrefix + newParamText + fnBody\n            );\n\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a longform property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.async) {\n                functionHeader = `async ${functionHeader}`;\n            }\n            if (node.value.generator) {\n                functionHeader = `${functionHeader}*`;\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\n         * @returns {void}\n         */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\n         * in the current lexical scope contain a reference to this lexical keyword.\n         * @returns {void}\n         */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            messageId,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            messageId: \"expectedPropertyLongform\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            messageId: \"expectedMethodShorthand\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        messageId: \"expectedPropertyShorthand\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check multiple var declarations per line\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow newlines around variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var-declaration-per-line\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"initializations\"]\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            expectVarOnNewline: \"Expected variable declaration to be on a new line.\"\n        }\n    },\n\n    create(context) {\n\n        const always = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Checks newlines around variable declarations.\n         * @private\n         * @param {ASTNode} node `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForNewLine(node) {\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            let prev;\n\n            declarations.forEach(current => {\n                if (prev && prev.loc.end.line === current.loc.start.line) {\n                    if (always || prev.init || current.init) {\n                        context.report({\n                            node,\n                            messageId: \"expectVarOnNewline\",\n                            loc: current.loc,\n                            fix: fixer => fixer.insertTextBefore(current, \"\\n\")\n                        });\n                    }\n                }\n                prev = current;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForNewLine\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\nfunction isInStatementList(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\"\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n            combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n            splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n            splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n            splitRequires: \"Split requires to be separated into a single block.\",\n            combine: \"Combine this with the previous '{{type}}' statement.\",\n            split: \"Split '{{type}}' declarations into multiple statements.\"\n        }\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = !!mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function} The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n         * @returns {Function|null} The fixer function\n         */\n        function splitDeclarations(declaration) {\n            const { parent } = declaration;\n\n            // don't autofix code such as: if (foo) var x, y;\n            if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n                return null;\n            }\n\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        messageId: \"splitRequires\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            messageId: \"combine\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        messageId: \"combine\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            messageId: \"split\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            messageId: \"splitInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            messageId: \"splitUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commutative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n    return (\n        node.type === \"Identifier\" ||\n        (\n            node.type === \"MemberExpression\" &&\n            (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") &&\n            (!node.computed || node.property.type === \"Literal\")\n        )\n    );\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-assignment\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            replaced: \"Assignment can be replaced with operator assignment.\",\n            unexpected: \"Unexpected operator assignment shorthand.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n         * @returns {Token} The operator token in the node\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                if (astUtils.isSameReference(left, expr.left, true)) {\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        fix(fixer) {\n                            if (canBeFixed(left) && canBeFixed(expr.left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                // Check for comments that would be removed.\n                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        messageId: \"replaced\"\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const firstToken = sourceCode.getFirstToken(node);\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // Check for comments that would be duplicated.\n                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                                return null;\n                            }\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true });\n                                let rightTextPrefix = \"\";\n\n                                if (\n                                    operatorToken.range[1] === tokenAfterOperator.range[0] &&\n                                    !astUtils.canTokensBeAdjacent({ type: \"Punctuator\", value: newOperator }, tokenAfterOperator)\n                                ) {\n                                    rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                                }\n\n                                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n","/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n            operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n            badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n            noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            /*\n             * When the left part of a binary expression is a single expression wrapped in\n             * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n             * and operatorToken will be the closing parenthesis.\n             * The leftToken should be the last closing parenthesis, and the operatorToken\n             * should be the token right after that.\n             */\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"badLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtBeginning\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtEnd\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"noLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            alwaysPadBlock: \"Block must be padded by blank lines.\",\n            neverPadBlock: \"Block must not be padded by blank lines.\"\n        }\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        messageId: \"neverPadBlock\"\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        messageId: \"neverPadBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = astUtils.skipChainExpression(node.expression);\n\n        if (call.type === \"UnaryExpression\") {\n            call = astUtils.skipChainExpression(call.argument);\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"unexpectedBlankLine\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        messageId: \"expectedBlankLine\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        },\n\n        messages: {\n            unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n            expectedBlankLine: \"Expected blank line before this statement.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n    let bound = false;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ChainExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (\n                    parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\"\n                ) {\n                    const maybeCallee = parent.parent.type === \"ChainExpression\"\n                        ? parent.parent\n                        : parent;\n\n                    if (astUtils.isCallee(maybeCallee)) {\n                        if (!bound) {\n                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n                            retv.isLexicalThis = (\n                                maybeCallee.parent.arguments.length === 1 &&\n                                maybeCallee.parent.arguments[0].type === \"ThisExpression\"\n                            );\n                        }\n                        parent = maybeCallee.parent;\n                    } else {\n                        return retv;\n                    }\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            preferArrowCallback: \"Unexpected function expression.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"preferArrowCallback\",\n                        *fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                            }\n\n                            // Remove `.bind(this)` if exists.\n                            if (callbackInfo.isLexicalThis) {\n                                const memberNode = node.parent;\n\n                                /*\n                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                                 * E.g. `(foo || function(){}).bind(this)`\n                                 */\n                                if (memberNode.type !== \"MemberExpression\") {\n                                    return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                                }\n\n                                const callNode = memberNode.parent;\n                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                                /*\n                                 * If the member expression is parenthesized, don't remove the right paren.\n                                 * E.g. `(function(){}.bind)(this)`\n                                 *                    ^^^^^^^^^^^^\n                                 */\n                                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                                    return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                                }\n\n                                // If comments exist in the `.bind(this)`, don't remove those.\n                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                                    return; // eslint-disable-line eslint-plugin/fixer-return -- false positive\n                                }\n\n                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n                            }\n\n                            // Convert the function expression to an arrow function.\n                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n\n                                // Remove only extra tokens to keep comments.\n                                yield fixer.remove(functionToken);\n                                if (node.id) {\n                                    yield fixer.remove(node.id);\n                                }\n                            } else {\n\n                                // Remove extra tokens and spaces.\n                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n                            }\n                            yield fixer.insertTextBefore(node.body, \"=> \");\n\n                            // Get the node that will become the new arrow function.\n                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            if (replacedNode.type === \"ChainExpression\") {\n                                replacedNode = replacedNode.parent;\n                            }\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            if (\n                                replacedNode.parent.type !== \"CallExpression\" &&\n                                replacedNode.parent.type !== \"ConditionalExpression\" &&\n                                !astUtils.isParenthesised(sourceCode, replacedNode) &&\n                                !astUtils.isParenthesised(sourceCode, node)\n                            ) {\n                                yield fixer.insertTextBefore(replacedNode, \"(\");\n                                yield fixer.insertTextAfter(replacedNode, \")\");\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => {\n                                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n\n                                /**\n                                 * Extend the replacement range to the whole declaration,\n                                 * in order to prevent other fixes in the same pass\n                                 * https://github.com/eslint/eslint/issues/13899\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainRange(varDeclParent.range)\n                                    .replaceTextRange(letKeywordToken.range, \"const\");\n                            }\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: \"AssignmentExpression\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            preferDestructuring: \"Use {{type}} destructuring.\"\n        }\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                messageId: \"preferDestructuring\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                !node.init.computed &&\n                node.init.property.type === \"Identifier\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.getSourceCode();\n\n            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n                return null;\n            }\n\n            let objectText = sourceCode.getText(rightNode.object);\n\n            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                objectText = `(${objectText})`;\n            }\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${objectText}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssignmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssignmentExpression\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: \"BinaryExpression\", operator: \"**\" });\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n    return (\n\n        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n\n        // An unary operator cannot be used immediately before an exponentiation expression\n        base.type === \"AwaitExpression\" ||\n        base.type === \"UnaryExpression\"\n    );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n\n    // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n    const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n\n    const needsParens = (\n        parent.type === \"ClassDeclaration\" ||\n        (\n            parent.type.endsWith(\"Expression\") &&\n            astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR &&\n            !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) &&\n            !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) &&\n            !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) &&\n            !(parent.type === \"ArrayExpression\")\n        )\n    );\n\n    return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n    return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node 'Math.pow()' node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"useExponentiation\",\n                fix(fixer) {\n                    if (\n                        node.arguments.length !== 2 ||\n                        node.arguments.some(arg => arg.type === \"SpreadElement\") ||\n                        sourceCode.getCommentsInside(node).length > 0\n                    ) {\n                        return null;\n                    }\n\n                    const base = node.arguments[0],\n                        exponent = node.arguments[1],\n                        baseText = sourceCode.getText(base),\n                        exponentText = sourceCode.getText(exponent),\n                        shouldParenthesizeBase = doesBaseNeedParens(base),\n                        shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                        shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n\n                    let prefix = \"\",\n                        suffix = \"\";\n\n                    if (!shouldParenthesizeAll) {\n                        if (!shouldParenthesizeBase) {\n                            const firstReplacementToken = sourceCode.getFirstToken(base),\n                                tokenBefore = sourceCode.getTokenBefore(node);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n                            }\n                        }\n                        if (!shouldParenthesizeExponent) {\n                            const lastReplacementToken = sourceCode.getLastToken(exponent),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)\n                            ) {\n                                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n                            }\n                        }\n                    }\n\n                    const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                        exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                        replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n\n                    return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                }\n            });\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Math: {\n                        pow: { [CALL]: true }\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce requiring named capture groups in regular expression.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"eslint-utils\");\nconst regexpp = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new regexpp.RegExpParser();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce using named capture group in regular expression\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-named-capture-group\"\n        },\n\n        schema: [],\n\n        messages: {\n            required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Function to check regular expression.\n         * @param {string} pattern The regular expression pattern to be check.\n         * @param {ASTNode} node AST node which contains regular expression.\n         * @param {boolean} uFlag Flag indicates whether unicode mode is enabled or not.\n         * @returns {void}\n         */\n        function checkRegex(pattern, node, uFlag) {\n            let ast;\n\n            try {\n                ast = parser.parsePattern(pattern, 0, pattern.length, uFlag);\n            } catch {\n\n                // ignore regex syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(ast, {\n                onCapturingGroupEnter(group) {\n                    if (!group.name) {\n                        context.report({\n                            node,\n                            messageId: \"required\",\n                            data: {\n                                group: group.raw\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            Literal(node) {\n                if (node.regex) {\n                    checkRegex(node.regex.pattern, node, node.regex.flags.includes(\"u\"));\n                }\n            },\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const regex = getStringIfConstant(node.arguments[0]);\n                    const flags = getStringIfConstant(node.arguments[1]);\n\n                    if (regex) {\n                        checkRegex(regex, node, flags && flags.includes(\"u\"));\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\n]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    return (\n        astUtils.isSpecificId(calleeNode, \"parseInt\") ||\n        astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            \"CallExpression[arguments.length=2]\"(node) {\n                const [strNode, radixNode] = node.arguments,\n                    str = astUtils.getStaticStringValue(strNode),\n                    radix = radixNode.value;\n\n                if (\n                    str !== null &&\n                    astUtils.isStringLiteral(strNode) &&\n                    radixNode.type === \"Literal\" &&\n                    typeof radix === \"number\" &&\n                    radixMap.has(radix) &&\n                    isParseInt(node.callee)\n                ) {\n\n                    const { system, literalPrefix } = radixMap.get(radix);\n\n                    context.report({\n                        node,\n                        messageId: \"useLiteral\",\n                        data: {\n                            system,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            if (sourceCode.getCommentsInside(node).length) {\n                                return null;\n                            }\n\n                            const replacement = `${literalPrefix}${str}`;\n\n                            if (+replacement !== parseInt(str, radix)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 *\n                                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                                 * so the autofix would be invalid:\n                                 *\n                                 *   parseInt(\"1_1\", 2) // === 1\n                                 *   0b1_1 // === 3\n                                 */\n                                return null;\n                            }\n\n                            const tokenBefore = sourceCode.getTokenBefore(node),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n                            let prefix = \"\",\n                                suffix = \"\";\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\n                            ) {\n                                suffix = \" \";\n                            }\n\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\nfunction isAccessorProperty(node) {\n    return node.type === \"Property\" &&\n        (node.kind === \"get\" || node.kind === \"set\");\n}\n\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\nfunction hasAccessors(node) {\n    return node.properties.some(isAccessorProperty);\n}\n\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\nfunction hasArgumentsWithAccessors(node) {\n    return node.arguments\n        .filter(arg => arg.type === \"ObjectExpression\")\n        .some(hasAccessors);\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n        yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        node.arguments.length >= 1 &&\n                        node.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(node) &&\n                        !(\n                            node.arguments.length > 1 &&\n                            hasArgumentsWithAccessors(node)\n                        )\n                    ) {\n                        const messageId = node.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(node, sourceCode);\n\n                        context.report({ node, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview restrict values that can be used as Promise rejection reasons\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using Error objects as Promise rejection reasons\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-promise-reject-errors\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyReject: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            rejectAnError: \"Expected the Promise rejection reason to be an Error.\"\n        }\n    },\n\n    create(context) {\n\n        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error\n         * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise\n         * @returns {void}\n         */\n        function checkRejectCall(callExpression) {\n            if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {\n                return;\n            }\n            if (\n                !callExpression.arguments.length ||\n                !astUtils.couldBeError(callExpression.arguments[0]) ||\n                callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\"\n            ) {\n                context.report({\n                    node: callExpression,\n                    messageId: \"rejectAnError\"\n                });\n            }\n        }\n\n        /**\n         * Determines whether a function call is a Promise.reject() call\n         * @param {ASTNode} node A CallExpression node\n         * @returns {boolean} `true` if the call is a Promise.reject() call\n         */\n        function isPromiseRejectCall(node) {\n            return astUtils.isSpecificMemberAccess(node.callee, \"Promise\", \"reject\");\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Check `Promise.reject(value)` calls.\n            CallExpression(node) {\n                if (isPromiseRejectCall(node)) {\n                    checkRejectCall(node);\n                }\n            },\n\n            /*\n             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.\n             * This function is run on \"NewExpression:exit\" instead of \"NewExpression\" to ensure that\n             * the nodes in the expression already have the `parent` property.\n             */\n            \"NewExpression:exit\"(node) {\n                if (\n                    node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" &&\n                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&\n                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\"\n                ) {\n                    context.getDeclaredVariables(node.arguments[0])\n\n                        /*\n                         * Find the first variable that matches the second parameter's name.\n                         * If the first parameter has the same name as the second parameter, then the variable will actually\n                         * be \"declared\" when the first parameter is evaluated, but then it will be immediately overwritten\n                         * by the second parameter. It's not possible for an expression with the variable to be evaluated before\n                         * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or\n                         * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for\n                         * this case.\n                         */\n                        .find(variable => variable.name === node.arguments[0].params[1].name)\n\n                        // Get the references to that variable.\n                        .references\n\n                        // Only check the references that read the parameter's value.\n                        .filter(ref => ref.isRead())\n\n                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.\n                        .filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee)\n\n                        // Check the argument of the function call to determine whether it's an Error.\n                        .forEach(ref => checkRejectCall(ref.identifier.parent));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-reflect\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [],\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            preferReflect: \"Avoid using {{existing}}, instead use {{substitute}}.\"\n        }\n    },\n\n    create(context) {\n        const existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        const reflectSubstitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        const exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report({\n                node,\n                messageId: \"preferReflect\",\n                data: {\n                    existing,\n                    substitute\n                }\n            });\n        }\n\n        return {\n            CallExpression(node) {\n                const methodName = (node.callee.property || {}).name;\n                const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                const hasReflectSubstitute = Object.prototype.hasOwnProperty.call(reflectSubstitutes, methodName);\n                const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubstitutes[methodName]);\n                }\n            },\n            UnaryExpression(node) {\n                const isDeleteOperator = node.operator === \"delete\";\n                const targetsIdentifier = node.argument.type === \"Identifier\";\n                const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n\n/**\n * Determines whether the given node is a template literal without expressions.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a template literal without expressions.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = context.getScope();\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n                        if (node.arguments.length === 2) {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExpWithFlags\" });\n                        } else {\n                            context.report({ node, messageId: \"unexpectedRedundantRegExp\" });\n                        }\n                    } else if (hasOnlyStaticStringArguments(node)) {\n                        context.report({ node, messageId: \"unexpectedRegExp\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks if the given reference is not normal member access.\n *\n * - arguments         .... true    // not member access\n * - arguments[i]      .... true    // computed member access\n * - arguments[0]      .... true    // computed member access\n * - arguments.length  .... false   // normal member access\n * @param {eslint-scope.Reference} reference The reference to check.\n * @returns {boolean} `true` if the reference is not normal member access.\n */\nfunction isNotNormalMemberAccess(reference) {\n    const id = reference.identifier;\n    const parent = id.parent;\n\n    return !(\n        parent.type === \"MemberExpression\" &&\n        parent.object === id &&\n        !parent.computed\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require rest parameters instead of `arguments`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-rest-params\"\n        },\n\n        schema: [],\n\n        messages: {\n            preferRestParams: \"Use the rest parameters instead of 'arguments'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            context.report({\n                node: reference.identifier,\n                loc: reference.identifier.loc,\n                messageId: \"preferRestParams\"\n            });\n        }\n\n        /**\n         * Reports references of the implicit `arguments` variable if exist.\n         * @returns {void}\n         */\n        function checkForArguments() {\n            const argumentsVar = getVariableOfArguments(context.getScope());\n\n            if (argumentsVar) {\n                argumentsVar\n                    .references\n                    .filter(isNotNormalMemberAccess)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            \"FunctionDeclaration:exit\": checkForArguments,\n            \"FunctionExpression:exit\": checkForArguments\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        astUtils.isSpecificMemberAccess(node.callee, null, \"apply\") &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\" &&\n        node.arguments[1].type !== \"SpreadElement\"\n    );\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis The node that is the owner of the applied function.\n * @param {ASTNode} thisArg The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return astUtils.equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-spread\"\n        },\n\n        schema: [],\n        fixable: null,\n\n        messages: {\n            preferSpread: \"Use the spread operator instead of '.apply()'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({\n                        node,\n                        messageId: \"preferSpread\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return (\n            hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||\n            hasOctalOrNonOctalDecimalEscapeSequence(node.right)\n        );\n    }\n\n    // No need to check TemplateLiterals – would throw parsing error\n    if (node.type === \"Literal\" && typeof node.value === \"string\") {\n        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    messageId: \"unexpectedStringConcatenation\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quote-props\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n        messages: {\n            requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n            inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n            unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n            unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n            unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n            unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n            redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n        }\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes removed\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes added\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessarilyQuotedProperty\",\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedReservedProperty\",\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n                context.report({\n                    node,\n                    messageId: \"unquotedNumericProperty\",\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    messageId: \"unquotedPropertyFound\",\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"redundantQuoting\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"requireQuotesDueToReservedWord\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        messageId: \"inconsistentlyQuotedProperty\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    const newQuote = this.quote;\n    const oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return `\\\\${match}`; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quotes\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            wrongQuotes: \"Strings must use {{description}}.\"\n        }\n    },\n\n    create(context) {\n\n        const quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.getSourceCode();\n        let avoidEscape = options && options.avoidEscape === true;\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         *\n         * This function returns `true` in the following cases:\n         *\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n         * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\n         *\n         * In particular, this function returns `false` in the following cases:\n         *\n         * - `<div className={\"foo\"}></div>`\n         * - `<div>{\"foo\"}</div>`\n         *\n         * In both cases, inside of the braces is handled as normal JavaScript.\n         * The braces are `JSXExpressionContainer` nodes.\n         * @param {ASTNode} node The Literal node to check.\n         * @returns {boolean} True if the node is a part of JSX, false if not.\n         * @private\n         */\n        function isJSXLiteral(node) {\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\"\n            );\n        }\n\n        /**\n         * Checks whether or not a given node is a part of directive prologues.\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\n         * @private\n         */\n        function isPartOfDirectivePrologue(node) {\n            const block = node.parent.parent;\n\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n                return false;\n            }\n\n            // Check the node is at a prologue.\n            for (let i = 0; i < block.body.length; ++i) {\n                const statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return isPartOfDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                case \"ExportAllDeclaration\":\n                    return parent.source === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\n         * @param {ASTNode} node A TemplateLiteral node to check.\n         * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\n         * @private\n         */\n        function isUsingFeatureOfTemplateLiteral(node) {\n            const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n\n            if (hasTag) {\n                return true;\n            }\n\n            const hasStringInterpolation = node.expressions.length > 0;\n\n            if (hasStringInterpolation) {\n                return true;\n            }\n\n            const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n            if (isMultilineString) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n\n            Literal(node) {\n                const val = node.value,\n                    rawVal = node.raw;\n\n                if (settings && typeof val === \"string\") {\n                    let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXLiteral(node) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node,\n                            messageId: \"wrongQuotes\",\n                            data: {\n                                description: settings.description\n                            },\n                            fix(fixer) {\n                                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\n\n                                    /*\n                                     * An octal or non-octal decimal escape sequence in a template literal would\n                                     * produce syntax error, even in non-strict mode.\n                                     */\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral(node) {\n\n                // Don't throw an error if backticks are expected or a template literal feature is in use.\n                if (\n                    allowTemplateLiterals ||\n                    quoteOption === \"backtick\" ||\n                    isUsingFeatureOfTemplateLiteral(node)\n                ) {\n                    return;\n                }\n\n                context.report({\n                    node,\n                    messageId: \"wrongQuotes\",\n                    data: {\n                        description: settings.description\n                    },\n                    fix(fixer) {\n                        if (isPartOfDirectivePrologue(node)) {\n\n                            /*\n                             * TemplateLiterals in a directive prologue aren't actually directives, but if they're\n                             * in the directive prologue, then fixing them might turn them into directives and change\n                             * the behavior of the code.\n                             */\n                            return null;\n                        }\n                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/radix\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ],\n\n        messages: {\n            missingParameters: \"Missing parameters.\",\n            redundantRadix: \"Redundant radix parameter.\",\n            missingRadix: \"Missing radix parameter.\",\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        messageId: \"missingParameters\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            messageId: \"missingRadix\"\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"redundantRadix\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"invalidRadix\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n                        const maybeCallee = node.parent.type === \"ChainExpression\"\n                            ? node.parent\n                            : node;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n                            checkArguments(maybeCallee.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariableNames = new Set();\n        const freshReadVariableNames = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);\n                info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariableNames, freshReadVariableNames });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {string} variableName The variable name to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variableName) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariableNames.add(variableName);\n\n                // If a variable is freshly read again, then it's no more out-dated.\n                info.outdatedReadVariableNames.delete(variableName);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariableNames` to `outdatedReadVariableNames`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);\n                info.freshReadVariableNames.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {string} variableName The variable name to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variableName) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariableNames.has(variableName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath) {\n                const scope = context.getScope();\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n            },\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { codePath, referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const name = reference.identifier.name;\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(codePath.currentSegments, name);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other closure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ← exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariableNames` list, report it.\n             */\n            \":expression:exit\"(node) {\n                const { codePath, referenceMap } = stack;\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(codePath.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const name = reference.identifier.name;\n\n                        if (segmentInfo.isOutdated(codePath.currentSegments, name)) {\n                            context.report({\n                                node: node.parent,\n                                messageId: \"nonAtomicUpdate\",\n                                data: {\n                                    value: sourceCode.getText(node.parent.left)\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow async functions which have no `await` expression.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Capitalize the 1st letter of the given text.\n * @param {string} text The text to capitalize.\n * @returns {string} The text that the 1st letter was capitalized.\n */\nfunction capitalizeFirstLetter(text) {\n    return text[0].toUpperCase() + text.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow async functions which have no `await` expression\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-await\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingAwait: \"{{name}} has no 'await' expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Push the scope info object to the stack.\n         * @returns {void}\n         */\n        function enterFunction() {\n            scopeInfo = {\n                upper: scopeInfo,\n                hasAwait: false\n            };\n        }\n\n        /**\n         * Pop the top scope info object from the stack.\n         * Also, it reports the function if needed.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (!node.generator && node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: \"missingAwait\",\n                    data: {\n                        name: capitalizeFirstLetter(\n                            astUtils.getFunctionNameWithKind(node)\n                        )\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            \"ArrowFunctionExpression:exit\": exitFunction,\n\n            AwaitExpression() {\n                if (!scopeInfo) {\n                    return;\n                }\n\n                scopeInfo.hasAwait = true;\n            },\n            ForOfStatement(node) {\n                if (!scopeInfo) {\n                    return;\n                }\n\n                if (node.await) {\n                    scopeInfo.hasAwait = true;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for jsdoc presence.\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require JSDoc comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    require: {\n                        type: \"object\",\n                        properties: {\n                            ClassDeclaration: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            MethodDefinition: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            FunctionDeclaration: {\n                                type: \"boolean\",\n                                default: true\n                            },\n                            ArrowFunctionExpression: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            FunctionExpression: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false,\n                        default: {}\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        deprecated: true,\n        replacedBy: [],\n\n        messages: {\n            missingJSDocComment: \"Missing JSDoc comment.\"\n        }\n    },\n\n    create(context) {\n        const source = context.getSourceCode();\n        const DEFAULT_OPTIONS = {\n            FunctionDeclaration: true,\n            MethodDefinition: false,\n            ClassDeclaration: false,\n            ArrowFunctionExpression: false,\n            FunctionExpression: false\n        };\n        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require);\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, messageId: \"missingJSDocComment\" });\n        }\n\n        /**\n         * Check if the jsdoc comment is present or not.\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkJsDoc(node) {\n            const jsdocComment = source.getJSDocComment(node);\n\n            if (!jsdocComment) {\n                report(node);\n            }\n        }\n\n        return {\n            FunctionDeclaration(node) {\n                if (options.FunctionDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            FunctionExpression(node) {\n                if (\n                    (options.MethodDefinition && node.parent.type === \"MethodDefinition\") ||\n                    (options.FunctionExpression && (node.parent.type === \"VariableDeclarator\" || (node.parent.type === \"Property\" && node === node.parent.value)))\n                ) {\n                    checkJsDoc(node);\n                }\n            },\n            ClassDeclaration(node) {\n                if (options.ClassDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            ArrowFunctionExpression(node) {\n                if (options.ArrowFunctionExpression && node.parent.type === \"VariableDeclarator\") {\n                    checkJsDoc(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce the use of `u` flag on RegExp.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of `u` flag on RegExp\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-unicode-regexp\"\n        },\n\n        messages: {\n            requireUFlag: \"Use the 'u' flag.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            \"Literal[regex]\"(node) {\n                const flags = node.regex.flags || \"\";\n\n                if (!flags.includes(\"u\")) {\n                    context.report({ node, messageId: \"requireUFlag\" });\n                }\n            },\n\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    const flagsNode = node.arguments[1];\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (!flagsNode || (typeof flags === \"string\" && !flags.includes(\"u\"))) {\n                        context.report({ node, messageId: \"requireUFlag\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag the generator functions that does not have yield.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require generator functions to contain `yield`\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/require-yield\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingYield: \"This generator function does not have 'yield'.\"\n        }\n    },\n\n    create(context) {\n        const stack = [];\n\n        /**\n         * If the node is a generator function, start counting `yield` keywords.\n         * @param {Node} node A function node to check.\n         * @returns {void}\n         */\n        function beginChecking(node) {\n            if (node.generator) {\n                stack.push(0);\n            }\n        }\n\n        /**\n         * If the node is a generator function, end counting `yield` keywords, then\n         * reports result.\n         * @param {Node} node A function node to check.\n         * @returns {void}\n         */\n        function endChecking(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const countYield = stack.pop();\n\n            if (countYield === 0 && node.body.body.length > 0) {\n                context.report({ node, messageId: \"missingYield\" });\n            }\n        }\n\n        return {\n            FunctionDeclaration: beginChecking,\n            \"FunctionDeclaration:exit\": endChecking,\n            FunctionExpression: beginChecking,\n            \"FunctionExpression:exit\": endChecking,\n\n            // Increases the count of `yield` keyword.\n            YieldExpression() {\n\n                /* istanbul ignore else */\n                if (stack.length > 0) {\n                    stack[stack.length - 1] += 1;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce spacing between rest and spread operators and their expressions.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce spacing between rest and spread operators and their expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/rest-spread-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        messages: {\n            unexpectedWhitespace: \"Unexpected whitespace after {{type}} operator.\",\n            expectedWhitespace: \"Expected whitespace after {{type}} operator.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            alwaysSpace = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whitespace between rest/spread operators and their expressions\n         * @param {ASTNode} node The node to check\n         * @returns {void}\n         */\n        function checkWhiteSpace(node) {\n            const operator = sourceCode.getFirstToken(node),\n                nextToken = sourceCode.getTokenAfter(operator),\n                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);\n            let type;\n\n            switch (node.type) {\n                case \"SpreadElement\":\n                    type = \"spread\";\n                    if (node.parent.type === \"ObjectExpression\") {\n                        type += \" property\";\n                    }\n                    break;\n                case \"RestElement\":\n                    type = \"rest\";\n                    if (node.parent.type === \"ObjectPattern\") {\n                        type += \" property\";\n                    }\n                    break;\n                case \"ExperimentalSpreadProperty\":\n                    type = \"spread property\";\n                    break;\n                case \"ExperimentalRestProperty\":\n                    type = \"rest property\";\n                    break;\n                default:\n                    return;\n            }\n\n            if (alwaysSpace && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: operator.loc,\n                    messageId: \"expectedWhitespace\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], \" \");\n                    }\n                });\n            } else if (!alwaysSpace && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        start: operator.loc.end,\n                        end: nextToken.loc.start\n                    },\n                    messageId: \"unexpectedWhitespace\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            SpreadElement: checkWhiteSpace,\n            RestElement: checkWhiteSpace,\n            ExperimentalSpreadProperty: checkWhiteSpace,\n            ExperimentalRestProperty: checkWhiteSpace\n        };\n    }\n};\n","/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\n            unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\n            missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\n            missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            requireSpaceBefore = config.before;\n            requireSpaceAfter = config.after;\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Report location example :\n         *\n         * for unexpected space `before`\n         *\n         * var a = 'b'   ;\n         *            ^^^\n         *\n         * for unexpected space `after`\n         *\n         * var a = 'b';  c = 10;\n         *             ^^\n         *\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        const tokenBefore = sourceCode.getTokenBefore(token);\n                        const loc = {\n                            start: tokenBefore.loc.end,\n                            end: token.loc.start\n                        };\n\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"unexpectedWhitespaceBefore\",\n                            fix(fixer) {\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        const loc = token.loc;\n\n                        context.report({\n                            node,\n                            loc,\n                            messageId: \"missingWhitespaceBefore\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            const tokenAfter = sourceCode.getTokenAfter(token);\n                            const loc = {\n                                start: token.loc.end,\n                                end: tokenAfter.loc.start\n                            };\n\n                            context.report({\n                                node,\n                                loc,\n                                messageId: \"unexpectedWhitespaceAfter\",\n                                fix(fixer) {\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            const loc = token.loc;\n\n                            context.report({\n                                node,\n                                loc,\n                                messageId: \"missingWhitespaceAfter\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            DoWhileStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${\n    [\n        \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n        \"DoWhileStatement\", \"ExportAllDeclaration\",\n        \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n        \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n        \"ThrowStatement\", \"VariableDeclaration\"\n    ].join(\",\")\n})`;\n\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n    const t = node.type;\n\n    if (t === \"BlockStatement\" || t === \"Program\") {\n        return node.body;\n    }\n    if (t === \"SwitchCase\") {\n        return node.consequent;\n    }\n    return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n    const t = node.parent.type;\n\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\n        return true;\n    }\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\n        return true;\n    }\n    const nodeList = getChildren(node.parent);\n\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce location of semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-style\"\n        },\n\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\",\n\n        messages: {\n            expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    messageId: \"expectedSemiColon\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                if (option === \"first\" && isLastChild(node)) {\n                    return;\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow semicolons instead of ASI\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                beforeStatementContinuationChars: {\n                                    enum: [\"always\", \"any\", \"never\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                omitLastInOneLineBlock: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            missingSemi: \"Missing semicolon.\",\n            extraSemi: \"Extra semicolon.\"\n        }\n    },\n\n    create(context) {\n\n        const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`\n        const options = context.options[1];\n        const never = context.options[0] === \"never\";\n        const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);\n        const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || \"any\";\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a semicolon error with appropriate location and message.\n         * @param {ASTNode} node The node with an extra or missing semicolon.\n         * @param {boolean} missing True if the semicolon is missing.\n         * @returns {void}\n         */\n        function report(node, missing) {\n            const lastToken = sourceCode.getLastToken(node);\n            let messageId,\n                fix,\n                loc;\n\n            if (!missing) {\n                messageId = \"missingSemi\";\n                loc = {\n                    start: lastToken.loc.end,\n                    end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)\n                };\n                fix = function(fixer) {\n                    return fixer.insertTextAfter(lastToken, \";\");\n                };\n            } else {\n                messageId = \"extraSemi\";\n                loc = lastToken.loc;\n                fix = function(fixer) {\n\n                    /*\n                     * Expand the replacement range to include the surrounding\n                     * tokens to avoid conflicting with no-extra-semi.\n                     * https://github.com/eslint/eslint/issues/7928\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainSurroundingTokens(lastToken)\n                        .remove(lastToken);\n                };\n            }\n\n            context.report({\n                node,\n                loc,\n                messageId,\n                fix\n            });\n\n        }\n\n        /**\n         * Check whether a given semicolon token is redundant.\n         * @param {Token} semiToken A semicolon token to check.\n         * @returns {boolean} `true` if the next token is `;` or `}`.\n         */\n        function isRedundantSemi(semiToken) {\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n\n            return (\n                !nextToken ||\n                astUtils.isClosingBraceToken(nextToken) ||\n                astUtils.isSemicolonToken(nextToken)\n            );\n        }\n\n        /**\n         * Check whether a given token is the closing brace of an arrow function.\n         * @param {Token} lastToken A token to check.\n         * @returns {boolean} `true` if the token is the closing brace of an arrow function.\n         */\n        function isEndOfArrowBlock(lastToken) {\n            if (!astUtils.isClosingBraceToken(lastToken)) {\n                return false;\n            }\n            const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);\n\n            return (\n                node.type === \"BlockStatement\" &&\n                node.parent.type === \"ArrowFunctionExpression\"\n            );\n        }\n\n        /**\n         * Check whether a given node is on the same line with the next token.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} `true` if the node is on the same line with the next token.\n         */\n        function isOnSameLineWithNextToken(node) {\n            const prevToken = sourceCode.getLastToken(node, 1);\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);\n        }\n\n        /**\n         * Check whether a given node can connect the next line if the next line is unreliable.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} `true` if the node can connect the next line.\n         */\n        function maybeAsiHazardAfter(node) {\n            const t = node.type;\n\n            if (t === \"DoWhileStatement\" ||\n                t === \"BreakStatement\" ||\n                t === \"ContinueStatement\" ||\n                t === \"DebuggerStatement\" ||\n                t === \"ImportDeclaration\" ||\n                t === \"ExportAllDeclaration\"\n            ) {\n                return false;\n            }\n            if (t === \"ReturnStatement\") {\n                return Boolean(node.argument);\n            }\n            if (t === \"ExportNamedDeclaration\") {\n                return Boolean(node.declaration);\n            }\n            if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Check whether a given token can connect the previous statement.\n         * @param {Token} token A token to check.\n         * @returns {boolean} `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.\n         */\n        function maybeAsiHazardBefore(token) {\n            return (\n                Boolean(token) &&\n                OPT_OUT_PATTERN.test(token.value) &&\n                token.value !== \"++\" &&\n                token.value !== \"--\"\n            );\n        }\n\n        /**\n         * Check if the semicolon of a given node is unnecessary, only true if:\n         *   - next token is a valid statement divider (`;` or `}`).\n         *   - next token is on a new line and the node is not connectable to the new line.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} whether the semicolon is unnecessary.\n         */\n        function canRemoveSemicolon(node) {\n            if (isRedundantSemi(sourceCode.getLastToken(node))) {\n                return true; // `;;` or `;}`\n            }\n            if (isOnSameLineWithNextToken(node)) {\n                return false; // One liner.\n            }\n            if (beforeStatementContinuationChars === \"never\" && !maybeAsiHazardAfter(node)) {\n                return true; // ASI works. This statement doesn't connect to the next.\n            }\n            if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n                return true; // ASI works. The next token doesn't connect to this statement.\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks a node to see if it's in a one-liner block statement.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is in a one-liner block statement.\n         */\n        function isOneLinerBlock(node) {\n            const parent = node.parent;\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (!nextToken || nextToken.value !== \"}\") {\n                return false;\n            }\n            return (\n                !!parent &&\n                parent.type === \"BlockStatement\" &&\n                parent.loc.start.line === parent.loc.end.line\n            );\n        }\n\n        /**\n         * Checks a node to see if it's followed by a semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolon(node) {\n            const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));\n\n            if (never) {\n                if (isSemi && canRemoveSemicolon(node)) {\n                    report(node, true);\n                } else if (!isSemi && beforeStatementContinuationChars === \"always\" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n                    report(node);\n                }\n            } else {\n                const oneLinerBlock = (exceptOneLine && isOneLinerBlock(node));\n\n                if (isSemi && oneLinerBlock) {\n                    report(node, true);\n                } else if (!isSemi && !oneLinerBlock) {\n                    report(node);\n                }\n            }\n        }\n\n        /**\n         * Checks to see if there's a semicolon after a variable declaration.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolonForVariableDeclaration(node) {\n            const parent = node.parent;\n\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n                (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)\n            ) {\n                checkForSemicolon(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\n            ExpressionStatement: checkForSemicolon,\n            ReturnStatement: checkForSemicolon,\n            ThrowStatement: checkForSemicolon,\n            DoWhileStatement: checkForSemicolon,\n            DebuggerStatement: checkForSemicolon,\n            BreakStatement: checkForSemicolon,\n            ContinueStatement: checkForSemicolon,\n            ImportDeclaration: checkForSemicolon,\n            ExportAllDeclaration: checkForSemicolon,\n            ExportNamedDeclaration(node) {\n                if (!node.declaration) {\n                    checkForSemicolon(node);\n                }\n            },\n            ExportDefaultDeclaration(node) {\n                if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {\n                    checkForSemicolon(node);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSeparatedGroups: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n            sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n            unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n        }\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        /**\n         * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n         * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n         * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n         * on two consecutive lines.\n         * @param {ASTNode} left node that appears before the given `right` node.\n         * @param {ASTNode} right node that appears after the given `left` node.\n         * @returns {number} number of lines between nodes.\n         */\n        function getNumberOfLinesBetween(left, right) {\n            return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (\n                        previousDeclaration &&\n                        allowSeparatedGroups &&\n                        getNumberOfLinesBetween(previousDeclaration, node) > 0\n                    ) {\n\n                        // reset declaration sort\n                        previousDeclaration = null;\n                    }\n\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    messageId: \"unexpectedSyntaxOrder\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    messageId: \"sortImportsAlphabetically\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            messageId: \"sortMembersAlphabetically\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n * @param {ASTNode} node The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    const staticName = astUtils.getStaticPropertyName(node);\n\n    if (staticName !== null) {\n        return staticName;\n    }\n\n    return node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natural.\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require object keys to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-keys\"\n        },\n\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    natural: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    minKeys: {\n                        type: \"integer\",\n                        minimum: 2,\n                        default: 2\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n        }\n    },\n\n    create(context) {\n\n        // Parse options.\n        const order = context.options[0] || \"asc\";\n        const options = context.options[1];\n        const insensitive = options && options.caseSensitive === false;\n        const natural = options && options.natural;\n        const minKeys = options && options.minKeys;\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n\n        return {\n            ObjectExpression(node) {\n                stack = {\n                    upper: stack,\n                    prevName: null,\n                    numKeys: node.properties.length\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            SpreadElement(node) {\n                if (node.parent.type === \"ObjectExpression\") {\n                    stack.prevName = null;\n                }\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const numKeys = stack.numKeys;\n                const thisName = getPropertyName(node);\n\n                if (thisName !== null) {\n                    stack.prevName = thisName;\n                }\n\n                if (prevName === null || thisName === null || numKeys < minKeys) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        messageId: \"sortKeys\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natural: natural ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-vars\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n        }\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            sourceCode = context.getSourceCode();\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n                let fixed = false;\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    const lastVariableName = getSortableName(memo),\n                        currentVariableName = getSortableName(decl);\n\n                    if (currentVariableName < lastVariableName) {\n                        context.report({\n                            node: decl,\n                            messageId: \"sortVars\",\n                            fix(fixer) {\n                                if (unfixable || fixed) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange(\n                                    [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],\n                                    idDeclarations\n\n                                        // Clone the idDeclarations array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((declA, declB) => {\n                                            const aName = getSortableName(declA);\n                                            const bName = getSortableName(declB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\n                                        .reduce((sourceText, identifier, index) => {\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                                        }, \"\")\n\n                                );\n                            }\n                        });\n                        fixed = true;\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents the body of a function.\n * @param {ASTNode} node the node to check.\n * @returns {boolean} `true` if the node is function body.\n */\nfunction isFunctionBody(node) {\n    const parent = node.parent;\n\n    return (\n        node.type === \"BlockStatement\" &&\n        astUtils.isFunction(parent) &&\n        parent.body === node\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedSpace: \"Unexpected space before opening brace.\",\n            missingSpace: \"Missing space before opening brace.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let alwaysFunctions = true,\n            alwaysKeywords = true,\n            alwaysClasses = true,\n            neverFunctions = false,\n            neverKeywords = false,\n            neverClasses = false;\n\n        if (typeof config === \"object\") {\n            alwaysFunctions = config.functions === \"always\";\n            alwaysKeywords = config.keywords === \"always\";\n            alwaysClasses = config.classes === \"always\";\n            neverFunctions = config.functions === \"never\";\n            neverKeywords = config.keywords === \"never\";\n            neverClasses = config.classes === \"never\";\n        } else if (config === \"never\") {\n            alwaysFunctions = false;\n            alwaysKeywords = false;\n            alwaysClasses = false;\n            neverFunctions = true;\n            neverKeywords = true;\n            neverClasses = true;\n        }\n\n        /**\n         * Checks whether the spacing before the given block is already controlled by another rule:\n         * - `arrow-spacing` checks spaces after `=>`.\n         * - `keyword-spacing` checks spaces after keywords in certain contexts.\n         * @param {Token} precedingToken first token before the block.\n         * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\n         * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\n         */\n        function isConflicted(precedingToken, node) {\n            return astUtils.isArrowToken(precedingToken) ||\n                astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node);\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                let requireSpace;\n                let requireNoSpace;\n\n                if (isFunctionBody(node)) {\n                    requireSpace = alwaysFunctions;\n                    requireNoSpace = neverFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = alwaysClasses;\n                    requireNoSpace = neverClasses;\n                } else {\n                    requireSpace = alwaysKeywords;\n                    requireNoSpace = neverKeywords;\n                }\n\n                if (requireSpace && !hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"missingSpace\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                    });\n                } else if (requireNoSpace && hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedSpace\",\n                        fix(fixer) {\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedSpace: \"Unexpected space before function parentheses.\",\n            missingSpace: \"Missing space before function parentheses.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n                    return overrideConfig.asyncArrow || baseConfig;\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: {\n                        start: leftToken.loc.end,\n                        end: rightToken.loc.start\n                    },\n                    messageId: \"unexpectedSpace\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(rightToken);\n\n                        // Don't fix anything if there's a single line comment between the left and the right token\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange(\n                            [leftToken.range[1], rightToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: rightToken.loc,\n                    messageId: \"missingSpace\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-in-parens\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingOpeningSpace: \"There must be a space after this paren.\",\n            missingClosingSpace: \"There must be a space before this paren.\",\n            rejectedOpeningSpace: \"There should be no space after this paren.\",\n            rejectedClosingSpace: \"There should be no space before this paren.\"\n        }\n    },\n\n    create(context) {\n        const ALWAYS = context.options[0] === \"always\",\n            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],\n            options = {};\n\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.includes(\"{}\");\n            options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n            options.parenException = exceptionsArrayOptions.includes(\"()\");\n            options.empty = exceptionsArrayOptions.includes(\"empty\");\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return exceptions.openers.includes(token.value);\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return exceptions.closers.includes(token.value);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a required space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren is missing a required space\n         */\n        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isOpenerException(tokenAfterOpeningParen);\n            }\n            return isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if an opening paren is immediately followed by a disallowed space\n         * @param {Object} openingParenToken The paren token\n         * @param {Object} tokenAfterOpeningParen The token after it\n         * @returns {boolean} True if the opening paren has a disallowed space\n         */\n        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n            if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (tokenAfterOpeningParen.type === \"Line\") {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(tokenAfterOpeningParen);\n            }\n            return !isOpenerException(tokenAfterOpeningParen);\n        }\n\n        /**\n         * Determines if a closing paren is immediately preceded by a required space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren is missing a required space\n         */\n        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(tokenBeforeClosingParen);\n            }\n            return isCloserException(tokenBeforeClosingParen);\n        }\n\n        /**\n         * Determines if a closer paren is immediately preceded by a disallowed space\n         * @param {Object} tokenBeforeClosingParen The token before the paren\n         * @param {Object} closingParenToken The paren token\n         * @returns {boolean} True if the closing paren has a disallowed space\n         */\n        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n            if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(tokenBeforeClosingParen);\n            }\n            return !isCloserException(tokenBeforeClosingParen);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    // if token is not an opening or closing paren token, do nothing\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    // if token is an opening paren and is not followed by a required space\n                    if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is an opening paren and is followed by a disallowed space\n                    if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: { start: token.loc.end, end: nextToken.loc.start },\n                            messageId: \"rejectedOpeningSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is not preceded by a required space\n                    if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc,\n                            messageId: \"missingClosingSpace\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n\n                    // if token is a closing paren and is preceded by a disallowed space\n                    if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: { start: prevToken.loc.end, end: token.loc.start },\n                            messageId: \"rejectedClosingSpace\",\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require spacing around infix operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-infix-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingSpace: \"Operator '{{operator}}' must be spaced.\"\n        }\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left The left node of the main node\n         * @param {ASTNode} right The right node of the main node\n         * @param {string} op The operator of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right, op) {\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n            const prev = sourceCode.getTokenBefore(operator);\n            const next = sourceCode.getTokenAfter(operator);\n\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n                return operator;\n            }\n\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode The node to report\n         * @param {Object} culpritToken The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc,\n                messageId: \"missingSpace\",\n                data: {\n                    operator: culpritToken.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            // search for = in AssignmentPattern nodes\n            const operator = node.operator || \"=\";\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n            if (nonSpacedConsequentNode) {\n                report(node, nonSpacedConsequentNode);\n            }\n\n            if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar\n        };\n\n    }\n};\n","/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n","/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${lodash.escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n            expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n            unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n            unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n            expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n            expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n                hasExceptions: exceptions.length > 0,\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n                markers: new Set(markers)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {Array} match An array of match results for markers.\n         * @param {string} refChar Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, messageId, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                messageId,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {string} match An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, messageId, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                messageId\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments and comments that consist only of a marker.\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.captureMarker.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"expectedSpaceBefore\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n * @param {ASTNode} node A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n * @param {ASTNode[]} params A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow strict mode directives\",\n            category: \"Strict Mode\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/strict\"\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            function: \"Use the function form of 'use strict'.\",\n            global: \"Use the global form of 'use strict'.\",\n            multiple: \"Multiple 'use strict' directives.\",\n            never: \"Strict mode is not permitted.\",\n            unnecessary: \"Unnecessary 'use strict' directive.\",\n            module: \"'use strict' is unnecessary inside of modules.\",\n            implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n            unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n            nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n            wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n        }\n    },\n\n    create(context) {\n\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let mode = context.options[0] || \"safe\";\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n        }\n\n        /**\n         * Determines whether a reported error should be fixed, depending on the error type.\n         * @param {string} errorType The type of error\n         * @returns {boolean} `true` if the reported error should be fixed\n         */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n         * Gets a fixer function to remove a given 'use strict' directive.\n         * @param {ASTNode} node The directive that should be removed\n         * @returns {Function} A fixer function\n         */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} messageId Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, messageId, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, messageId, fix) {\n            reportSlice(nodes, 0, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, messageId, fix) {\n            reportSlice(nodes, 1, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessary\", fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessaryInClasses\", fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, messageId: \"function\" });\n                } else {\n                    context.report({\n                        node,\n                        messageId: \"wrap\",\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, messageId: \"global\" });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                } else {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing around colons of switch statements.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce spacing around colons of switch statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/switch-colon-spacing\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: false },\n                    after: { type: \"boolean\", default: true }\n                },\n                additionalProperties: false\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expectedBefore: \"Expected space(s) before this colon.\",\n            expectedAfter: \"Expected space(s) after this colon.\",\n            unexpectedBefore: \"Unexpected space(s) before this colon.\",\n            unexpectedAfter: \"Unexpected space(s) after this colon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const beforeSpacing = options.before === true; // false by default\n        const afterSpacing = options.after !== false; // true by default\n\n        /**\n         * Get the colon token of the given SwitchCase node.\n         * @param {ASTNode} node The SwitchCase node to get.\n         * @returns {Token} The colon token of the node.\n         */\n        function getColonToken(node) {\n            if (node.test) {\n                return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n            }\n            return sourceCode.getFirstToken(node, 1);\n        }\n\n        /**\n         * Check whether the spacing between the given 2 tokens is valid or not.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @param {boolean} expected The expected spacing to check. `true` if there should be a space.\n         * @returns {boolean} `true` if the spacing between the tokens is valid.\n         */\n        function isValidSpacing(left, right, expected) {\n            return (\n                astUtils.isClosingBraceToken(right) ||\n                !astUtils.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === expected\n            );\n        }\n\n        /**\n         * Check whether comments exist between the given 2 tokens.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @returns {boolean} `true` if comments exist between the given 2 tokens.\n         */\n        function commentsExistBetween(left, right) {\n            return sourceCode.getFirstTokenBetween(\n                left,\n                right,\n                {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                }\n            ) !== null;\n        }\n\n        /**\n         * Fix the spacing between the given 2 tokens.\n         * @param {RuleFixer} fixer The fixer to fix.\n         * @param {Token} left The left token of fix range.\n         * @param {Token} right The right token of fix range.\n         * @param {boolean} spacing The spacing style. `true` if there should be a space.\n         * @returns {Fix|null} The fix object.\n         */\n        function fix(fixer, left, right, spacing) {\n            if (commentsExistBetween(left, right)) {\n                return null;\n            }\n            if (spacing) {\n                return fixer.insertTextAfter(left, \" \");\n            }\n            return fixer.removeRange([left.range[1], right.range[0]]);\n        }\n\n        return {\n            SwitchCase(node) {\n                const colonToken = getColonToken(node);\n                const beforeToken = sourceCode.getTokenBefore(colonToken);\n                const afterToken = sourceCode.getTokenAfter(colonToken);\n\n                if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: beforeSpacing ? \"expectedBefore\" : \"unexpectedBefore\",\n                        fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n                    });\n                }\n                if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: afterSpacing ? \"expectedAfter\" : \"unexpectedAfter\",\n                        fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce description with the `Symbol` object\n * @author Jarek Rencz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require symbol descriptions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/symbol-description\"\n        },\n        fixable: null,\n        schema: [],\n        messages: {\n            expected: \"Expected Symbol to have a description.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports if node does not conform the rule in case rule is set to\n         * report missing description\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArgument(node) {\n            if (node.arguments.length === 0) {\n                context.report({\n                    node,\n                    messageId: \"expected\"\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const variable = astUtils.getVariableByName(scope, \"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArgument(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing around embedded expressions of template strings\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing around embedded expressions of template strings\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/template-curly-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before '}'.\",\n            expectedAfter: \"Expected space(s) after '${'.\",\n            unexpectedBefore: \"Unexpected space(s) before '}'.\",\n            unexpectedAfter: \"Unexpected space(s) after '${'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const always = context.options[0] === \"always\";\n\n        /**\n         * Checks spacing before `}` of a given token.\n         * @param {Token} token A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token) {\n            if (!token.value.startsWith(\"}\")) {\n                return; // starts with a backtick, this is the first template element in the template literal\n            }\n\n            const prevToken = sourceCode.getTokenBefore(token, { includeComments: true }),\n                hasSpace = sourceCode.isSpaceBetween(prevToken, token);\n\n            if (!astUtils.isTokenOnSameLine(prevToken, token)) {\n                return;\n            }\n\n            if (always && !hasSpace) {\n                context.report({\n                    loc: {\n                        start: token.loc.start,\n                        end: {\n                            line: token.loc.start.line,\n                            column: token.loc.start.column + 1\n                        }\n                    },\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(token, \" \")\n                });\n            }\n\n            if (!always && hasSpace) {\n                context.report({\n                    loc: {\n                        start: prevToken.loc.end,\n                        end: token.loc.start\n                    },\n                    messageId: \"unexpectedBefore\",\n                    fix: fixer => fixer.removeRange([prevToken.range[1], token.range[0]])\n                });\n            }\n        }\n\n        /**\n         * Checks spacing after `${` of a given token.\n         * @param {Token} token A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token) {\n            if (!token.value.endsWith(\"${\")) {\n                return; // ends with a backtick, this is the last template element in the template literal\n            }\n\n            const nextToken = sourceCode.getTokenAfter(token, { includeComments: true }),\n                hasSpace = sourceCode.isSpaceBetween(token, nextToken);\n\n            if (!astUtils.isTokenOnSameLine(token, nextToken)) {\n                return;\n            }\n\n            if (always && !hasSpace) {\n                context.report({\n                    loc: {\n                        start: {\n                            line: token.loc.end.line,\n                            column: token.loc.end.column - 2\n                        },\n                        end: token.loc.end\n                    },\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(token, \" \")\n                });\n            }\n\n            if (!always && hasSpace) {\n                context.report({\n                    loc: {\n                        start: token.loc.end,\n                        end: nextToken.loc.start\n                    },\n                    messageId: \"unexpectedAfter\",\n                    fix: fixer => fixer.removeRange([token.range[1], nextToken.range[0]])\n                });\n            }\n        }\n\n        return {\n            TemplateElement(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                checkSpacingBefore(token);\n                checkSpacingAfter(token);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check spacing between template tags and their literals\n * @author Jonathan Wilsson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing between template tags and their literals\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/template-tag-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n        messages: {\n            unexpected: \"Unexpected space between template tag and template literal.\",\n            missing: \"Missing space between template tag and template literal.\"\n        }\n    },\n\n    create(context) {\n        const never = context.options[0] !== \"always\";\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if a space is present between a template tag and its literal\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const tagToken = sourceCode.getTokenBefore(node.quasi);\n            const literalToken = sourceCode.getFirstToken(node.quasi);\n            const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        start: tagToken.loc.end,\n                        end: literalToken.loc.start\n                    },\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(node.quasi);\n\n                        // Don't fix anything if there's a single line comment after the template tag\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange(\n                            [tagToken.range[1], literalToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        start: node.loc.start,\n                        end: literalToken.loc.start\n                    },\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(tagToken, \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            TaggedTemplateExpression: checkSpacing\n        };\n    }\n};\n","/**\n * @fileoverview Require or disallow Unicode BOM\n * @author Andrew Johnston <https://github.com/ehjay>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow Unicode byte order mark (BOM)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/unicode-bom\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected Unicode BOM (Byte Order Mark).\",\n            unexpected: \"Unexpected Unicode BOM (Byte Order Mark).\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkUnicodeBOM(node) {\n\n                const sourceCode = context.getSourceCode(),\n                    location = { column: 0, line: 1 },\n                    requireBOM = context.options[0] || \"never\";\n\n                if (!sourceCode.hasBOM && (requireBOM === \"always\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"expected\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange([0, 1], \"\\uFEFF\");\n                        }\n                    });\n                } else if (sourceCode.hasBOM && (requireBOM === \"never\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            return fixer.removeRange([-1, 0]);\n                        }\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n    return Boolean(node) && node.type === \"Identifier\" && node.name === \"NaN\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/use-isnan\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForSwitchCase: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    enforceForIndexOf: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n        }\n    },\n\n    create(context) {\n\n        const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n\n        /**\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkBinaryExpression(node) {\n            if (\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\n            ) {\n                context.report({ node, messageId: \"comparisonWithNaN\" });\n            }\n        }\n\n        /**\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkSwitchStatement(node) {\n            if (isNaNIdentifier(node.discriminant)) {\n                context.report({ node, messageId: \"switchNaN\" });\n            }\n\n            for (const switchCase of node.cases) {\n                if (isNaNIdentifier(switchCase.test)) {\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\n                }\n            }\n        }\n\n        /**\n         * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkCallExpression(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                const methodName = astUtils.getStaticPropertyName(callee);\n\n                if (\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\n                    node.arguments.length === 1 &&\n                    isNaNIdentifier(node.arguments[0])\n                ) {\n                    context.report({ node, messageId: \"indexOfNaN\", data: { methodName } });\n                }\n            }\n        }\n\n        const listeners = {\n            BinaryExpression: checkBinaryExpression\n        };\n\n        if (enforceForSwitchCase) {\n            listeners.SwitchStatement = checkSwitchStatement;\n        }\n\n        if (enforceForIndexOf) {\n            listeners.CallExpression = checkCallExpression;\n        }\n\n        return listeners;\n    }\n};\n","/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamType: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n            use: \"Use @{{name}} instead.\",\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n            syntaxError: \"JSDoc syntax error.\",\n            missingBrace: \"JSDoc type missing brace.\",\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n            missingReturnType: \"Missing JSDoc return type.\",\n            missingReturnDesc: \"Missing JSDoc return description.\",\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n        },\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            requireParamType = options.requireParamType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node) || node.async\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n         * the expected name of the annotation\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type;\n            } else if (type.expression) {\n                currentType = type.expression;\n            }\n\n            return {\n                currentType,\n                expectedTypeName: currentType && preferType[currentType.name]\n            };\n        }\n\n        /**\n         * Gets the location of a JSDoc node in a file\n         * @param {Token} jsdocComment The comment that this node is parsed from\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n         */\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n            return {\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedTypeName &&\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n                    context.report({\n                        node: jsdocNode,\n                        messageId: \"useType\",\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n                        data: {\n                            currentTypeName: typeToCheck.currentType.name,\n                            expectedTypeName: typeToCheck.expectedTypeName\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\n                                typeToCheck.expectedTypeName\n                            );\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                paramTagsByName = Object.create(null),\n                paramTags = [];\n            let hasReturns = false,\n                returnsTag,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true,\n                        range: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/iu.test(ex.message)) {\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\n                    } else {\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            paramTags.push(tag);\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n                            returnsTag = tag;\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"use\",\n                            loc: {\n                                start: entireTagRange.start,\n                                end: {\n                                    line: entireTagRange.start.line,\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\n                                }\n                            },\n                            data: { name: prefer[tag.title] },\n                            fix(fixer) {\n                                return fixer.replaceTextRange(\n                                    [\n                                        jsdocNode.range[0] + tag.range[0] + 3,\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\n                                    ],\n                                    prefer[tag.title]\n                                );\n                            }\n                        });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                paramTags.forEach(param => {\n                    if (requireParamType && !param.type) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamType\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (!param.description && requireParamDescription) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamDesc\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (paramTagsByName[param.name]) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"duplicateParam\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    } else if (param.name.indexOf(\".\") === -1) {\n                        paramTagsByName[param.name] = param;\n                    }\n                });\n\n                if (hasReturns) {\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"unexpectedTag\",\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\n                            data: {\n                                title: returnsTag.title\n                            }\n                        });\n                    } else {\n                        if (requireReturnType && !returnsTag.type) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\n                        }\n\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\n                        }\n                    }\n                }\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingReturn\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParamNames = Object.keys(paramTagsByName);\n\n                if (node.params) {\n                    node.params.forEach((param, paramsIndex) => {\n                        const bindingParam = param.type === \"AssignmentPattern\"\n                            ? param.left\n                            : param;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (bindingParam.type === \"Identifier\") {\n                            const name = bindingParam.name;\n\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"expected\",\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParamNames[paramsIndex]\n                                    }\n                                });\n                            } else if (!paramTagsByName[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"missingParam\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription, \"u\");\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n","/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\"\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `var` declarations be placed at the top of their containing scope\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/vars-on-top\"\n        },\n\n        schema: [],\n        messages: {\n            top: \"All 'var' declarations must be at the top of the function scope.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // eslint-disable-next-line jsdoc/require-description\n        /**\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         * @param {ASTNode} node any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // skip over directives\n            for (; i < l; ++i) {\n                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                    break;\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} parent Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} parent Parent of the node\n         * @param {ASTNode} grandParent Parent of the node's parent\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node, parent, grandParent) {\n            if (!(/Function/u.test(grandParent.type) &&\n                    parent.type === \"BlockStatement\" &&\n                    isVarOnTop(node, parent.body))) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration[kind='var']\"(node) {\n                if (node.parent.type === \"ExportNamedDeclaration\") {\n                    globalVarCheck(node.parent, node.parent.parent);\n                } else if (node.parent.type === \"Program\") {\n                    globalVarCheck(node, node.parent);\n                } else {\n                    blockScopeVarCheck(node, node.parent, node.parent.parent);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\n//----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\nfunction isCalleeOfNewExpression(node) {\n    const maybeCallee = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n\n    return (\n        maybeCallee.parent.type === \"NewExpression\" &&\n        maybeCallee.parent.callee === maybeCallee\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in any parens\n         * @private\n         */\n        function isWrappedInAnyParens(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in grouping parens\n         * @private\n         */\n        function isWrappedInGroupingParens(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const isCallExpressionWrapped = isWrappedInAnyParens(node),\n                    isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n                if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            // The outer call expression will always be wrapped at this point.\n\n                            if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n\n                                /*\n                                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                                 * Replace the range between the end of the function expression and the end of the call expression.\n                                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                                 */\n\n                                const parenAfter = sourceCode.getTokenAfter(node);\n\n                                return fixer.replaceTextRange(\n                                    [innerNode.range[1], parenAfter.range[1]],\n                                    `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                                );\n                            }\n\n                            /*\n                             * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n                             * These parens cannot be removed, so just parenthesize the function expression.\n                             */\n\n                            return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n                        }\n                    });\n                } else if (style === \"outside\" && !isCallExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when regex literals are not wrapped in parens\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parenthesis around regex literals\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-regex\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            requireParens: \"Wrap the regexp literal in parens to disambiguate the slash.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node),\n                    nodeType = token.type;\n\n                if (nodeType === \"RegularExpression\") {\n                    const beforeToken = sourceCode.getTokenBefore(node);\n                    const afterToken = sourceCode.getTokenAfter(node);\n                    const ancestors = context.getAncestors();\n                    const grandparent = ancestors[ancestors.length - 1];\n\n                    if (grandparent.type === \"MemberExpression\" && grandparent.object === node &&\n                        !(beforeToken && beforeToken.value === \"(\" && afterToken && afterToken.value === \")\")) {\n                        context.report({\n                            node,\n                            messageId: \"requireParens\",\n                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check the spacing around the * in yield* expressions.\n * @author Bryan Smith\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing around the `*` in `yield*` expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yield-star-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            missingBefore: \"Missing space before *.\",\n            missingAfter: \"Missing space after *.\",\n            unexpectedBefore: \"Unexpected space before *.\",\n            unexpectedAfter: \"Unexpected space after *.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const mode = (function(option) {\n            if (!option || typeof option === \"string\") {\n                return {\n                    before: { before: true, after: false },\n                    after: { before: false, after: true },\n                    both: { before: true, after: true },\n                    neither: { before: false, after: false }\n                }[option || \"after\"];\n            }\n            return option;\n        }(context.options[0]));\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(side, leftToken, rightToken) {\n            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = mode[side];\n                const node = after ? leftToken : rightToken;\n                let messageId = \"\";\n\n                if (spaceRequired) {\n                    messageId = side === \"before\" ? \"missingBefore\" : \"missingAfter\";\n                } else {\n                    messageId = side === \"before\" ? \"unexpectedBefore\" : \"unexpectedAfter\";\n                }\n\n                context.report({\n                    node,\n                    messageId,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a yield* expression.\n         * @param {ASTNode} node A yield expression node.\n         * @returns {void}\n         */\n        function checkExpression(node) {\n            if (!node.delegate) {\n                return;\n            }\n\n            const tokens = sourceCode.getFirstTokens(node, 3);\n            const yieldToken = tokens[0];\n            const starToken = tokens[1];\n            const nextToken = tokens[2];\n\n            checkSpacing(\"before\", yieldToken, starToken);\n            checkSpacing(\"after\", starToken, nextToken);\n        }\n\n        return {\n            YieldExpression: checkExpression\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n    return (\n        node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        astUtils.isNumericLiteral(node.argument)\n    );\n}\n\n/**\n * Determines whether a node is a Template Literal which can be determined statically.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node is a Template Literal without expression.\n */\nfunction isStaticTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (isNegativeNumericLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (isStaticTemplateLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: node.quasis[0].value.cooked,\n            raw: node.quasis[0].value.raw\n        };\n    }\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: 'require or disallow \"Yoda\" conditions',\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected:\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = context.options[0] === \"always\";\n        const exceptRange =\n            context.options[1] && context.options[1].exceptRange;\n        const onlyEquality =\n            context.options[1] && context.options[1].onlyEquality;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n                    const leftLiteral = getNormalizedLiteral(left.left);\n                    const rightLiteral = getNormalizedLiteral(right.right);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n                    const leftLiteral = getNormalizedLiteral(left.right);\n                    const rightLiteral = getNormalizedLiteral(right.left);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (\n                node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped()\n            );\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n\n            const source = sourceCode.getText();\n\n            const leftText = source.slice(\n                node.range[0],\n                lastLeftToken.range[1]\n            );\n            const textBeforeOperator = source.slice(\n                lastLeftToken.range[1],\n                operatorToken.range[0]\n            );\n            const textAfterOperator = source.slice(\n                operatorToken.range[1],\n                firstRightToken.range[0]\n            );\n            const rightText = source.slice(\n                firstRightToken.range[0],\n                node.range[1]\n            );\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n            let prefix = \"\";\n            let suffix = \"\";\n\n            if (\n                tokenBefore &&\n                tokenBefore.range[1] === node.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\n            ) {\n                prefix = \" \";\n            }\n\n            if (\n                tokenAfter &&\n                node.range[1] === tokenAfter.range[0] &&\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\n            ) {\n                suffix = \" \";\n            }\n\n            return (\n                prefix +\n                rightText +\n                textBeforeOperator +\n                OPERATOR_FLIP_MAP[operatorToken.value] +\n                textAfterOperator +\n                leftText +\n                suffix\n            );\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedNonLiteral)) &&\n                    !(\n                        expectedLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedLiteral)\n                    ) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer =>\n                            fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n            }\n        };\n    }\n};\n","import _0 from \"eslint/lib/rules/accessor-pairs\"\nimport _1 from \"eslint/lib/rules/array-bracket-newline\"\nimport _2 from \"eslint/lib/rules/array-bracket-spacing\"\nimport _3 from \"eslint/lib/rules/array-callback-return\"\nimport _4 from \"eslint/lib/rules/array-element-newline\"\nimport _5 from \"eslint/lib/rules/arrow-body-style\"\nimport _6 from \"eslint/lib/rules/arrow-parens\"\nimport _7 from \"eslint/lib/rules/arrow-spacing\"\nimport _8 from \"eslint/lib/rules/block-scoped-var\"\nimport _9 from \"eslint/lib/rules/block-spacing\"\nimport _10 from \"eslint/lib/rules/brace-style\"\nimport _11 from \"eslint/lib/rules/callback-return\"\nimport _12 from \"eslint/lib/rules/camelcase\"\nimport _13 from \"eslint/lib/rules/capitalized-comments\"\nimport _14 from \"eslint/lib/rules/class-methods-use-this\"\nimport _15 from \"eslint/lib/rules/comma-dangle\"\nimport _16 from \"eslint/lib/rules/comma-spacing\"\nimport _17 from \"eslint/lib/rules/comma-style\"\nimport _18 from \"eslint/lib/rules/complexity\"\nimport _19 from \"eslint/lib/rules/computed-property-spacing\"\nimport _20 from \"eslint/lib/rules/consistent-return\"\nimport _21 from \"eslint/lib/rules/consistent-this\"\nimport _22 from \"eslint/lib/rules/constructor-super\"\nimport _23 from \"eslint/lib/rules/curly\"\nimport _24 from \"eslint/lib/rules/default-case-last\"\nimport _25 from \"eslint/lib/rules/default-case\"\nimport _26 from \"eslint/lib/rules/default-param-last\"\nimport _27 from \"eslint/lib/rules/dot-location\"\nimport _28 from \"eslint/lib/rules/dot-notation\"\nimport _29 from \"eslint/lib/rules/eol-last\"\nimport _30 from \"eslint/lib/rules/eqeqeq\"\nimport _31 from \"eslint/lib/rules/for-direction\"\nimport _32 from \"eslint/lib/rules/func-call-spacing\"\nimport _33 from \"eslint/lib/rules/func-name-matching\"\nimport _34 from \"eslint/lib/rules/func-names\"\nimport _35 from \"eslint/lib/rules/func-style\"\nimport _36 from \"eslint/lib/rules/function-call-argument-newline\"\nimport _37 from \"eslint/lib/rules/function-paren-newline\"\nimport _38 from \"eslint/lib/rules/generator-star-spacing\"\nimport _39 from \"eslint/lib/rules/getter-return\"\nimport _40 from \"eslint/lib/rules/global-require\"\nimport _41 from \"eslint/lib/rules/grouped-accessor-pairs\"\nimport _42 from \"eslint/lib/rules/guard-for-in\"\nimport _43 from \"eslint/lib/rules/handle-callback-err\"\nimport _44 from \"eslint/lib/rules/id-blacklist\"\nimport _45 from \"eslint/lib/rules/id-denylist\"\nimport _46 from \"eslint/lib/rules/id-length\"\nimport _47 from \"eslint/lib/rules/id-match\"\nimport _48 from \"eslint/lib/rules/implicit-arrow-linebreak\"\nimport _49 from \"eslint/lib/rules/indent-legacy\"\nimport _50 from \"eslint/lib/rules/indent\"\nimport _51 from \"eslint/lib/rules/init-declarations\"\nimport _52 from \"eslint/lib/rules/jsx-quotes\"\nimport _53 from \"eslint/lib/rules/key-spacing\"\nimport _54 from \"eslint/lib/rules/keyword-spacing\"\nimport _55 from \"eslint/lib/rules/line-comment-position\"\nimport _56 from \"eslint/lib/rules/linebreak-style\"\nimport _57 from \"eslint/lib/rules/lines-around-comment\"\nimport _58 from \"eslint/lib/rules/lines-around-directive\"\nimport _59 from \"eslint/lib/rules/lines-between-class-members\"\nimport _60 from \"eslint/lib/rules/max-classes-per-file\"\nimport _61 from \"eslint/lib/rules/max-depth\"\nimport _62 from \"eslint/lib/rules/max-len\"\nimport _63 from \"eslint/lib/rules/max-lines-per-function\"\nimport _64 from \"eslint/lib/rules/max-lines\"\nimport _65 from \"eslint/lib/rules/max-nested-callbacks\"\nimport _66 from \"eslint/lib/rules/max-params\"\nimport _67 from \"eslint/lib/rules/max-statements-per-line\"\nimport _68 from \"eslint/lib/rules/max-statements\"\nimport _69 from \"eslint/lib/rules/multiline-comment-style\"\nimport _70 from \"eslint/lib/rules/multiline-ternary\"\nimport _71 from \"eslint/lib/rules/new-cap\"\nimport _72 from \"eslint/lib/rules/new-parens\"\nimport _73 from \"eslint/lib/rules/newline-after-var\"\nimport _74 from \"eslint/lib/rules/newline-before-return\"\nimport _75 from \"eslint/lib/rules/newline-per-chained-call\"\nimport _76 from \"eslint/lib/rules/no-alert\"\nimport _77 from \"eslint/lib/rules/no-array-constructor\"\nimport _78 from \"eslint/lib/rules/no-async-promise-executor\"\nimport _79 from \"eslint/lib/rules/no-await-in-loop\"\nimport _80 from \"eslint/lib/rules/no-bitwise\"\nimport _81 from \"eslint/lib/rules/no-buffer-constructor\"\nimport _82 from \"eslint/lib/rules/no-caller\"\nimport _83 from \"eslint/lib/rules/no-case-declarations\"\nimport _84 from \"eslint/lib/rules/no-catch-shadow\"\nimport _85 from \"eslint/lib/rules/no-class-assign\"\nimport _86 from \"eslint/lib/rules/no-compare-neg-zero\"\nimport _87 from \"eslint/lib/rules/no-cond-assign\"\nimport _88 from \"eslint/lib/rules/no-confusing-arrow\"\nimport _89 from \"eslint/lib/rules/no-console\"\nimport _90 from \"eslint/lib/rules/no-const-assign\"\nimport _91 from \"eslint/lib/rules/no-constant-condition\"\nimport _92 from \"eslint/lib/rules/no-constructor-return\"\nimport _93 from \"eslint/lib/rules/no-continue\"\nimport _94 from \"eslint/lib/rules/no-control-regex\"\nimport _95 from \"eslint/lib/rules/no-debugger\"\nimport _96 from \"eslint/lib/rules/no-delete-var\"\nimport _97 from \"eslint/lib/rules/no-div-regex\"\nimport _98 from \"eslint/lib/rules/no-dupe-args\"\nimport _99 from \"eslint/lib/rules/no-dupe-class-members\"\nimport _100 from \"eslint/lib/rules/no-dupe-else-if\"\nimport _101 from \"eslint/lib/rules/no-dupe-keys\"\nimport _102 from \"eslint/lib/rules/no-duplicate-case\"\nimport _103 from \"eslint/lib/rules/no-duplicate-imports\"\nimport _104 from \"eslint/lib/rules/no-else-return\"\nimport _105 from \"eslint/lib/rules/no-empty-character-class\"\nimport _106 from \"eslint/lib/rules/no-empty-function\"\nimport _107 from \"eslint/lib/rules/no-empty-pattern\"\nimport _108 from \"eslint/lib/rules/no-empty\"\nimport _109 from \"eslint/lib/rules/no-eq-null\"\nimport _110 from \"eslint/lib/rules/no-eval\"\nimport _111 from \"eslint/lib/rules/no-ex-assign\"\nimport _112 from \"eslint/lib/rules/no-extend-native\"\nimport _113 from \"eslint/lib/rules/no-extra-bind\"\nimport _114 from \"eslint/lib/rules/no-extra-boolean-cast\"\nimport _115 from \"eslint/lib/rules/no-extra-label\"\nimport _116 from \"eslint/lib/rules/no-extra-parens\"\nimport _117 from \"eslint/lib/rules/no-extra-semi\"\nimport _118 from \"eslint/lib/rules/no-fallthrough\"\nimport _119 from \"eslint/lib/rules/no-floating-decimal\"\nimport _120 from \"eslint/lib/rules/no-func-assign\"\nimport _121 from \"eslint/lib/rules/no-global-assign\"\nimport _122 from \"eslint/lib/rules/no-implicit-coercion\"\nimport _123 from \"eslint/lib/rules/no-implicit-globals\"\nimport _124 from \"eslint/lib/rules/no-implied-eval\"\nimport _125 from \"eslint/lib/rules/no-import-assign\"\nimport _126 from \"eslint/lib/rules/no-inline-comments\"\nimport _127 from \"eslint/lib/rules/no-inner-declarations\"\nimport _128 from \"eslint/lib/rules/no-invalid-regexp\"\nimport _129 from \"eslint/lib/rules/no-invalid-this\"\nimport _130 from \"eslint/lib/rules/no-irregular-whitespace\"\nimport _131 from \"eslint/lib/rules/no-iterator\"\nimport _132 from \"eslint/lib/rules/no-label-var\"\nimport _133 from \"eslint/lib/rules/no-labels\"\nimport _134 from \"eslint/lib/rules/no-lone-blocks\"\nimport _135 from \"eslint/lib/rules/no-lonely-if\"\nimport _136 from \"eslint/lib/rules/no-loop-func\"\nimport _137 from \"eslint/lib/rules/no-loss-of-precision\"\nimport _138 from \"eslint/lib/rules/no-magic-numbers\"\nimport _139 from \"eslint/lib/rules/no-misleading-character-class\"\nimport _140 from \"eslint/lib/rules/no-mixed-operators\"\nimport _141 from \"eslint/lib/rules/no-mixed-requires\"\nimport _142 from \"eslint/lib/rules/no-mixed-spaces-and-tabs\"\nimport _143 from \"eslint/lib/rules/no-multi-assign\"\nimport _144 from \"eslint/lib/rules/no-multi-spaces\"\nimport _145 from \"eslint/lib/rules/no-multi-str\"\nimport _146 from \"eslint/lib/rules/no-multiple-empty-lines\"\nimport _147 from \"eslint/lib/rules/no-native-reassign\"\nimport _148 from \"eslint/lib/rules/no-negated-condition\"\nimport _149 from \"eslint/lib/rules/no-negated-in-lhs\"\nimport _150 from \"eslint/lib/rules/no-nested-ternary\"\nimport _151 from \"eslint/lib/rules/no-new-func\"\nimport _152 from \"eslint/lib/rules/no-new-object\"\nimport _153 from \"eslint/lib/rules/no-new-require\"\nimport _154 from \"eslint/lib/rules/no-new-symbol\"\nimport _155 from \"eslint/lib/rules/no-new-wrappers\"\nimport _156 from \"eslint/lib/rules/no-new\"\nimport _157 from \"eslint/lib/rules/no-nonoctal-decimal-escape\"\nimport _158 from \"eslint/lib/rules/no-obj-calls\"\nimport _159 from \"eslint/lib/rules/no-octal-escape\"\nimport _160 from \"eslint/lib/rules/no-octal\"\nimport _161 from \"eslint/lib/rules/no-param-reassign\"\nimport _162 from \"eslint/lib/rules/no-path-concat\"\nimport _163 from \"eslint/lib/rules/no-plusplus\"\nimport _164 from \"eslint/lib/rules/no-process-env\"\nimport _165 from \"eslint/lib/rules/no-process-exit\"\nimport _166 from \"eslint/lib/rules/no-promise-executor-return\"\nimport _167 from \"eslint/lib/rules/no-proto\"\nimport _168 from \"eslint/lib/rules/no-prototype-builtins\"\nimport _169 from \"eslint/lib/rules/no-redeclare\"\nimport _170 from \"eslint/lib/rules/no-regex-spaces\"\nimport _171 from \"eslint/lib/rules/no-restricted-exports\"\nimport _172 from \"eslint/lib/rules/no-restricted-globals\"\nimport _173 from \"eslint/lib/rules/no-restricted-imports\"\nimport _174 from \"eslint/lib/rules/no-restricted-modules\"\nimport _175 from \"eslint/lib/rules/no-restricted-properties\"\nimport _176 from \"eslint/lib/rules/no-restricted-syntax\"\nimport _177 from \"eslint/lib/rules/no-return-assign\"\nimport _178 from \"eslint/lib/rules/no-return-await\"\nimport _179 from \"eslint/lib/rules/no-script-url\"\nimport _180 from \"eslint/lib/rules/no-self-assign\"\nimport _181 from \"eslint/lib/rules/no-self-compare\"\nimport _182 from \"eslint/lib/rules/no-sequences\"\nimport _183 from \"eslint/lib/rules/no-setter-return\"\nimport _184 from \"eslint/lib/rules/no-shadow-restricted-names\"\nimport _185 from \"eslint/lib/rules/no-shadow\"\nimport _186 from \"eslint/lib/rules/no-spaced-func\"\nimport _187 from \"eslint/lib/rules/no-sparse-arrays\"\nimport _188 from \"eslint/lib/rules/no-sync\"\nimport _189 from \"eslint/lib/rules/no-tabs\"\nimport _190 from \"eslint/lib/rules/no-template-curly-in-string\"\nimport _191 from \"eslint/lib/rules/no-ternary\"\nimport _192 from \"eslint/lib/rules/no-this-before-super\"\nimport _193 from \"eslint/lib/rules/no-throw-literal\"\nimport _194 from \"eslint/lib/rules/no-trailing-spaces\"\nimport _195 from \"eslint/lib/rules/no-undef-init\"\nimport _196 from \"eslint/lib/rules/no-undef\"\nimport _197 from \"eslint/lib/rules/no-undefined\"\nimport _198 from \"eslint/lib/rules/no-underscore-dangle\"\nimport _199 from \"eslint/lib/rules/no-unexpected-multiline\"\nimport _200 from \"eslint/lib/rules/no-unmodified-loop-condition\"\nimport _201 from \"eslint/lib/rules/no-unneeded-ternary\"\nimport _202 from \"eslint/lib/rules/no-unreachable-loop\"\nimport _203 from \"eslint/lib/rules/no-unreachable\"\nimport _204 from \"eslint/lib/rules/no-unsafe-finally\"\nimport _205 from \"eslint/lib/rules/no-unsafe-negation\"\nimport _206 from \"eslint/lib/rules/no-unsafe-optional-chaining\"\nimport _207 from \"eslint/lib/rules/no-unused-expressions\"\nimport _208 from \"eslint/lib/rules/no-unused-labels\"\nimport _209 from \"eslint/lib/rules/no-unused-vars\"\nimport _210 from \"eslint/lib/rules/no-use-before-define\"\nimport _211 from \"eslint/lib/rules/no-useless-backreference\"\nimport _212 from \"eslint/lib/rules/no-useless-call\"\nimport _213 from \"eslint/lib/rules/no-useless-catch\"\nimport _214 from \"eslint/lib/rules/no-useless-computed-key\"\nimport _215 from \"eslint/lib/rules/no-useless-concat\"\nimport _216 from \"eslint/lib/rules/no-useless-constructor\"\nimport _217 from \"eslint/lib/rules/no-useless-escape\"\nimport _218 from \"eslint/lib/rules/no-useless-rename\"\nimport _219 from \"eslint/lib/rules/no-useless-return\"\nimport _220 from \"eslint/lib/rules/no-var\"\nimport _221 from \"eslint/lib/rules/no-void\"\nimport _222 from \"eslint/lib/rules/no-warning-comments\"\nimport _223 from \"eslint/lib/rules/no-whitespace-before-property\"\nimport _224 from \"eslint/lib/rules/no-with\"\nimport _225 from \"eslint/lib/rules/nonblock-statement-body-position\"\nimport _226 from \"eslint/lib/rules/object-curly-newline\"\nimport _227 from \"eslint/lib/rules/object-curly-spacing\"\nimport _228 from \"eslint/lib/rules/object-property-newline\"\nimport _229 from \"eslint/lib/rules/object-shorthand\"\nimport _230 from \"eslint/lib/rules/one-var-declaration-per-line\"\nimport _231 from \"eslint/lib/rules/one-var\"\nimport _232 from \"eslint/lib/rules/operator-assignment\"\nimport _233 from \"eslint/lib/rules/operator-linebreak\"\nimport _234 from \"eslint/lib/rules/padded-blocks\"\nimport _235 from \"eslint/lib/rules/padding-line-between-statements\"\nimport _236 from \"eslint/lib/rules/prefer-arrow-callback\"\nimport _237 from \"eslint/lib/rules/prefer-const\"\nimport _238 from \"eslint/lib/rules/prefer-destructuring\"\nimport _239 from \"eslint/lib/rules/prefer-exponentiation-operator\"\nimport _240 from \"eslint/lib/rules/prefer-named-capture-group\"\nimport _241 from \"eslint/lib/rules/prefer-numeric-literals\"\nimport _242 from \"eslint/lib/rules/prefer-object-spread\"\nimport _243 from \"eslint/lib/rules/prefer-promise-reject-errors\"\nimport _244 from \"eslint/lib/rules/prefer-reflect\"\nimport _245 from \"eslint/lib/rules/prefer-regex-literals\"\nimport _246 from \"eslint/lib/rules/prefer-rest-params\"\nimport _247 from \"eslint/lib/rules/prefer-spread\"\nimport _248 from \"eslint/lib/rules/prefer-template\"\nimport _249 from \"eslint/lib/rules/quote-props\"\nimport _250 from \"eslint/lib/rules/quotes\"\nimport _251 from \"eslint/lib/rules/radix\"\nimport _252 from \"eslint/lib/rules/require-atomic-updates\"\nimport _253 from \"eslint/lib/rules/require-await\"\nimport _254 from \"eslint/lib/rules/require-jsdoc\"\nimport _255 from \"eslint/lib/rules/require-unicode-regexp\"\nimport _256 from \"eslint/lib/rules/require-yield\"\nimport _257 from \"eslint/lib/rules/rest-spread-spacing\"\nimport _258 from \"eslint/lib/rules/semi-spacing\"\nimport _259 from \"eslint/lib/rules/semi-style\"\nimport _260 from \"eslint/lib/rules/semi\"\nimport _261 from \"eslint/lib/rules/sort-imports\"\nimport _262 from \"eslint/lib/rules/sort-keys\"\nimport _263 from \"eslint/lib/rules/sort-vars\"\nimport _264 from \"eslint/lib/rules/space-before-blocks\"\nimport _265 from \"eslint/lib/rules/space-before-function-paren\"\nimport _266 from \"eslint/lib/rules/space-in-parens\"\nimport _267 from \"eslint/lib/rules/space-infix-ops\"\nimport _268 from \"eslint/lib/rules/space-unary-ops\"\nimport _269 from \"eslint/lib/rules/spaced-comment\"\nimport _270 from \"eslint/lib/rules/strict\"\nimport _271 from \"eslint/lib/rules/switch-colon-spacing\"\nimport _272 from \"eslint/lib/rules/symbol-description\"\nimport _273 from \"eslint/lib/rules/template-curly-spacing\"\nimport _274 from \"eslint/lib/rules/template-tag-spacing\"\nimport _275 from \"eslint/lib/rules/unicode-bom\"\nimport _276 from \"eslint/lib/rules/use-isnan\"\nimport _277 from \"eslint/lib/rules/valid-jsdoc\"\nimport _278 from \"eslint/lib/rules/valid-typeof\"\nimport _279 from \"eslint/lib/rules/vars-on-top\"\nimport _280 from \"eslint/lib/rules/wrap-iife\"\nimport _281 from \"eslint/lib/rules/wrap-regex\"\nimport _282 from \"eslint/lib/rules/yield-star-spacing\"\nimport _283 from \"eslint/lib/rules/yoda\"\nexport default {\n    \"accessor-pairs\": _0,\n    \"array-bracket-newline\": _1,\n    \"array-bracket-spacing\": _2,\n    \"array-callback-return\": _3,\n    \"array-element-newline\": _4,\n    \"arrow-body-style\": _5,\n    \"arrow-parens\": _6,\n    \"arrow-spacing\": _7,\n    \"block-scoped-var\": _8,\n    \"block-spacing\": _9,\n    \"brace-style\": _10,\n    \"callback-return\": _11,\n    \"camelcase\": _12,\n    \"capitalized-comments\": _13,\n    \"class-methods-use-this\": _14,\n    \"comma-dangle\": _15,\n    \"comma-spacing\": _16,\n    \"comma-style\": _17,\n    \"complexity\": _18,\n    \"computed-property-spacing\": _19,\n    \"consistent-return\": _20,\n    \"consistent-this\": _21,\n    \"constructor-super\": _22,\n    \"curly\": _23,\n    \"default-case-last\": _24,\n    \"default-case\": _25,\n    \"default-param-last\": _26,\n    \"dot-location\": _27,\n    \"dot-notation\": _28,\n    \"eol-last\": _29,\n    \"eqeqeq\": _30,\n    \"for-direction\": _31,\n    \"func-call-spacing\": _32,\n    \"func-name-matching\": _33,\n    \"func-names\": _34,\n    \"func-style\": _35,\n    \"function-call-argument-newline\": _36,\n    \"function-paren-newline\": _37,\n    \"generator-star-spacing\": _38,\n    \"getter-return\": _39,\n    \"global-require\": _40,\n    \"grouped-accessor-pairs\": _41,\n    \"guard-for-in\": _42,\n    \"handle-callback-err\": _43,\n    \"id-blacklist\": _44,\n    \"id-denylist\": _45,\n    \"id-length\": _46,\n    \"id-match\": _47,\n    \"implicit-arrow-linebreak\": _48,\n    \"indent-legacy\": _49,\n    \"indent\": _50,\n    \"init-declarations\": _51,\n    \"jsx-quotes\": _52,\n    \"key-spacing\": _53,\n    \"keyword-spacing\": _54,\n    \"line-comment-position\": _55,\n    \"linebreak-style\": _56,\n    \"lines-around-comment\": _57,\n    \"lines-around-directive\": _58,\n    \"lines-between-class-members\": _59,\n    \"max-classes-per-file\": _60,\n    \"max-depth\": _61,\n    \"max-len\": _62,\n    \"max-lines-per-function\": _63,\n    \"max-lines\": _64,\n    \"max-nested-callbacks\": _65,\n    \"max-params\": _66,\n    \"max-statements-per-line\": _67,\n    \"max-statements\": _68,\n    \"multiline-comment-style\": _69,\n    \"multiline-ternary\": _70,\n    \"new-cap\": _71,\n    \"new-parens\": _72,\n    \"newline-after-var\": _73,\n    \"newline-before-return\": _74,\n    \"newline-per-chained-call\": _75,\n    \"no-alert\": _76,\n    \"no-array-constructor\": _77,\n    \"no-async-promise-executor\": _78,\n    \"no-await-in-loop\": _79,\n    \"no-bitwise\": _80,\n    \"no-buffer-constructor\": _81,\n    \"no-caller\": _82,\n    \"no-case-declarations\": _83,\n    \"no-catch-shadow\": _84,\n    \"no-class-assign\": _85,\n    \"no-compare-neg-zero\": _86,\n    \"no-cond-assign\": _87,\n    \"no-confusing-arrow\": _88,\n    \"no-console\": _89,\n    \"no-const-assign\": _90,\n    \"no-constant-condition\": _91,\n    \"no-constructor-return\": _92,\n    \"no-continue\": _93,\n    \"no-control-regex\": _94,\n    \"no-debugger\": _95,\n    \"no-delete-var\": _96,\n    \"no-div-regex\": _97,\n    \"no-dupe-args\": _98,\n    \"no-dupe-class-members\": _99,\n    \"no-dupe-else-if\": _100,\n    \"no-dupe-keys\": _101,\n    \"no-duplicate-case\": _102,\n    \"no-duplicate-imports\": _103,\n    \"no-else-return\": _104,\n    \"no-empty-character-class\": _105,\n    \"no-empty-function\": _106,\n    \"no-empty-pattern\": _107,\n    \"no-empty\": _108,\n    \"no-eq-null\": _109,\n    \"no-eval\": _110,\n    \"no-ex-assign\": _111,\n    \"no-extend-native\": _112,\n    \"no-extra-bind\": _113,\n    \"no-extra-boolean-cast\": _114,\n    \"no-extra-label\": _115,\n    \"no-extra-parens\": _116,\n    \"no-extra-semi\": _117,\n    \"no-fallthrough\": _118,\n    \"no-floating-decimal\": _119,\n    \"no-func-assign\": _120,\n    \"no-global-assign\": _121,\n    \"no-implicit-coercion\": _122,\n    \"no-implicit-globals\": _123,\n    \"no-implied-eval\": _124,\n    \"no-import-assign\": _125,\n    \"no-inline-comments\": _126,\n    \"no-inner-declarations\": _127,\n    \"no-invalid-regexp\": _128,\n    \"no-invalid-this\": _129,\n    \"no-irregular-whitespace\": _130,\n    \"no-iterator\": _131,\n    \"no-label-var\": _132,\n    \"no-labels\": _133,\n    \"no-lone-blocks\": _134,\n    \"no-lonely-if\": _135,\n    \"no-loop-func\": _136,\n    \"no-loss-of-precision\": _137,\n    \"no-magic-numbers\": _138,\n    \"no-misleading-character-class\": _139,\n    \"no-mixed-operators\": _140,\n    \"no-mixed-requires\": _141,\n    \"no-mixed-spaces-and-tabs\": _142,\n    \"no-multi-assign\": _143,\n    \"no-multi-spaces\": _144,\n    \"no-multi-str\": _145,\n    \"no-multiple-empty-lines\": _146,\n    \"no-native-reassign\": _147,\n    \"no-negated-condition\": _148,\n    \"no-negated-in-lhs\": _149,\n    \"no-nested-ternary\": _150,\n    \"no-new-func\": _151,\n    \"no-new-object\": _152,\n    \"no-new-require\": _153,\n    \"no-new-symbol\": _154,\n    \"no-new-wrappers\": _155,\n    \"no-new\": _156,\n    \"no-nonoctal-decimal-escape\": _157,\n    \"no-obj-calls\": _158,\n    \"no-octal-escape\": _159,\n    \"no-octal\": _160,\n    \"no-param-reassign\": _161,\n    \"no-path-concat\": _162,\n    \"no-plusplus\": _163,\n    \"no-process-env\": _164,\n    \"no-process-exit\": _165,\n    \"no-promise-executor-return\": _166,\n    \"no-proto\": _167,\n    \"no-prototype-builtins\": _168,\n    \"no-redeclare\": _169,\n    \"no-regex-spaces\": _170,\n    \"no-restricted-exports\": _171,\n    \"no-restricted-globals\": _172,\n    \"no-restricted-imports\": _173,\n    \"no-restricted-modules\": _174,\n    \"no-restricted-properties\": _175,\n    \"no-restricted-syntax\": _176,\n    \"no-return-assign\": _177,\n    \"no-return-await\": _178,\n    \"no-script-url\": _179,\n    \"no-self-assign\": _180,\n    \"no-self-compare\": _181,\n    \"no-sequences\": _182,\n    \"no-setter-return\": _183,\n    \"no-shadow-restricted-names\": _184,\n    \"no-shadow\": _185,\n    \"no-spaced-func\": _186,\n    \"no-sparse-arrays\": _187,\n    \"no-sync\": _188,\n    \"no-tabs\": _189,\n    \"no-template-curly-in-string\": _190,\n    \"no-ternary\": _191,\n    \"no-this-before-super\": _192,\n    \"no-throw-literal\": _193,\n    \"no-trailing-spaces\": _194,\n    \"no-undef-init\": _195,\n    \"no-undef\": _196,\n    \"no-undefined\": _197,\n    \"no-underscore-dangle\": _198,\n    \"no-unexpected-multiline\": _199,\n    \"no-unmodified-loop-condition\": _200,\n    \"no-unneeded-ternary\": _201,\n    \"no-unreachable-loop\": _202,\n    \"no-unreachable\": _203,\n    \"no-unsafe-finally\": _204,\n    \"no-unsafe-negation\": _205,\n    \"no-unsafe-optional-chaining\": _206,\n    \"no-unused-expressions\": _207,\n    \"no-unused-labels\": _208,\n    \"no-unused-vars\": _209,\n    \"no-use-before-define\": _210,\n    \"no-useless-backreference\": _211,\n    \"no-useless-call\": _212,\n    \"no-useless-catch\": _213,\n    \"no-useless-computed-key\": _214,\n    \"no-useless-concat\": _215,\n    \"no-useless-constructor\": _216,\n    \"no-useless-escape\": _217,\n    \"no-useless-rename\": _218,\n    \"no-useless-return\": _219,\n    \"no-var\": _220,\n    \"no-void\": _221,\n    \"no-warning-comments\": _222,\n    \"no-whitespace-before-property\": _223,\n    \"no-with\": _224,\n    \"nonblock-statement-body-position\": _225,\n    \"object-curly-newline\": _226,\n    \"object-curly-spacing\": _227,\n    \"object-property-newline\": _228,\n    \"object-shorthand\": _229,\n    \"one-var-declaration-per-line\": _230,\n    \"one-var\": _231,\n    \"operator-assignment\": _232,\n    \"operator-linebreak\": _233,\n    \"padded-blocks\": _234,\n    \"padding-line-between-statements\": _235,\n    \"prefer-arrow-callback\": _236,\n    \"prefer-const\": _237,\n    \"prefer-destructuring\": _238,\n    \"prefer-exponentiation-operator\": _239,\n    \"prefer-named-capture-group\": _240,\n    \"prefer-numeric-literals\": _241,\n    \"prefer-object-spread\": _242,\n    \"prefer-promise-reject-errors\": _243,\n    \"prefer-reflect\": _244,\n    \"prefer-regex-literals\": _245,\n    \"prefer-rest-params\": _246,\n    \"prefer-spread\": _247,\n    \"prefer-template\": _248,\n    \"quote-props\": _249,\n    \"quotes\": _250,\n    \"radix\": _251,\n    \"require-atomic-updates\": _252,\n    \"require-await\": _253,\n    \"require-jsdoc\": _254,\n    \"require-unicode-regexp\": _255,\n    \"require-yield\": _256,\n    \"rest-spread-spacing\": _257,\n    \"semi-spacing\": _258,\n    \"semi-style\": _259,\n    \"semi\": _260,\n    \"sort-imports\": _261,\n    \"sort-keys\": _262,\n    \"sort-vars\": _263,\n    \"space-before-blocks\": _264,\n    \"space-before-function-paren\": _265,\n    \"space-in-parens\": _266,\n    \"space-infix-ops\": _267,\n    \"space-unary-ops\": _268,\n    \"spaced-comment\": _269,\n    \"strict\": _270,\n    \"switch-colon-spacing\": _271,\n    \"symbol-description\": _272,\n    \"template-curly-spacing\": _273,\n    \"template-tag-spacing\": _274,\n    \"unicode-bom\": _275,\n    \"use-isnan\": _276,\n    \"valid-jsdoc\": _277,\n    \"valid-typeof\": _278,\n    \"vars-on-top\": _279,\n    \"wrap-iife\": _280,\n    \"wrap-regex\": _281,\n    \"yield-star-spacing\": _282,\n    \"yoda\": _283,\n}\n"]}