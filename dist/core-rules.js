'use strict';

var _commonjsHelpers = require('./_commonjsHelpers-11cbc178.js');

var esutils = require('esutils');

var espree = require('espree');

var lodash = require('lodash');

var functionalRedBlackTree = require('functional-red-black-tree');

var regexpp = require('regexpp');

var globals = require('globals');

var eslintUtils = require('eslint-utils');

var ignore = require('ignore');

var naturalCompare = require('natural-compare');

var doctrine = require('doctrine');

function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var esutils__default = _interopDefaultLegacy(esutils);

var espree__default = _interopDefaultLegacy(espree);

var lodash__default = _interopDefaultLegacy(lodash);

var functionalRedBlackTree__default = _interopDefaultLegacy(functionalRedBlackTree);

var regexpp__default = _interopDefaultLegacy(regexpp);

var globals__default = _interopDefaultLegacy(globals);

var eslintUtils__default = _interopDefaultLegacy(eslintUtils);

var ignore__default = _interopDefaultLegacy(ignore);

var naturalCompare__default = _interopDefaultLegacy(naturalCompare);

var doctrine__default = _interopDefaultLegacy(doctrine);

var astUtils = _commonjsHelpers.createCommonjsModule(function (module) {
  const {
    breakableTypePattern,
    createGlobalLinebreakMatcher,
    lineBreakPattern,
    shebangPattern
  } = _commonjsHelpers.astUtils;
  const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
  const thisTagPattern = /^[\s*]*@this/mu;
  const LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
  const STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);
  const DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;
  const LOGICAL_ASSIGNMENT_OPERATORS = new Set(["&&=", "||=", "??="]);

  function isModifyingReference(reference, index, references) {
    const identifier = reference.identifier;
    const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
    return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
  }

  function startsWithUpperCase(s) {
    return s[0] !== s[0].toLocaleLowerCase();
  }

  function isES5Constructor(node) {
    return node.id && startsWithUpperCase(node.id.name);
  }

  function getUpperFunction(node) {
    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
      if (anyFunctionPattern.test(currentNode.type)) {
        return currentNode;
      }
    }

    return null;
  }

  function isFunction(node) {
    return Boolean(node && anyFunctionPattern.test(node.type));
  }

  function isLoop(node) {
    return Boolean(node && /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u.test(node.type));
  }

  function isNullLiteral(node) {
    return node.type === "Literal" && node.value === null && !node.regex && !node.bigint;
  }

  function isNullOrUndefined(node) {
    return isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
  }

  function isCallee(node) {
    return node.parent.type === "CallExpression" && node.parent.callee === node;
  }

  function getStaticStringValue(node) {
    switch (node.type) {
      case "Literal":
        if (node.value === null) {
          if (isNullLiteral(node)) {
            return String(node.value);
          }

          if (node.regex) {
            return `/${node.regex.pattern}/${node.regex.flags}`;
          }

          if (node.bigint) {
            return node.bigint;
          }
        } else {
          return String(node.value);
        }

        break;

      case "TemplateLiteral":
        if (node.expressions.length === 0 && node.quasis.length === 1) {
          return node.quasis[0].value.cooked;
        }

        break;
    }

    return null;
  }

  function getStaticPropertyName(node) {
    let prop;

    switch (node && node.type) {
      case "ChainExpression":
        return getStaticPropertyName(node.expression);

      case "Property":
      case "MethodDefinition":
        prop = node.key;
        break;

      case "MemberExpression":
        prop = node.property;
        break;
    }

    if (prop) {
      if (prop.type === "Identifier" && !node.computed) {
        return prop.name;
      }

      return getStaticStringValue(prop);
    }

    return null;
  }

  function skipChainExpression(node) {
    return node && node.type === "ChainExpression" ? node.expression : node;
  }

  function checkText(actual, expected) {
    return typeof expected === "string" ? actual === expected : expected.test(actual);
  }

  function isSpecificId(node, name) {
    return node.type === "Identifier" && checkText(node.name, name);
  }

  function isSpecificMemberAccess(node, objectName, propertyName) {
    const checkNode = skipChainExpression(node);

    if (checkNode.type !== "MemberExpression") {
      return false;
    }

    if (objectName && !isSpecificId(checkNode.object, objectName)) {
      return false;
    }

    if (propertyName) {
      const actualPropertyName = getStaticPropertyName(checkNode);

      if (typeof actualPropertyName !== "string" || !checkText(actualPropertyName, propertyName)) {
        return false;
      }
    }

    return true;
  }

  function equalLiteralValue(left, right) {
    if (left.regex || right.regex) {
      return Boolean(left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags);
    }

    if (left.bigint || right.bigint) {
      return left.bigint === right.bigint;
    }

    return left.value === right.value;
  }

  function isSameReference(left, right, disableStaticComputedKey = false) {
    if (left.type !== right.type) {
      if (left.type === "ChainExpression") {
        return isSameReference(left.expression, right, disableStaticComputedKey);
      }

      if (right.type === "ChainExpression") {
        return isSameReference(left, right.expression, disableStaticComputedKey);
      }

      return false;
    }

    switch (left.type) {
      case "Super":
      case "ThisExpression":
        return true;

      case "Identifier":
        return left.name === right.name;

      case "Literal":
        return equalLiteralValue(left, right);

      case "ChainExpression":
        return isSameReference(left.expression, right.expression, disableStaticComputedKey);

      case "MemberExpression":
        {
          if (!disableStaticComputedKey) {
            const nameA = getStaticPropertyName(left);

            if (nameA !== null) {
              return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);
            }
          }

          return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);
        }

      default:
        return false;
    }
  }

  function isReflectApply(node) {
    return isSpecificMemberAccess(node, "Reflect", "apply");
  }

  function isArrayFromMethod(node) {
    return isSpecificMemberAccess(node, /Array$/u, "from");
  }

  function isMethodWhichHasThisArg(node) {
    return isSpecificMemberAccess(node, null, /^(?:every|filter|find|findIndex|forEach|map|some)$/u);
  }

  function negate(f) {
    return token => !f(token);
  }

  function hasJSDocThisTag(node, sourceCode) {
    const jsdocComment = sourceCode.getJSDocComment(node);

    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
      return true;
    }

    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));
  }

  function isArrowToken(token) {
    return token.value === "=>" && token.type === "Punctuator";
  }

  function isCommaToken(token) {
    return token.value === "," && token.type === "Punctuator";
  }

  function isDotToken(token) {
    return token.value === "." && token.type === "Punctuator";
  }

  function isQuestionDotToken(token) {
    return token.value === "?." && token.type === "Punctuator";
  }

  function isSemicolonToken(token) {
    return token.value === ";" && token.type === "Punctuator";
  }

  function isColonToken(token) {
    return token.value === ":" && token.type === "Punctuator";
  }

  function isOpeningParenToken(token) {
    return token.value === "(" && token.type === "Punctuator";
  }

  function isClosingParenToken(token) {
    return token.value === ")" && token.type === "Punctuator";
  }

  function isOpeningBracketToken(token) {
    return token.value === "[" && token.type === "Punctuator";
  }

  function isClosingBracketToken(token) {
    return token.value === "]" && token.type === "Punctuator";
  }

  function isOpeningBraceToken(token) {
    return token.value === "{" && token.type === "Punctuator";
  }

  function isClosingBraceToken(token) {
    return token.value === "}" && token.type === "Punctuator";
  }

  function getOpeningParenOfParams(node, sourceCode) {
    return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
  }

  function isLogicalExpression(node) {
    return node.type === "LogicalExpression" && (node.operator === "&&" || node.operator === "||");
  }

  function isCoalesceExpression(node) {
    return node.type === "LogicalExpression" && node.operator === "??";
  }

  module.exports = {
    COMMENTS_IGNORE_PATTERN: /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u,
    LINEBREAKS,
    LINEBREAK_MATCHER: lineBreakPattern,
    SHEBANG_MATCHER: shebangPattern,
    STATEMENT_LIST_PARENTS,

    isTokenOnSameLine(left, right) {
      return left.loc.end.line === right.loc.start.line;
    },

    isNullOrUndefined,
    isCallee,
    isES5Constructor,
    getUpperFunction,
    isFunction,
    isLoop,
    isInLoop: function (node) {
      for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {
        if (isLoop(currentNode)) {
          return true;
        }
      }

      return false;
    },
    isArrayFromMethod,
    isParenthesised: function (sourceCode, node) {
      const previousToken = sourceCode.getTokenBefore(node),
            nextToken = sourceCode.getTokenAfter(node);
      return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    },
    createGlobalLinebreakMatcher,
    equalTokens: function (left, right, sourceCode) {
      const tokensL = sourceCode.getTokens(left);
      const tokensR = sourceCode.getTokens(right);

      if (tokensL.length !== tokensR.length) {
        return false;
      }

      for (let i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
          return false;
        }
      }

      return true;
    },
    isArrowToken,
    isClosingBraceToken,
    isClosingBracketToken,
    isClosingParenToken,
    isColonToken,
    isCommaToken,
    isCommentToken: function (token) {
      return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
    },
    isDotToken,
    isQuestionDotToken,
    isKeywordToken: function (token) {
      return token.type === "Keyword";
    },
    isNotClosingBraceToken: negate(isClosingBraceToken),
    isNotClosingBracketToken: negate(isClosingBracketToken),
    isNotClosingParenToken: negate(isClosingParenToken),
    isNotColonToken: negate(isColonToken),
    isNotCommaToken: negate(isCommaToken),
    isNotDotToken: negate(isDotToken),
    isNotQuestionDotToken: negate(isQuestionDotToken),
    isNotOpeningBraceToken: negate(isOpeningBraceToken),
    isNotOpeningBracketToken: negate(isOpeningBracketToken),
    isNotOpeningParenToken: negate(isOpeningParenToken),
    isNotSemicolonToken: negate(isSemicolonToken),
    isOpeningBraceToken,
    isOpeningBracketToken,
    isOpeningParenToken,
    isSemicolonToken,

    isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
    },

    isBreakableStatement(node) {
      return breakableTypePattern.test(node.type);
    },

    getModifyingReferences(references) {
      return references.filter(isModifyingReference);
    },

    isSurroundedBy(val, character) {
      return val[0] === character && val[val.length - 1] === character;
    },

    isDirectiveComment(node) {
      const comment = node.value.trim();
      return node.type === "Line" && comment.indexOf("eslint-") === 0 || node.type === "Block" && (comment.indexOf("global ") === 0 || comment.indexOf("eslint ") === 0 || comment.indexOf("eslint-") === 0);
    },

    getTrailingStatement: esutils__default['default'].ast.trailingStatement,

    getVariableByName(initScope, name) {
      let scope = initScope;

      while (scope) {
        const variable = scope.set.get(name);

        if (variable) {
          return variable;
        }

        scope = scope.upper;
      }

      return null;
    },

    isDefaultThisBinding(node, sourceCode, {
      capIsConstructor = true
    } = {}) {
      if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
        return false;
      }

      const isAnonymous = node.id === null;
      let currentNode = node;

      while (currentNode) {
        const parent = currentNode.parent;

        switch (parent.type) {
          case "LogicalExpression":
          case "ConditionalExpression":
          case "ChainExpression":
            currentNode = parent;
            break;

          case "ReturnStatement":
            {
              const func = getUpperFunction(parent);

              if (func === null || !isCallee(func)) {
                return true;
              }

              currentNode = func.parent;
              break;
            }

          case "ArrowFunctionExpression":
            if (currentNode !== parent.body || !isCallee(parent)) {
              return true;
            }

            currentNode = parent.parent;
            break;

          case "Property":
          case "MethodDefinition":
            return parent.value !== currentNode;

          case "AssignmentExpression":
          case "AssignmentPattern":
            if (parent.left.type === "MemberExpression") {
              return false;
            }

            if (capIsConstructor && isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
              return false;
            }

            return true;

          case "VariableDeclarator":
            return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));

          case "MemberExpression":
            if (parent.object === currentNode && isSpecificMemberAccess(parent, null, /^(?:bind|call|apply)$/u)) {
              const maybeCalleeNode = parent.parent.type === "ChainExpression" ? parent.parent : parent;
              return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));
            }

            return true;

          case "CallExpression":
            if (isReflectApply(parent.callee)) {
              return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
            }

            if (isArrayFromMethod(parent.callee)) {
              return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
            }

            if (isMethodWhichHasThisArg(parent.callee)) {
              return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
            }

            return true;

          default:
            return true;
        }
      }

      return true;
    },

    getPrecedence(node) {
      switch (node.type) {
        case "SequenceExpression":
          return 0;

        case "AssignmentExpression":
        case "ArrowFunctionExpression":
        case "YieldExpression":
          return 1;

        case "ConditionalExpression":
          return 3;

        case "LogicalExpression":
          switch (node.operator) {
            case "||":
            case "??":
              return 4;

            case "&&":
              return 5;
          }

        case "BinaryExpression":
          switch (node.operator) {
            case "|":
              return 6;

            case "^":
              return 7;

            case "&":
              return 8;

            case "==":
            case "!=":
            case "===":
            case "!==":
              return 9;

            case "<":
            case "<=":
            case ">":
            case ">=":
            case "in":
            case "instanceof":
              return 10;

            case "<<":
            case ">>":
            case ">>>":
              return 11;

            case "+":
            case "-":
              return 12;

            case "*":
            case "/":
            case "%":
              return 13;

            case "**":
              return 15;
          }

        case "UnaryExpression":
        case "AwaitExpression":
          return 16;

        case "UpdateExpression":
          return 17;

        case "CallExpression":
        case "ChainExpression":
        case "ImportExpression":
          return 18;

        case "NewExpression":
          return 19;

        default:
          return 20;
      }
    },

    isEmptyBlock(node) {
      return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
    },

    isEmptyFunction(node) {
      return isFunction(node) && module.exports.isEmptyBlock(node.body);
    },

    getDirectivePrologue(node) {
      const directives = [];

      if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement") {
        const statements = node.type === "Program" ? node.body : node.body.body;

        for (const statement of statements) {
          if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
            directives.push(statement);
          } else {
            break;
          }
        }
      }

      return directives;
    },

    isDecimalInteger(node) {
      return node.type === "Literal" && typeof node.value === "number" && DECIMAL_INTEGER_PATTERN.test(node.raw);
    },

    isDecimalIntegerNumericToken(token) {
      return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
    },

    getFunctionNameWithKind(node) {
      const parent = node.parent;
      const tokens = [];

      if (parent.type === "MethodDefinition" && parent.static) {
        tokens.push("static");
      }

      if (node.async) {
        tokens.push("async");
      }

      if (node.generator) {
        tokens.push("generator");
      }

      if (node.type === "ArrowFunctionExpression") {
        tokens.push("arrow", "function");
      } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        if (parent.kind === "constructor") {
          return "constructor";
        }

        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else {
        tokens.push("function");
      }

      if (node.id) {
        tokens.push(`'${node.id.name}'`);
      } else {
        const name = getStaticPropertyName(parent);

        if (name !== null) {
          tokens.push(`'${name}'`);
        }
      }

      return tokens.join(" ");
    },

    getFunctionHeadLoc(node, sourceCode) {
      const parent = node.parent;
      let start = null;
      let end = null;

      if (node.type === "ArrowFunctionExpression") {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      }

      return {
        start: Object.assign({}, start),
        end: Object.assign({}, end)
      };
    },

    getNextLocation(sourceCode, {
      line,
      column
    }) {
      if (column < sourceCode.lines[line - 1].length) {
        return {
          line,
          column: column + 1
        };
      }

      if (line < sourceCode.lines.length) {
        return {
          line: line + 1,
          column: 0
        };
      }

      return null;
    },

    getParenthesisedText(sourceCode, node) {
      let leftToken = sourceCode.getFirstToken(node);
      let rightToken = sourceCode.getLastToken(node);

      while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
        leftToken = sourceCode.getTokenBefore(leftToken);
        rightToken = sourceCode.getTokenAfter(rightToken);
      }

      return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
    },

    couldBeError(node) {
      switch (node.type) {
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
        case "AwaitExpression":
        case "ChainExpression":
          return true;

        case "AssignmentExpression":
          if (["=", "&&="].includes(node.operator)) {
            return module.exports.couldBeError(node.right);
          }

          if (["||=", "??="].includes(node.operator)) {
            return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
          }

          return false;

        case "SequenceExpression":
          {
            const exprs = node.expressions;
            return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
          }

        case "LogicalExpression":
          if (node.operator === "&&") {
            return module.exports.couldBeError(node.right);
          }

          return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

        case "ConditionalExpression":
          return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

        default:
          return false;
      }
    },

    isNumericLiteral(node) {
      return node.type === "Literal" && (typeof node.value === "number" || Boolean(node.bigint));
    },

    canTokensBeAdjacent(leftValue, rightValue) {
      const espreeOptions = {
        ecmaVersion: espree__default['default'].latestEcmaVersion,
        comment: true,
        range: true
      };
      let leftToken;

      if (typeof leftValue === "string") {
        let tokens;

        try {
          tokens = espree__default['default'].tokenize(leftValue, espreeOptions);
        } catch {
          return false;
        }

        const comments = tokens.comments;
        leftToken = tokens[tokens.length - 1];

        if (comments.length) {
          const lastComment = comments[comments.length - 1];

          if (lastComment.range[0] > leftToken.range[0]) {
            leftToken = lastComment;
          }
        }
      } else {
        leftToken = leftValue;
      }

      if (leftToken.type === "Shebang") {
        return false;
      }

      let rightToken;

      if (typeof rightValue === "string") {
        let tokens;

        try {
          tokens = espree__default['default'].tokenize(rightValue, espreeOptions);
        } catch {
          return false;
        }

        const comments = tokens.comments;
        rightToken = tokens[0];

        if (comments.length) {
          const firstComment = comments[0];

          if (firstComment.range[0] < rightToken.range[0]) {
            rightToken = firstComment;
          }
        }
      } else {
        rightToken = rightValue;
      }

      if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
        if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
          const PLUS_TOKENS = new Set(["+", "++"]);
          const MINUS_TOKENS = new Set(["-", "--"]);
          return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
        }

        if (leftToken.type === "Punctuator" && leftToken.value === "/") {
          return !["Block", "Line", "RegularExpression"].includes(rightToken.type);
        }

        return true;
      }

      if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
        return true;
      }

      if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
        return true;
      }

      if (leftToken.type === "Block" || rightToken.type === "Block" || rightToken.type === "Line") {
        return true;
      }

      return false;
    },

    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {
      const namePattern = new RegExp(`[\\s,]${lodash__default['default'].escapeRegExp(name)}(?:$|[\\s,:])`, "gu");
      namePattern.lastIndex = comment.value.indexOf("global") + 6;
      const match = namePattern.exec(comment.value);
      const start = sourceCode.getLocFromIndex(comment.range[0] + 2 + (match ? match.index + 1 : 0));
      const end = {
        line: start.line,
        column: start.column + (match ? name.length : 1)
      };
      return {
        start,
        end
      };
    },

    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {
      return /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su.test(rawString);
    },

    isLogicalExpression,
    isCoalesceExpression,
    isMixedLogicalAndCoalesceExpressions: function (left, right) {
      return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);
    },
    isNullLiteral,
    getStaticStringValue,
    getStaticPropertyName,
    skipChainExpression,
    isSpecificId,
    isSpecificMemberAccess,
    equalLiteralValue,
    isSameReference,
    isLogicalAssignmentOperator: function (operator) {
      return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);
    }
  };
});

astUtils.COMMENTS_IGNORE_PATTERN;
astUtils.LINEBREAKS;
astUtils.LINEBREAK_MATCHER;
astUtils.SHEBANG_MATCHER;
astUtils.STATEMENT_LIST_PARENTS;
astUtils.isTokenOnSameLine;
astUtils.isNullOrUndefined;
astUtils.isCallee;
astUtils.isES5Constructor;
astUtils.getUpperFunction;
astUtils.isFunction;
astUtils.isLoop;
astUtils.isInLoop;
astUtils.isArrayFromMethod;
astUtils.isParenthesised;
astUtils.createGlobalLinebreakMatcher;
astUtils.equalTokens;
astUtils.isArrowToken;
astUtils.isClosingBraceToken;
astUtils.isClosingBracketToken;
astUtils.isClosingParenToken;
astUtils.isColonToken;
astUtils.isCommaToken;
astUtils.isCommentToken;
astUtils.isDotToken;
astUtils.isQuestionDotToken;
astUtils.isKeywordToken;
astUtils.isNotClosingBraceToken;
astUtils.isNotClosingBracketToken;
astUtils.isNotClosingParenToken;
astUtils.isNotColonToken;
astUtils.isNotCommaToken;
astUtils.isNotDotToken;
astUtils.isNotQuestionDotToken;
astUtils.isNotOpeningBraceToken;
astUtils.isNotOpeningBracketToken;
astUtils.isNotOpeningParenToken;
astUtils.isNotSemicolonToken;
astUtils.isOpeningBraceToken;
astUtils.isOpeningBracketToken;
astUtils.isOpeningParenToken;
astUtils.isSemicolonToken;
astUtils.isStringLiteral;
astUtils.isBreakableStatement;
astUtils.getModifyingReferences;
astUtils.isSurroundedBy;
astUtils.isDirectiveComment;
astUtils.getTrailingStatement;
astUtils.getVariableByName;
astUtils.isDefaultThisBinding;
astUtils.getPrecedence;
astUtils.isEmptyBlock;
astUtils.isEmptyFunction;
astUtils.getDirectivePrologue;
astUtils.isDecimalInteger;
astUtils.isDecimalIntegerNumericToken;
astUtils.getFunctionNameWithKind;
astUtils.getFunctionHeadLoc;
astUtils.getNextLocation;
astUtils.getParenthesisedText;
astUtils.couldBeError;
astUtils.isNumericLiteral;
astUtils.canTokensBeAdjacent;
astUtils.getNameLocationInGlobalDirectiveComment;
astUtils.hasOctalOrNonOctalDecimalEscapeSequence;
astUtils.isLogicalExpression;
astUtils.isCoalesceExpression;
astUtils.isMixedLogicalAndCoalesceExpressions;
astUtils.isNullLiteral;
astUtils.getStaticStringValue;
astUtils.getStaticPropertyName;
astUtils.skipChainExpression;
astUtils.isSpecificId;
astUtils.isSpecificMemberAccess;
astUtils.equalLiteralValue;
astUtils.isSameReference;
astUtils.isLogicalAssignmentOperator;

function areEqualTokenLists$1(left, right) {
  if (left.length !== right.length) {
    return false;
  }

  for (let i = 0; i < left.length; i++) {
    const leftToken = left[i],
          rightToken = right[i];

    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
      return false;
    }
  }

  return true;
}

function areEqualKeys$1(left, right) {
  if (typeof left === "string" && typeof right === "string") {
    return left === right;
  }

  if (Array.isArray(left) && Array.isArray(right)) {
    return areEqualTokenLists$1(left, right);
  }

  return false;
}

function isAccessorKind$1(node) {
  return node.kind === "get" || node.kind === "set";
}

function isArgumentOfMethodCall(node, index, object, property) {
  const parent = node.parent;
  return parent.type === "CallExpression" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;
}

function isPropertyDescriptor$1(node) {
  if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
    return true;
  }

  const grandparent = node.parent.parent;
  return grandparent.type === "ObjectExpression" && (isArgumentOfMethodCall(grandparent, 1, "Object", "create") || isArgumentOfMethodCall(grandparent, 1, "Object", "defineProperties"));
}

var accessorPairs = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce getter and setter pairs in objects and classes",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/accessor-pairs"
    },
    schema: [{
      type: "object",
      properties: {
        getWithoutSet: {
          type: "boolean",
          default: false
        },
        setWithoutGet: {
          type: "boolean",
          default: true
        },
        enforceForClassMembers: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
      missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
      missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
      missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
      missingGetterInClass: "Getter is not present for class {{ name }}.",
      missingSetterInClass: "Setter is not present for class {{ name }}."
    }
  },

  create(context) {
    const config = context.options[0] || {};
    const checkGetWithoutSet = config.getWithoutSet === true;
    const checkSetWithoutGet = config.setWithoutGet !== false;
    const enforceForClassMembers = config.enforceForClassMembers !== false;
    const sourceCode = context.getSourceCode();

    function report(node, messageKind) {
      if (node.type === "Property") {
        context.report({
          node,
          messageId: `${messageKind}InObjectLiteral`,
          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
          data: {
            name: astUtils.getFunctionNameWithKind(node.value)
          }
        });
      } else if (node.type === "MethodDefinition") {
        context.report({
          node,
          messageId: `${messageKind}InClass`,
          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
          data: {
            name: astUtils.getFunctionNameWithKind(node.value)
          }
        });
      } else {
        context.report({
          node,
          messageId: `${messageKind}InPropertyDescriptor`
        });
      }
    }

    function reportList(nodes, messageKind) {
      for (const node of nodes) {
        report(node, messageKind);
      }
    }

    function createAccessorData(node) {
      const name = astUtils.getStaticPropertyName(node);
      const key = name !== null ? name : sourceCode.getTokens(node.key);
      return {
        key,
        getters: node.kind === "get" ? [node] : [],
        setters: node.kind === "set" ? [node] : []
      };
    }

    function mergeAccessorData(accessors, accessorData) {
      const equalKeyElement = accessors.find(a => areEqualKeys$1(a.key, accessorData.key));

      if (equalKeyElement) {
        equalKeyElement.getters.push(...accessorData.getters);
        equalKeyElement.setters.push(...accessorData.setters);
      } else {
        accessors.push(accessorData);
      }

      return accessors;
    }

    function checkList(nodes) {
      const accessors = nodes.filter(isAccessorKind$1).map(createAccessorData).reduce(mergeAccessorData, []);

      for (const {
        getters,
        setters
      } of accessors) {
        if (checkSetWithoutGet && setters.length && !getters.length) {
          reportList(setters, "missingGetter");
        }

        if (checkGetWithoutSet && getters.length && !setters.length) {
          reportList(getters, "missingSetter");
        }
      }
    }

    function checkObjectLiteral(node) {
      checkList(node.properties.filter(p => p.type === "Property"));
    }

    function checkPropertyDescriptor(node) {
      const namesToCheck = node.properties.filter(p => p.type === "Property" && p.kind === "init" && !p.computed).map(({
        key
      }) => key.name);
      const hasGetter = namesToCheck.includes("get");
      const hasSetter = namesToCheck.includes("set");

      if (checkSetWithoutGet && hasSetter && !hasGetter) {
        report(node, "missingGetter");
      }

      if (checkGetWithoutSet && hasGetter && !hasSetter) {
        report(node, "missingSetter");
      }
    }

    function checkObjectExpression(node) {
      checkObjectLiteral(node);

      if (isPropertyDescriptor$1(node)) {
        checkPropertyDescriptor(node);
      }
    }

    function checkClassBody(node) {
      const methodDefinitions = node.body.filter(m => m.type === "MethodDefinition");
      checkList(methodDefinitions.filter(m => m.static));
      checkList(methodDefinitions.filter(m => !m.static));
    }

    const listeners = {};

    if (checkSetWithoutGet || checkGetWithoutSet) {
      listeners.ObjectExpression = checkObjectExpression;

      if (enforceForClassMembers) {
        listeners.ClassBody = checkClassBody;
      }
    }

    return listeners;
  }

};
var arrayBracketNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce linebreaks after opening and before closing array brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-bracket-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent"]
      }, {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
      unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
      missingOpeningLinebreak: "A linebreak is required after '['.",
      missingClosingLinebreak: "A linebreak is required before ']'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function normalizeOptionValue(option) {
      let consistent = false;
      let multiline = false;
      let minItems = 0;

      if (option) {
        if (option === "consistent") {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === "always" || option.minItems === 0) {
          minItems = 0;
        } else if (option === "never") {
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
      } else {
        consistent = false;
        multiline = true;
        minItems = Number.POSITIVE_INFINITY;
      }

      return {
        consistent,
        multiline,
        minItems
      };
    }

    function normalizeOptions(options) {
      const value = normalizeOptionValue(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }

    function reportNoBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedOpeningLinebreak",

        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token, {
            includeComments: true
          });

          if (astUtils.isCommentToken(nextToken)) {
            return null;
          }

          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }

      });
    }

    function reportNoEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedClosingLinebreak",

        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token, {
            includeComments: true
          });

          if (astUtils.isCommentToken(previousToken)) {
            return null;
          }

          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }

      });
    }

    function reportRequiredBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingOpeningLinebreak",

        fix(fixer) {
          return fixer.insertTextAfter(token, "\n");
        }

      });
    }

    function reportRequiredEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingClosingLinebreak",

        fix(fixer) {
          return fixer.insertTextBefore(token, "\n");
        }

      });
    }

    function check(node) {
      const elements = node.elements;
      const normalizedOptions = normalizeOptions(context.options[0]);
      const options = normalizedOptions[node.type];
      const openBracket = sourceCode.getFirstToken(node);
      const closeBracket = sourceCode.getLastToken(node);
      const firstIncComment = sourceCode.getTokenAfter(openBracket, {
        includeComments: true
      });
      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {
        includeComments: true
      });
      const first = sourceCode.getTokenAfter(openBracket);
      const last = sourceCode.getTokenBefore(closeBracket);
      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;

      if (needsLinebreaks) {
        if (astUtils.isTokenOnSameLine(openBracket, first)) {
          reportRequiredBeginningLinebreak(node, openBracket);
        }

        if (astUtils.isTokenOnSameLine(last, closeBracket)) {
          reportRequiredEndingLinebreak(node, closeBracket);
        }
      } else {
        if (!astUtils.isTokenOnSameLine(openBracket, first)) {
          reportNoBeginningLinebreak(node, openBracket);
        }

        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
          reportNoEndingLinebreak(node, closeBracket);
        }
      }
    }

    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }

};
var arrayBracketSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside array brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-bracket-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        singleValue: {
          type: "boolean"
        },
        objectsInArrays: {
          type: "boolean"
        },
        arraysInArrays: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'."
    }
  },

  create(context) {
    const spaced = context.options[0] === "always",
          sourceCode = context.getSourceCode();

    function isOptionSet(option) {
      return context.options[1] ? context.options[1][option] === !spaced : false;
    }

    const options = {
      spaced,
      singleElementException: isOptionSet("singleValue"),
      objectsInArraysException: isOptionSet("objectsInArrays"),
      arraysInArraysException: isOptionSet("arraysInArrays")
    };

    function reportNoBeginningSpace(node, token) {
      const nextToken = sourceCode.getTokenAfter(token);
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }

      });
    }

    function reportNoEndingSpace(node, token) {
      const previousToken = sourceCode.getTokenBefore(token);
      context.report({
        node,
        loc: {
          start: previousToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }

      });
    }

    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }

      });
    }

    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }

      });
    }

    function isObjectType(node) {
      return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
    }

    function isArrayType(node) {
      return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
    }

    function validateArraySpacing(node) {
      if (options.spaced && node.elements.length === 0) {
        return;
      }

      const first = sourceCode.getFirstToken(node),
            second = sourceCode.getFirstToken(node, 1),
            last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node),
            penultimate = sourceCode.getTokenBefore(last),
            firstElement = node.elements[0],
            lastElement = node.elements[node.elements.length - 1];
      const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
      const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;

      if (astUtils.isTokenOnSameLine(first, second)) {
        if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
          reportRequiredBeginningSpace(node, first);
        }

        if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
          reportNoBeginningSpace(node, first);
        }
      }

      if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
        if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
          reportRequiredEndingSpace(node, last);
        }

        if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
          reportNoEndingSpace(node, last);
        }
      }
    }

    return {
      ArrayPattern: validateArraySpacing,
      ArrayExpression: validateArraySpacing
    };
  }

};
const TARGET_NODE_TYPE$2 = /^(?:Arrow)?FunctionExpression$/u;
const TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;

function isReachable$3(segment) {
  return segment.reachable;
}

function isTargetMethod(node) {
  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);
}

function fullMethodName(arrayMethodName) {
  if (["from", "of", "isArray"].includes(arrayMethodName)) {
    return "Array.".concat(arrayMethodName);
  }

  return "Array.prototype.".concat(arrayMethodName);
}

function getArrayMethodName(node) {
  let currentNode = node;

  while (currentNode) {
    const parent = currentNode.parent;

    switch (parent.type) {
      case "LogicalExpression":
      case "ConditionalExpression":
      case "ChainExpression":
        currentNode = parent;
        break;

      case "ReturnStatement":
        {
          const func = astUtils.getUpperFunction(parent);

          if (func === null || !astUtils.isCallee(func)) {
            return null;
          }

          currentNode = func.parent;
          break;
        }

      case "CallExpression":
        if (astUtils.isArrayFromMethod(parent.callee)) {
          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {
            return "from";
          }
        }

        if (isTargetMethod(parent.callee)) {
          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {
            return astUtils.getStaticPropertyName(parent.callee);
          }
        }

        return null;

      default:
        return null;
    }
  }

  return null;
}

var arrayCallbackReturn = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in callbacks of array methods",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-callback-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: false
        },
        checkForEach: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
      expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
      expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
      expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}."
    }
  },

  create(context) {
    const options = context.options[0] || {
      allowImplicit: false,
      checkForEach: false
    };
    const sourceCode = context.getSourceCode();
    let funcInfo = {
      arrayMethodName: null,
      upper: null,
      codePath: null,
      hasReturn: false,
      shouldCheck: false,
      node: null
    };

    function checkLastSegment(node) {
      if (!funcInfo.shouldCheck) {
        return;
      }

      let messageId = null;

      if (funcInfo.arrayMethodName === "forEach") {
        if (options.checkForEach && node.type === "ArrowFunctionExpression" && node.expression) {
          messageId = "expectedNoReturnValue";
        }
      } else {
        if (node.body.type === "BlockStatement" && funcInfo.codePath.currentSegments.some(isReachable$3)) {
          messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
        }
      }

      if (messageId) {
        const name = astUtils.getFunctionNameWithKind(node);
        context.report({
          node,
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          messageId,
          data: {
            name,
            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)
          }
        });
      }
    }

    return {
      onCodePathStart(codePath, node) {
        let methodName = null;

        if (TARGET_NODE_TYPE$2.test(node.type)) {
          methodName = getArrayMethodName(node);
        }

        funcInfo = {
          arrayMethodName: methodName,
          upper: funcInfo,
          codePath,
          hasReturn: false,
          shouldCheck: methodName && !node.async && !node.generator,
          node
        };
      },

      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },

      ReturnStatement(node) {
        if (!funcInfo.shouldCheck) {
          return;
        }

        funcInfo.hasReturn = true;
        let messageId = null;

        if (funcInfo.arrayMethodName === "forEach") {
          if (options.checkForEach && node.argument) {
            messageId = "expectedNoReturnValue";
          }
        } else {
          if (!options.allowImplicit && !node.argument) {
            messageId = "expectedReturnValue";
          }
        }

        if (messageId) {
          context.report({
            node,
            messageId,
            data: {
              name: astUtils.getFunctionNameWithKind(funcInfo.node),
              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)
            }
          });
        }
      },

      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }

};
var arrayElementNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks after each array element",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-element-newline"
    },
    fixable: "whitespace",
    schema: {
      definitions: {
        basicConfig: {
          oneOf: [{
            enum: ["always", "never", "consistent"]
          }, {
            type: "object",
            properties: {
              multiline: {
                type: "boolean"
              },
              minItems: {
                type: ["integer", "null"],
                minimum: 0
              }
            },
            additionalProperties: false
          }]
        }
      },
      items: [{
        oneOf: [{
          $ref: "#/definitions/basicConfig"
        }, {
          type: "object",
          properties: {
            ArrayExpression: {
              $ref: "#/definitions/basicConfig"
            },
            ArrayPattern: {
              $ref: "#/definitions/basicConfig"
            }
          },
          additionalProperties: false,
          minProperties: 1
        }]
      }]
    },
    messages: {
      unexpectedLineBreak: "There should be no linebreak here.",
      missingLineBreak: "There should be a linebreak after this element."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function normalizeOptionValue(providedOption) {
      let consistent = false;
      let multiline = false;
      let minItems;
      const option = providedOption || "always";

      if (!option || option === "always" || option.minItems === 0) {
        minItems = 0;
      } else if (option === "never") {
        minItems = Number.POSITIVE_INFINITY;
      } else if (option === "consistent") {
        consistent = true;
        minItems = Number.POSITIVE_INFINITY;
      } else {
        multiline = Boolean(option.multiline);
        minItems = option.minItems || Number.POSITIVE_INFINITY;
      }

      return {
        consistent,
        multiline,
        minItems
      };
    }

    function normalizeOptions(options) {
      if (options && (options.ArrayExpression || options.ArrayPattern)) {
        let expressionOptions, patternOptions;

        if (options.ArrayExpression) {
          expressionOptions = normalizeOptionValue(options.ArrayExpression);
        }

        if (options.ArrayPattern) {
          patternOptions = normalizeOptionValue(options.ArrayPattern);
        }

        return {
          ArrayExpression: expressionOptions,
          ArrayPattern: patternOptions
        };
      }

      const value = normalizeOptionValue(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }

    function reportNoLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedLineBreak",

        fix(fixer) {
          if (astUtils.isCommentToken(tokenBefore)) {
            return null;
          }

          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
          }

          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {
            includeComments: true
          });

          if (astUtils.isCommentToken(twoTokensBefore)) {
            return null;
          }

          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
        }

      });
    }

    function reportRequiredLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "missingLineBreak",

        fix(fixer) {
          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
        }

      });
    }

    function check(node) {
      const elements = node.elements;
      const normalizedOptions = normalizeOptions(context.options[0]);
      const options = normalizedOptions[node.type];

      if (!options) {
        return;
      }

      let elementBreak = false;

      if (options.multiline) {
        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);
      }

      const linebreaksCount = node.elements.map((element, i) => {
        const previousElement = elements[i - 1];

        if (i === 0 || element === null || previousElement === null) {
          return false;
        }

        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
      }).filter(isBreak => isBreak === true).length;
      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
      elements.forEach((element, i) => {
        const previousElement = elements[i - 1];

        if (i === 0 || element === null || previousElement === null) {
          return;
        }

        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

        if (needsLinebreaks) {
          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportRequiredLineBreak(firstTokenOfCurrentElement);
          }
        } else {
          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportNoLineBreak(firstTokenOfCurrentElement);
          }
        }
      });
    }

    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }

};
var arrowBodyStyle = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require braces around arrow function bodies",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-body-style"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["as-needed"]
        }, {
          type: "object",
          properties: {
            requireReturnForObjectLiteral: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
      unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
      unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
      unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
      expectedBlock: "Expected block statement surrounding arrow body."
    }
  },

  create(context) {
    const options = context.options;
    const always = options[0] === "always";
    const asNeeded = !options[0] || options[0] === "as-needed";
    const never = options[0] === "never";
    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
    const sourceCode = context.getSourceCode();
    let funcInfo = null;

    function hasASIProblem(token) {
      return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
    }

    function findClosingParen(token) {
      let node = sourceCode.getNodeByRangeIndex(token.range[0]);

      while (!astUtils.isParenthesised(sourceCode, node)) {
        node = node.parent;
      }

      return sourceCode.getTokenAfter(node);
    }

    function isInsideForLoopInitializer(node) {
      if (node && node.parent) {
        if (node.parent.type === "ForStatement" && node.parent.init === node) {
          return true;
        }

        return isInsideForLoopInitializer(node.parent);
      }

      return false;
    }

    function validate(node) {
      const arrowBody = node.body;

      if (arrowBody.type === "BlockStatement") {
        const blockBody = arrowBody.body;

        if (blockBody.length !== 1 && !never) {
          return;
        }

        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
          return;
        }

        if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
          let messageId;

          if (blockBody.length === 0) {
            messageId = "unexpectedEmptyBlock";
          } else if (blockBody.length > 1) {
            messageId = "unexpectedOtherBlock";
          } else if (blockBody[0].argument === null) {
            messageId = "unexpectedSingleBlock";
          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {
            skip: 1
          }))) {
            messageId = "unexpectedObjectBlock";
          } else {
            messageId = "unexpectedSingleBlock";
          }

          context.report({
            node,
            loc: arrowBody.loc,
            messageId,

            fix(fixer) {
              const fixes = [];

              if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
                return fixes;
              }

              const openingBrace = sourceCode.getFirstToken(arrowBody);
              const closingBrace = sourceCode.getLastToken(arrowBody);
              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
              const lastValueToken = sourceCode.getLastToken(blockBody[0]);
              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);

              if (commentsExist) {
                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)));
              } else {
                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));
              }

              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === "SequenceExpression" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {
                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {
                  fixes.push(fixer.insertTextBefore(firstValueToken, "("), fixer.insertTextAfter(lastValueToken, ")"));
                }
              }

              if (astUtils.isSemicolonToken(lastValueToken)) {
                fixes.push(fixer.remove(lastValueToken));
              }

              return fixes;
            }

          });
        }
      } else {
        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
          context.report({
            node,
            loc: arrowBody.loc,
            messageId: "expectedBlock",

            fix(fixer) {
              const fixes = [];
              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
              const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {
                count: 2
              });
              const lastToken = sourceCode.getLastToken(node);
              const isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow);

              if (isParenthesisedObjectLiteral) {
                const openingParenToken = firstTokenAfterArrow;
                const openingBraceToken = secondTokenAfterArrow;

                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {
                  fixes.push(fixer.replaceText(openingParenToken, "{return "));
                } else {
                  fixes.push(fixer.replaceText(openingParenToken, "{"), fixer.insertTextBefore(openingBraceToken, "return "));
                }

                fixes.push(fixer.remove(findClosingParen(openingBraceToken)));
                fixes.push(fixer.insertTextAfter(lastToken, "}"));
              } else {
                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, "{return "));
                fixes.push(fixer.insertTextAfter(lastToken, "}"));
              }

              return fixes;
            }

          });
        }
      }
    }

    return {
      "BinaryExpression[operator='in']"() {
        let info = funcInfo;

        while (info) {
          info.hasInOperator = true;
          info = info.upper;
        }
      },

      ArrowFunctionExpression() {
        funcInfo = {
          upper: funcInfo,
          hasInOperator: false
        };
      },

      "ArrowFunctionExpression:exit"(node) {
        validate(node);
        funcInfo = funcInfo.upper;
      }

    };
  }

};

function hasBlockBody(node) {
  return node.body.type === "BlockStatement";
}

var arrowParens = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around arrow function arguments",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-parens"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "as-needed"]
    }, {
      type: "object",
      properties: {
        requireForBlockBody: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedParens: "Unexpected parentheses around single function argument.",
      expectedParens: "Expected parentheses around arrow function argument.",
      unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
      expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
    }
  },

  create(context) {
    const asNeeded = context.options[0] === "as-needed";
    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
    const sourceCode = context.getSourceCode();

    function findOpeningParenOfParams(node) {
      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);

      if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {
        return tokenBeforeParams;
      }

      return null;
    }

    function getClosingParenOfParams(node) {
      return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);
    }

    function hasCommentsInParensOfParams(node, openingParen) {
      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));
    }

    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {
      const expectedCount = node.async ? 1 : 0;
      return sourceCode.getFirstToken(node, {
        skip: expectedCount
      }) !== openingParen;
    }

    return {
      "ArrowFunctionExpression[params.length=1]"(node) {
        const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);
        const openingParen = findOpeningParenOfParams(node);
        const hasParens = openingParen !== null;
        const [param] = node.params;

        if (shouldHaveParens && !hasParens) {
          context.report({
            node,
            messageId: requireForBlockBody ? "expectedParensBlock" : "expectedParens",
            loc: param.loc,

            *fix(fixer) {
              yield fixer.insertTextBefore(param, "(");
              yield fixer.insertTextAfter(param, ")");
            }

          });
        }

        if (!shouldHaveParens && hasParens && param.type === "Identifier" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {
          context.report({
            node,
            messageId: requireForBlockBody ? "unexpectedParensInline" : "unexpectedParens",
            loc: param.loc,

            *fix(fixer) {
              const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);
              const closingParen = getClosingParenOfParams(node);

              if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {
                yield fixer.insertTextBefore(openingParen, " ");
              }

              yield fixer.removeRange([openingParen.range[0], param.range[0]]);
              yield fixer.removeRange([param.range[1], closingParen.range[1]]);
            }

          });
        }
      }

    };
  }

};
var arrowSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after the arrow in arrow functions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: true
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedBefore: "Missing space before =>.",
      unexpectedBefore: "Unexpected space before =>.",
      expectedAfter: "Missing space after =>.",
      unexpectedAfter: "Unexpected space after =>."
    }
  },

  create(context) {
    const rule = Object.assign({}, context.options[0]);
    rule.before = rule.before !== false;
    rule.after = rule.after !== false;
    const sourceCode = context.getSourceCode();

    function getTokens(node) {
      const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);
      return {
        before: sourceCode.getTokenBefore(arrow),
        arrow,
        after: sourceCode.getTokenAfter(arrow)
      };
    }

    function countSpaces(tokens) {
      const before = tokens.arrow.range[0] - tokens.before.range[1];
      const after = tokens.after.range[0] - tokens.arrow.range[1];
      return {
        before,
        after
      };
    }

    return {
      ArrowFunctionExpression: function (node) {
        const tokens = getTokens(node);
        const countSpace = countSpaces(tokens);

        if (rule.before) {
          if (countSpace.before === 0) {
            context.report({
              node: tokens.before,
              messageId: "expectedBefore",

              fix(fixer) {
                return fixer.insertTextBefore(tokens.arrow, " ");
              }

            });
          }
        } else {
          if (countSpace.before > 0) {
            context.report({
              node: tokens.before,
              messageId: "unexpectedBefore",

              fix(fixer) {
                return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
              }

            });
          }
        }

        if (rule.after) {
          if (countSpace.after === 0) {
            context.report({
              node: tokens.after,
              messageId: "expectedAfter",

              fix(fixer) {
                return fixer.insertTextAfter(tokens.arrow, " ");
              }

            });
          }
        } else {
          if (countSpace.after > 0) {
            context.report({
              node: tokens.after,
              messageId: "unexpectedAfter",

              fix(fixer) {
                return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
              }

            });
          }
        }
      }
    };
  }

};
var blockScopedVar = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of variables within the scope they are defined",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/block-scoped-var"
    },
    schema: [],
    messages: {
      outOfScope: "'{{name}}' used outside of binding context."
    }
  },

  create(context) {
    let stack = [];

    function enterScope(node) {
      stack.push(node.range);
    }

    function exitScope() {
      stack.pop();
    }

    function report(reference) {
      const identifier = reference.identifier;
      context.report({
        node: identifier,
        messageId: "outOfScope",
        data: {
          name: identifier.name
        }
      });
    }

    function checkForVariables(node) {
      if (node.kind !== "var") {
        return;
      }

      const scopeRange = stack[stack.length - 1];

      function isOutsideOfScope(reference) {
        const idRange = reference.identifier.range;
        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
      }

      const variables = context.getDeclaredVariables(node);

      for (let i = 0; i < variables.length; ++i) {
        variables[i].references.filter(isOutsideOfScope).forEach(report);
      }
    }

    return {
      Program(node) {
        stack = [node.range];
      },

      BlockStatement: enterScope,
      "BlockStatement:exit": exitScope,
      ForStatement: enterScope,
      "ForStatement:exit": exitScope,
      ForInStatement: enterScope,
      "ForInStatement:exit": exitScope,
      ForOfStatement: enterScope,
      "ForOfStatement:exit": exitScope,
      SwitchStatement: enterScope,
      "SwitchStatement:exit": exitScope,
      CatchClause: enterScope,
      "CatchClause:exit": exitScope,
      VariableDeclaration: checkForVariables
    };
  }

};
var blockSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/block-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      missing: "Requires a space {{location}} '{{token}}'.",
      extra: "Unexpected space(s) {{location}} '{{token}}'."
    }
  },

  create(context) {
    const always = context.options[0] !== "never",
          messageId = always ? "missing" : "extra",
          sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
      if (node.type === "SwitchStatement") {
        if (node.cases.length > 0) {
          return sourceCode.getTokenBefore(node.cases[0]);
        }

        return sourceCode.getLastToken(node, 1);
      }

      return sourceCode.getFirstToken(node);
    }

    function isValid(left, right) {
      return !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
    }

    function checkSpacingInsideBraces(node) {
      const openBrace = getOpenBrace(node);
      const closeBrace = sourceCode.getLastToken(node);
      const firstToken = sourceCode.getTokenAfter(openBrace, {
        includeComments: true
      });
      const lastToken = sourceCode.getTokenBefore(closeBrace, {
        includeComments: true
      });

      if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
        return;
      }

      if (!always && firstToken.type === "Line") {
        return;
      }

      if (!isValid(openBrace, firstToken)) {
        let loc = openBrace.loc;

        if (messageId === "extra") {
          loc = {
            start: openBrace.loc.end,
            end: firstToken.loc.start
          };
        }

        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "after",
            token: openBrace.value
          },

          fix(fixer) {
            if (always) {
              return fixer.insertTextBefore(firstToken, " ");
            }

            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
          }

        });
      }

      if (!isValid(lastToken, closeBrace)) {
        let loc = closeBrace.loc;

        if (messageId === "extra") {
          loc = {
            start: lastToken.loc.end,
            end: closeBrace.loc.start
          };
        }

        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "before",
            token: closeBrace.value
          },

          fix(fixer) {
            if (always) {
              return fixer.insertTextAfter(lastToken, " ");
            }

            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
          }

        });
      }
    }

    return {
      BlockStatement: checkSpacingInsideBraces,
      SwitchStatement: checkSpacingInsideBraces
    };
  }

};
var braceStyle = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent brace style for blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/brace-style"
    },
    schema: [{
      enum: ["1tbs", "stroustrup", "allman"]
    }, {
      type: "object",
      properties: {
        allowSingleLine: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace",
    messages: {
      nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
      sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
      blockSameLine: "Statement inside of curly braces should be on next line.",
      nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
      singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
      sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
    }
  },

  create(context) {
    const style = context.options[0] || "1tbs",
          params = context.options[1] || {},
          sourceCode = context.getSourceCode();

    function removeNewlineBetween(firstToken, secondToken) {
      const textRange = [firstToken.range[1], secondToken.range[0]];
      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);

      if (textBetween.trim()) {
        return null;
      }

      return fixer => fixer.replaceTextRange(textRange, " ");
    }

    function validateCurlyPair(openingCurly, closingCurly) {
      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);

      if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
        context.report({
          node: openingCurly,
          messageId: "nextLineOpen",
          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
        });
      }

      if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
        context.report({
          node: openingCurly,
          messageId: "sameLineOpen",
          fix: fixer => fixer.insertTextBefore(openingCurly, "\n")
        });
      }

      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
        context.report({
          node: openingCurly,
          messageId: "blockSameLine",
          fix: fixer => fixer.insertTextAfter(openingCurly, "\n")
        });
      }

      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
        context.report({
          node: closingCurly,
          messageId: "singleLineClose",
          fix: fixer => fixer.insertTextBefore(closingCurly, "\n")
        });
      }
    }

    function validateCurlyBeforeKeyword(curlyToken) {
      const keywordToken = sourceCode.getTokenAfter(curlyToken);

      if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
        context.report({
          node: curlyToken,
          messageId: "nextLineClose",
          fix: removeNewlineBetween(curlyToken, keywordToken)
        });
      }

      if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
        context.report({
          node: curlyToken,
          messageId: "sameLineClose",
          fix: fixer => fixer.insertTextAfter(curlyToken, "\n")
        });
      }
    }

    return {
      BlockStatement(node) {
        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
        }
      },

      ClassBody(node) {
        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      },

      SwitchStatement(node) {
        const closingCurly = sourceCode.getLastToken(node);
        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);
        validateCurlyPair(openingCurly, closingCurly);
      },

      IfStatement(node) {
        if (node.consequent.type === "BlockStatement" && node.alternate) {
          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
        }
      },

      TryStatement(node) {
        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));

        if (node.handler && node.finalizer) {
          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
        }
      }

    };
  }

};
var callbackReturn = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require `return` statements after callbacks",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/callback-return"
    },
    schema: [{
      type: "array",
      items: {
        type: "string"
      }
    }],
    messages: {
      missingReturn: "Expected return with your callback function."
    }
  },

  create(context) {
    const callbacks = context.options[0] || ["callback", "cb", "next"],
          sourceCode = context.getSourceCode();

    function findClosestParentOfType(node, types) {
      if (!node.parent) {
        return null;
      }

      if (types.indexOf(node.parent.type) === -1) {
        return findClosestParentOfType(node.parent, types);
      }

      return node.parent;
    }

    function containsOnlyIdentifiers(node) {
      if (node.type === "Identifier") {
        return true;
      }

      if (node.type === "MemberExpression") {
        if (node.object.type === "Identifier") {
          return true;
        }

        if (node.object.type === "MemberExpression") {
          return containsOnlyIdentifiers(node.object);
        }
      }

      return false;
    }

    function isCallback(node) {
      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
    }

    function isCallbackExpression(node, parentNode) {
      if (!parentNode || parentNode.type !== "ExpressionStatement") {
        return false;
      }

      if (parentNode.expression === node) {
        return true;
      }

      if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
        if (parentNode.expression.right === node) {
          return true;
        }
      }

      return false;
    }

    return {
      CallExpression(node) {
        if (!isCallback(node)) {
          return;
        }

        const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};

        if (closestBlock.type === "ReturnStatement") {
          return;
        }

        if (closestBlock.type === "ArrowFunctionExpression") {
          return;
        }

        if (closestBlock.type === "BlockStatement") {
          const lastItem = closestBlock.body[closestBlock.body.length - 1];

          if (isCallbackExpression(node, lastItem)) {
            const parentType = closestBlock.parent.type;

            if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
              return;
            }
          }

          if (lastItem.type === "ReturnStatement") {
            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
              return;
            }
          }
        }

        if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
          context.report({
            node,
            messageId: "missingReturn"
          });
        }
      }

    };
  }

};
var camelcase = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce camelcase naming convention",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/camelcase"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: false
        },
        ignoreImports: {
          type: "boolean",
          default: false
        },
        ignoreGlobals: {
          type: "boolean",
          default: false
        },
        properties: {
          enum: ["always", "never"]
        },
        allow: {
          type: "array",
          items: [{
            type: "string"
          }],
          minItems: 0,
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      notCamelCase: "Identifier '{{name}}' is not in camel case."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    let properties = options.properties || "";
    const ignoreDestructuring = options.ignoreDestructuring;
    const ignoreImports = options.ignoreImports;
    const ignoreGlobals = options.ignoreGlobals;
    const allow = options.allow || [];
    let globalScope;

    if (properties !== "always" && properties !== "never") {
      properties = "always";
    }

    const reported = [];
    const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);

    function isUnderscored(name) {
      return name.includes("_") && name !== name.toUpperCase();
    }

    function isAllowed(name) {
      return allow.some(entry => name === entry || name.match(new RegExp(entry, "u")));
    }

    function isInsideObjectPattern(node) {
      let current = node;

      while (current) {
        const parent = current.parent;

        if (parent && parent.type === "Property" && parent.computed && parent.key === current) {
          return false;
        }

        if (current.type === "ObjectPattern") {
          return true;
        }

        current = parent;
      }

      return false;
    }

    function isAssignmentTargetPropertyInDestructuring(node) {
      if (node.parent.type === "MemberExpression" && node.parent.property === node && !node.parent.computed) {
        const effectiveParent = node.parent.parent;
        return effectiveParent.type === "Property" && effectiveParent.value === node.parent && effectiveParent.parent.type === "ObjectPattern" || effectiveParent.type === "ArrayPattern" || effectiveParent.type === "RestElement" || effectiveParent.type === "AssignmentPattern" && effectiveParent.left === node.parent;
      }

      return false;
    }

    function isReferenceToGlobalVariable(node) {
      const variable = globalScope.set.get(node.name);
      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);
    }

    function isPropertyNameInObjectLiteral(node) {
      const parent = node.parent;
      return parent.type === "Property" && parent.parent.type === "ObjectExpression" && !parent.computed && parent.key === node;
    }

    function report(node) {
      if (!reported.includes(node)) {
        reported.push(node);
        context.report({
          node,
          messageId: "notCamelCase",
          data: {
            name: node.name
          }
        });
      }
    }

    return {
      Program() {
        globalScope = context.getScope();
      },

      Identifier(node) {
        const name = node.name,
              nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, "")),
              effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;

        if (isAllowed(name)) {
          return;
        }

        if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {
          return;
        }

        if (node.parent.type === "MemberExpression") {
          if (properties === "never") {
            return;
          }

          if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && nameIsUnderscored) {
            report(node);
          } else if (effectiveParent.type === "AssignmentExpression" && nameIsUnderscored && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
            report(node);
          } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {
            report(node);
          }
        } else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") {
          if (node.parent.parent && node.parent.parent.type === "ObjectPattern") {
            if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {
              report(node);
            }

            const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;

            if (nameIsUnderscored && node.parent.computed) {
              report(node);
            }

            if (node.parent.key === node && node.parent.value !== node) {
              return;
            }

            const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;

            if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
              report(node);
            }
          }

          if (properties === "never" || ignoreDestructuring && isInsideObjectPattern(node)) {
            return;
          }

          if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {
            report(node);
          }
        } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].includes(node.parent.type)) {
          if (node.parent.type === "ImportSpecifier" && ignoreImports) {
            return;
          }

          if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {
            report(node);
          }
        } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
          report(node);
        }
      }

    };
  }

};
/**
 * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
 * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
 * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
 * @author Kevin Partington
 * @license MIT License (from JSCS). See below.
 */

var letters = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;
const DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
      WHITESPACE = /\s/gu,
      MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u;
const SCHEMA_BODY = {
  type: "object",
  properties: {
    ignorePattern: {
      type: "string"
    },
    ignoreInlineComments: {
      type: "boolean"
    },
    ignoreConsecutiveComments: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
const DEFAULTS = {
  ignorePattern: "",
  ignoreInlineComments: false,
  ignoreConsecutiveComments: false
};

function getNormalizedOptions(rawOptions, which) {
  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
}

function getAllNormalizedOptions(rawOptions = {}) {
  return {
    Line: getNormalizedOptions(rawOptions, "line"),
    Block: getNormalizedOptions(rawOptions, "block")
  };
}

function createRegExpForIgnorePatterns(normalizedOptions) {
  Object.keys(normalizedOptions).forEach(key => {
    const ignorePatternStr = normalizedOptions[key].ignorePattern;

    if (ignorePatternStr) {
      const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`, "u");
      normalizedOptions[key].ignorePatternRegExp = regExp;
    }
  });
}

var capitalizedComments = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce or disallow capitalization of the first letter of a comment",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/capitalized-comments"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "never"]
    }, {
      oneOf: [SCHEMA_BODY, {
        type: "object",
        properties: {
          line: SCHEMA_BODY,
          block: SCHEMA_BODY
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
      unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
    }
  },

  create(context) {
    const capitalize = context.options[0] || "always",
          normalizedOptions = getAllNormalizedOptions(context.options[1]),
          sourceCode = context.getSourceCode();
    createRegExpForIgnorePatterns(normalizedOptions);

    function isInlineComment(comment) {
      const previousToken = sourceCode.getTokenBefore(comment, {
        includeComments: true
      }),
            nextToken = sourceCode.getTokenAfter(comment, {
        includeComments: true
      });
      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);
    }

    function isConsecutiveComment(comment) {
      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {
        includeComments: true
      });
      return Boolean(previousTokenOrComment && ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1);
    }

    function isCommentValid(comment, options) {
      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
        return true;
      }

      const commentWithoutAsterisks = comment.value.replace(/\*/gu, "");

      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
        return true;
      }

      if (options.ignoreInlineComments && isInlineComment(comment)) {
        return true;
      }

      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
        return true;
      }

      if (MAYBE_URL.test(commentWithoutAsterisks)) {
        return true;
      }

      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");

      if (commentWordCharsOnly.length === 0) {
        return true;
      }

      const firstWordChar = commentWordCharsOnly[0];

      if (!letters.test(firstWordChar)) {
        return true;
      }

      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
            isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();

      if (capitalize === "always" && isLowercase) {
        return false;
      }

      if (capitalize === "never" && isUppercase) {
        return false;
      }

      return true;
    }

    function processComment(comment) {
      const options = normalizedOptions[comment.type],
            commentValid = isCommentValid(comment, options);

      if (!commentValid) {
        const messageId = capitalize === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
        context.report({
          node: null,
          loc: comment.loc,
          messageId,

          fix(fixer) {
            const match = comment.value.match(letters);
            return fixer.replaceTextRange([comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());
          }

        });
      }
    }

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(processComment);
      }

    };
  }

};
var classMethodsUseThis = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce that class methods utilize `this`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/class-methods-use-this"
    },
    schema: [{
      type: "object",
      properties: {
        exceptMethods: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingThis: "Expected 'this' to be used by class {{name}}."
    }
  },

  create(context) {
    const config = Object.assign({}, context.options[0]);
    const exceptMethods = new Set(config.exceptMethods || []);
    const stack = [];

    function enterFunction() {
      stack.push(false);
    }

    function isInstanceMethod(node) {
      return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
    }

    function isIncludedInstanceMethod(node) {
      return isInstanceMethod(node) && (node.computed || !exceptMethods.has(node.key.name));
    }

    function exitFunction(node) {
      const methodUsesThis = stack.pop();

      if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
        context.report({
          node,
          messageId: "missingThis",
          data: {
            name: astUtils.getFunctionNameWithKind(node)
          }
        });
      }
    }

    function markThisUsed() {
      if (stack.length) {
        stack[stack.length - 1] = true;
      }
    }

    return {
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      ThisExpression: markThisUsed,
      Super: markThisUsed
    };
  }

};
const DEFAULT_OPTIONS$1 = Object.freeze({
  arrays: "never",
  objects: "never",
  imports: "never",
  exports: "never",
  functions: "never"
});

function isTrailingCommaAllowed(lastItem) {
  return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
}

function normalizeOptions$2(optionValue, ecmaVersion) {
  if (typeof optionValue === "string") {
    return {
      arrays: optionValue,
      objects: optionValue,
      imports: optionValue,
      exports: optionValue,
      functions: !ecmaVersion || ecmaVersion < 8 ? "ignore" : optionValue
    };
  }

  if (typeof optionValue === "object" && optionValue !== null) {
    return {
      arrays: optionValue.arrays || DEFAULT_OPTIONS$1.arrays,
      objects: optionValue.objects || DEFAULT_OPTIONS$1.objects,
      imports: optionValue.imports || DEFAULT_OPTIONS$1.imports,
      exports: optionValue.exports || DEFAULT_OPTIONS$1.exports,
      functions: optionValue.functions || DEFAULT_OPTIONS$1.functions
    };
  }

  return DEFAULT_OPTIONS$1;
}

var commaDangle = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow trailing commas",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-dangle"
    },
    fixable: "code",
    schema: {
      definitions: {
        value: {
          enum: ["always-multiline", "always", "never", "only-multiline"]
        },
        valueWithIgnore: {
          enum: ["always-multiline", "always", "ignore", "never", "only-multiline"]
        }
      },
      type: "array",
      items: [{
        oneOf: [{
          $ref: "#/definitions/value"
        }, {
          type: "object",
          properties: {
            arrays: {
              $ref: "#/definitions/valueWithIgnore"
            },
            objects: {
              $ref: "#/definitions/valueWithIgnore"
            },
            imports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            exports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            functions: {
              $ref: "#/definitions/valueWithIgnore"
            }
          },
          additionalProperties: false
        }]
      }]
    },
    messages: {
      unexpected: "Unexpected trailing comma.",
      missing: "Missing trailing comma."
    }
  },

  create(context) {
    const options = normalizeOptions$2(context.options[0], context.parserOptions.ecmaVersion);
    const sourceCode = context.getSourceCode();

    function getLastItem(node) {
      switch (node.type) {
        case "ObjectExpression":
        case "ObjectPattern":
          return lodash__default['default'].last(node.properties);

        case "ArrayExpression":
        case "ArrayPattern":
          return lodash__default['default'].last(node.elements);

        case "ImportDeclaration":
        case "ExportNamedDeclaration":
          return lodash__default['default'].last(node.specifiers);

        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
          return lodash__default['default'].last(node.params);

        case "CallExpression":
        case "NewExpression":
          return lodash__default['default'].last(node.arguments);

        default:
          return null;
      }
    }

    function getTrailingToken(node, lastItem) {
      switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "CallExpression":
        case "NewExpression":
          return sourceCode.getLastToken(node, 1);

        default:
          {
            const nextToken = sourceCode.getTokenAfter(lastItem);

            if (astUtils.isCommaToken(nextToken)) {
              return nextToken;
            }

            return sourceCode.getLastToken(lastItem);
          }
      }
    }

    function isMultiline(node) {
      const lastItem = getLastItem(node);

      if (!lastItem) {
        return false;
      }

      const penultimateToken = getTrailingToken(node, lastItem);
      const lastToken = sourceCode.getTokenAfter(penultimateToken);
      return lastToken.loc.end.line !== penultimateToken.loc.end.line;
    }

    function forbidTrailingComma(node) {
      const lastItem = getLastItem(node);

      if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
        return;
      }

      const trailingToken = getTrailingToken(node, lastItem);

      if (astUtils.isCommaToken(trailingToken)) {
        context.report({
          node: lastItem,
          loc: trailingToken.loc,
          messageId: "unexpected",

          fix(fixer) {
            return fixer.remove(trailingToken);
          }

        });
      }
    }

    function forceTrailingComma(node) {
      const lastItem = getLastItem(node);

      if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
        return;
      }

      if (!isTrailingCommaAllowed(lastItem)) {
        forbidTrailingComma(node);
        return;
      }

      const trailingToken = getTrailingToken(node, lastItem);

      if (trailingToken.value !== ",") {
        context.report({
          node: lastItem,
          loc: {
            start: trailingToken.loc.end,
            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)
          },
          messageId: "missing",

          fix(fixer) {
            return fixer.insertTextAfter(trailingToken, ",");
          }

        });
      }
    }

    const predicate = {
      always: forceTrailingComma,
      "always-multiline": function (node) {
        if (isMultiline(node)) {
          forceTrailingComma(node);
        } else {
          forbidTrailingComma(node);
        }
      },
      "only-multiline": function (node) {
        if (!isMultiline(node)) {
          forbidTrailingComma(node);
        }
      },
      never: forbidTrailingComma,
      ignore: lodash__default['default'].noop
    };
    return {
      ObjectExpression: predicate[options.objects],
      ObjectPattern: predicate[options.objects],
      ArrayExpression: predicate[options.arrays],
      ArrayPattern: predicate[options.arrays],
      ImportDeclaration: predicate[options.imports],
      ExportNamedDeclaration: predicate[options.exports],
      FunctionDeclaration: predicate[options.functions],
      FunctionExpression: predicate[options.functions],
      ArrowFunctionExpression: predicate[options.functions],
      CallExpression: predicate[options.functions],
      NewExpression: predicate[options.functions]
    };
  }

};
var commaSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after commas",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      missing: "A space is required {{loc}} ','.",
      unexpected: "There should be no space {{loc}} ','."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const tokensAndComments = sourceCode.tokensAndComments;
    const options = {
      before: context.options[0] ? context.options[0].before : false,
      after: context.options[0] ? context.options[0].after : true
    };
    const commaTokensToIgnore = [];

    function report(node, loc, otherNode) {
      context.report({
        node,

        fix(fixer) {
          if (options[loc]) {
            if (loc === "before") {
              return fixer.insertTextBefore(node, " ");
            }

            return fixer.insertTextAfter(node, " ");
          }

          let start, end;

          if (loc === "before") {
            start = otherNode.range[1];
            end = node.range[0];
          } else {
            start = node.range[1];
            end = otherNode.range[0];
          }

          return fixer.replaceTextRange([start, end], "");
        },

        messageId: options[loc] ? "missing" : "unexpected",
        data: {
          loc
        }
      });
    }

    function validateCommaItemSpacing(tokens, reportItem) {
      if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {
        report(reportItem, "before", tokens.left);
      }

      if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {
        return;
      }

      if (tokens.right && !options.after && tokens.right.type === "Line") {
        return;
      }

      if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {
        report(reportItem, "after", tokens.right);
      }
    }

    function addNullElementsToIgnoreList(node) {
      let previousToken = sourceCode.getFirstToken(node);
      node.elements.forEach(element => {
        let token;

        if (element === null) {
          token = sourceCode.getTokenAfter(previousToken);

          if (astUtils.isCommaToken(token)) {
            commaTokensToIgnore.push(token);
          }
        } else {
          token = sourceCode.getTokenAfter(element);
        }

        previousToken = token;
      });
    }

    return {
      "Program:exit"() {
        tokensAndComments.forEach((token, i) => {
          if (!astUtils.isCommaToken(token)) {
            return;
          }

          if (token && token.type === "JSXText") {
            return;
          }

          const previousToken = tokensAndComments[i - 1];
          const nextToken = tokensAndComments[i + 1];
          validateCommaItemSpacing({
            comma: token,
            left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
            right: astUtils.isCommaToken(nextToken) ? null : nextToken
          }, token);
        });
      },

      ArrayExpression: addNullElementsToIgnoreList,
      ArrayPattern: addNullElementsToIgnoreList
    };
  }

};
var commaStyle = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent comma style",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-style"
    },
    fixable: "code",
    schema: [{
      enum: ["first", "last"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
      expectedCommaFirst: "',' should be placed first.",
      expectedCommaLast: "',' should be placed last."
    }
  },

  create(context) {
    const style = context.options[0] || "last",
          sourceCode = context.getSourceCode();
    const exceptions = {
      ArrayPattern: true,
      ArrowFunctionExpression: true,
      CallExpression: true,
      FunctionDeclaration: true,
      FunctionExpression: true,
      ImportDeclaration: true,
      ObjectPattern: true,
      NewExpression: true
    };

    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], "exceptions")) {
      const keys = Object.keys(context.options[1].exceptions);

      for (let i = 0; i < keys.length; i++) {
        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
      }
    }

    function getReplacedText(styleType, text) {
      switch (styleType) {
        case "between":
          return `,${text.replace(astUtils.LINEBREAK_MATCHER, "")}`;

        case "first":
          return `${text},`;

        case "last":
          return `,${text}`;

        default:
          return "";
      }
    }

    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
      const range = [previousItemToken.range[1], currentItemToken.range[0]];
      return function (fixer) {
        return fixer.replaceTextRange(range, getReplacedText(styleType, text));
      };
    }

    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) ;else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
        const comment = sourceCode.getCommentsAfter(commaToken)[0];
        const styleType = comment && comment.type === "Block" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : "between";
        context.report({
          node: reportItem,
          loc: commaToken.loc,
          messageId: "unexpectedLineBeforeAndAfterComma",
          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)
        });
      } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
        context.report({
          node: reportItem,
          loc: commaToken.loc,
          messageId: "expectedCommaFirst",
          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
        });
      } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
        context.report({
          node: reportItem,
          loc: commaToken.loc,
          messageId: "expectedCommaLast",
          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
        });
      }
    }

    function validateComma(node, property) {
      const items = node[property],
            arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";

      if (items.length > 1 || arrayLiteral) {
        let previousItemToken = sourceCode.getFirstToken(node);
        items.forEach(item => {
          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
                currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken);

          if (astUtils.isCommaToken(commaToken)) {
            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, item || currentItemToken);
          }

          if (item) {
            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);
            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
          }
        });

        if (arrayLiteral) {
          const lastToken = sourceCode.getLastToken(node),
                nextToLastToken = sourceCode.getTokenBefore(lastToken);

          if (astUtils.isCommaToken(nextToLastToken)) {
            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);
          }
        }
      }
    }

    const nodes = {};

    if (!exceptions.VariableDeclaration) {
      nodes.VariableDeclaration = function (node) {
        validateComma(node, "declarations");
      };
    }

    if (!exceptions.ObjectExpression) {
      nodes.ObjectExpression = function (node) {
        validateComma(node, "properties");
      };
    }

    if (!exceptions.ObjectPattern) {
      nodes.ObjectPattern = function (node) {
        validateComma(node, "properties");
      };
    }

    if (!exceptions.ArrayExpression) {
      nodes.ArrayExpression = function (node) {
        validateComma(node, "elements");
      };
    }

    if (!exceptions.ArrayPattern) {
      nodes.ArrayPattern = function (node) {
        validateComma(node, "elements");
      };
    }

    if (!exceptions.FunctionDeclaration) {
      nodes.FunctionDeclaration = function (node) {
        validateComma(node, "params");
      };
    }

    if (!exceptions.FunctionExpression) {
      nodes.FunctionExpression = function (node) {
        validateComma(node, "params");
      };
    }

    if (!exceptions.ArrowFunctionExpression) {
      nodes.ArrowFunctionExpression = function (node) {
        validateComma(node, "params");
      };
    }

    if (!exceptions.CallExpression) {
      nodes.CallExpression = function (node) {
        validateComma(node, "arguments");
      };
    }

    if (!exceptions.ImportDeclaration) {
      nodes.ImportDeclaration = function (node) {
        validateComma(node, "specifiers");
      };
    }

    if (!exceptions.NewExpression) {
      nodes.NewExpression = function (node) {
        validateComma(node, "arguments");
      };
    }

    return nodes;
  }

};
var complexity = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum cyclomatic complexity allowed in a program",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/complexity"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
    }
  },

  create(context) {
    const option = context.options[0];
    let THRESHOLD = 20;

    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      THRESHOLD = option.maximum || option.max;
    } else if (typeof option === "number") {
      THRESHOLD = option;
    }

    const fns = [];

    function startFunction() {
      fns.push(1);
    }

    function endFunction(node) {
      const name = lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node));
      const complexity = fns.pop();

      if (complexity > THRESHOLD) {
        context.report({
          node,
          messageId: "complex",
          data: {
            name,
            complexity,
            max: THRESHOLD
          }
        });
      }
    }

    function increaseComplexity() {
      if (fns.length) {
        fns[fns.length - 1]++;
      }
    }

    return {
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,
      CatchClause: increaseComplexity,
      ConditionalExpression: increaseComplexity,
      LogicalExpression: increaseComplexity,
      ForStatement: increaseComplexity,
      ForInStatement: increaseComplexity,
      ForOfStatement: increaseComplexity,
      IfStatement: increaseComplexity,
      SwitchCase: function (node) {
        if (node.test) {
          increaseComplexity();
        }
      },
      WhileStatement: increaseComplexity,
      DoWhileStatement: increaseComplexity,

      AssignmentExpression(node) {
        if (astUtils.isLogicalAssignmentOperator(node.operator)) {
          increaseComplexity();
        }
      }

    };
  }

};
var computedPropertySpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside computed property brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/computed-property-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        enforceForClassMembers: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const propertyNameMustBeSpaced = context.options[0] === "always";
    const enforceForClassMembers = !context.options[1] || context.options[1].enforceForClassMembers;

    function reportNoBeginningSpace(node, token, tokenAfter) {
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: tokenAfter.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
        }

      });
    }

    function reportNoEndingSpace(node, token, tokenBefore) {
      context.report({
        node,
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
        }

      });
    }

    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }

      });
    }

    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: token.value
        },

        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }

      });
    }

    function checkSpacing(propertyName) {
      return function (node) {
        if (!node.computed) {
          return;
        }

        const property = node[propertyName];
        const before = sourceCode.getTokenBefore(property, astUtils.isOpeningBracketToken),
              first = sourceCode.getTokenAfter(before, {
          includeComments: true
        }),
              after = sourceCode.getTokenAfter(property, astUtils.isClosingBracketToken),
              last = sourceCode.getTokenBefore(after, {
          includeComments: true
        });

        if (astUtils.isTokenOnSameLine(before, first)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
              reportRequiredBeginningSpace(node, before);
            }
          } else {
            if (sourceCode.isSpaceBetweenTokens(before, first)) {
              reportNoBeginningSpace(node, before, first);
            }
          }
        }

        if (astUtils.isTokenOnSameLine(last, after)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
              reportRequiredEndingSpace(node, after);
            }
          } else {
            if (sourceCode.isSpaceBetweenTokens(last, after)) {
              reportNoEndingSpace(node, after, last);
            }
          }
        }
      };
    }

    const listeners = {
      Property: checkSpacing("key"),
      MemberExpression: checkSpacing("property")
    };

    if (enforceForClassMembers) {
      listeners.MethodDefinition = checkSpacing("key");
    }

    return listeners;
  }

};

function isUnreachable$1(segment) {
  return !segment.reachable;
}

function isClassConstructor(node) {
  return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

var consistentReturn = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `return` statements to either always or never specify values",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/consistent-return"
    },
    schema: [{
      type: "object",
      properties: {
        treatUndefinedAsUnspecified: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingReturn: "Expected to return a value at the end of {{name}}.",
      missingReturnValue: "{{name}} expected a return value.",
      unexpectedReturnValue: "{{name}} expected no return value."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
    let funcInfo = null;

    function checkLastSegment(node) {
      let loc, name;

      if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable$1) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
        return;
      }

      if (node.type === "Program") {
        loc = {
          line: 1,
          column: 0
        };
        name = "program";
      } else if (node.type === "ArrowFunctionExpression") {
        loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
      } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
        loc = node.parent.key.loc.start;
      } else {
        loc = (node.id || node).loc.start;
      }

      if (!name) {
        name = astUtils.getFunctionNameWithKind(node);
      }

      context.report({
        node,
        loc,
        messageId: "missingReturn",
        data: {
          name
        }
      });
    }

    return {
      onCodePathStart(codePath, node) {
        funcInfo = {
          upper: funcInfo,
          codePath,
          hasReturn: false,
          hasReturnValue: false,
          messageId: "",
          node
        };
      },

      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },

      ReturnStatement(node) {
        const argument = node.argument;
        let hasReturnValue = Boolean(argument);

        if (treatUndefinedAsUnspecified && hasReturnValue) {
          hasReturnValue = !astUtils.isSpecificId(argument, "undefined") && argument.operator !== "void";
        }

        if (!funcInfo.hasReturn) {
          funcInfo.hasReturn = true;
          funcInfo.hasReturnValue = hasReturnValue;
          funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
          funcInfo.data = {
            name: funcInfo.node.type === "Program" ? "Program" : lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
          };
        } else if (funcInfo.hasReturnValue !== hasReturnValue) {
          context.report({
            node,
            messageId: funcInfo.messageId,
            data: funcInfo.data
          });
        }
      },

      "Program:exit": checkLastSegment,
      "FunctionDeclaration:exit": checkLastSegment,
      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }

};
var consistentThis = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent naming when capturing the current execution context",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/consistent-this"
    },
    schema: {
      type: "array",
      items: {
        type: "string",
        minLength: 1
      },
      uniqueItems: true
    },
    messages: {
      aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
      unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
    }
  },

  create(context) {
    let aliases = [];

    if (context.options.length === 0) {
      aliases.push("that");
    } else {
      aliases = context.options;
    }

    function reportBadAssignment(node, name) {
      context.report({
        node,
        messageId: "aliasNotAssignedToThis",
        data: {
          name
        }
      });
    }

    function checkAssignment(node, name, value) {
      const isThis = value.type === "ThisExpression";

      if (aliases.indexOf(name) !== -1) {
        if (!isThis || node.operator && node.operator !== "=") {
          reportBadAssignment(node, name);
        }
      } else if (isThis) {
        context.report({
          node,
          messageId: "unexpectedAlias",
          data: {
            name
          }
        });
      }
    }

    function checkWasAssigned(alias, scope) {
      const variable = scope.set.get(alias);

      if (!variable) {
        return;
      }

      if (variable.defs.some(def => def.node.type === "VariableDeclarator" && def.node.init !== null)) {
        return;
      }

      if (!variable.references.some(reference => {
        const write = reference.writeExpr;
        return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
      })) {
        variable.defs.map(def => def.node).forEach(node => {
          reportBadAssignment(node, alias);
        });
      }
    }

    function ensureWasAssigned() {
      const scope = context.getScope();
      aliases.forEach(alias => {
        checkWasAssigned(alias, scope);
      });
    }

    return {
      "Program:exit": ensureWasAssigned,
      "FunctionExpression:exit": ensureWasAssigned,
      "FunctionDeclaration:exit": ensureWasAssigned,

      VariableDeclarator(node) {
        const id = node.id;
        const isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";

        if (node.init !== null && !isDestructuring) {
          checkAssignment(node, id.name, node.init);
        }
      },

      AssignmentExpression(node) {
        if (node.left.type === "Identifier") {
          checkAssignment(node, node.left.name, node.right);
        }
      }

    };
  }

};

function isReachable$2(segment) {
  return segment.reachable;
}

function isConstructorFunction$1(node) {
  return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

function isPossibleConstructor(node) {
  if (!node) {
    return false;
  }

  switch (node.type) {
    case "ClassExpression":
    case "FunctionExpression":
    case "ThisExpression":
    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "ChainExpression":
    case "YieldExpression":
    case "TaggedTemplateExpression":
    case "MetaProperty":
      return true;

    case "Identifier":
      return node.name !== "undefined";

    case "AssignmentExpression":
      if (["=", "&&="].includes(node.operator)) {
        return isPossibleConstructor(node.right);
      }

      if (["||=", "??="].includes(node.operator)) {
        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
      }

      return false;

    case "LogicalExpression":
      if (node.operator === "&&") {
        return isPossibleConstructor(node.right);
      }

      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);

    case "ConditionalExpression":
      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);

    case "SequenceExpression":
      {
        const lastExpression = node.expressions[node.expressions.length - 1];
        return isPossibleConstructor(lastExpression);
      }

    default:
      return false;
  }
}

var constructorSuper = {
  meta: {
    type: "problem",
    docs: {
      description: "require `super()` calls in constructors",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/constructor-super"
    },
    schema: [],
    messages: {
      missingSome: "Lacked a call of 'super()' in some code paths.",
      missingAll: "Expected to call 'super()'.",
      duplicate: "Unexpected duplicate 'super()'.",
      badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
      unexpected: "Unexpected 'super()'."
    }
  },

  create(context) {
    let funcInfo = null;
    let segInfoMap = Object.create(null);

    function isCalledInSomePath(segment) {
      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
    }

    function isCalledInEveryPath(segment) {
      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
        return true;
      }

      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
    }

    return {
      onCodePathStart(codePath, node) {
        if (isConstructorFunction$1(node)) {
          const classNode = node.parent.parent.parent;
          const superClass = classNode.superClass;
          funcInfo = {
            upper: funcInfo,
            isConstructor: true,
            hasExtends: Boolean(superClass),
            superIsConstructor: isPossibleConstructor(superClass),
            codePath
          };
        } else {
          funcInfo = {
            upper: funcInfo,
            isConstructor: false,
            hasExtends: false,
            superIsConstructor: false,
            codePath
          };
        }
      },

      onCodePathEnd(codePath, node) {
        const hasExtends = funcInfo.hasExtends;
        funcInfo = funcInfo.upper;

        if (!hasExtends) {
          return;
        }

        const segments = codePath.returnedSegments;
        const calledInEveryPaths = segments.every(isCalledInEveryPath);
        const calledInSomePaths = segments.some(isCalledInSomePath);

        if (!calledInEveryPaths) {
          context.report({
            messageId: calledInSomePaths ? "missingSome" : "missingAll",
            node: node.parent
          });
        }
      },

      onCodePathSegmentStart(segment) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        const info = segInfoMap[segment.id] = {
          calledInSomePaths: false,
          calledInEveryPaths: false,
          validNodes: []
        };
        const prevSegments = segment.prevSegments;

        if (prevSegments.length > 0) {
          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
        }
      },

      onCodePathSegmentLoop(fromSegment, toSegment) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        const isRealLoop = toSegment.prevSegments.length >= 2;
        funcInfo.codePath.traverseSegments({
          first: toSegment,
          last: fromSegment
        }, segment => {
          const info = segInfoMap[segment.id];
          const prevSegments = segment.prevSegments;
          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);

          if (info.calledInSomePaths || isRealLoop) {
            const nodes = info.validNodes;
            info.validNodes = [];

            for (let i = 0; i < nodes.length; ++i) {
              const node = nodes[i];
              context.report({
                messageId: "duplicate",
                node
              });
            }
          }
        });
      },

      "CallExpression:exit"(node) {
        if (!(funcInfo && funcInfo.isConstructor)) {
          return;
        }

        if (node.callee.type !== "Super") {
          return;
        }

        if (funcInfo.hasExtends) {
          const segments = funcInfo.codePath.currentSegments;
          let duplicate = false;
          let info = null;

          for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];

            if (segment.reachable) {
              info = segInfoMap[segment.id];
              duplicate = duplicate || info.calledInSomePaths;
              info.calledInSomePaths = info.calledInEveryPaths = true;
            }
          }

          if (info) {
            if (duplicate) {
              context.report({
                messageId: "duplicate",
                node
              });
            } else if (!funcInfo.superIsConstructor) {
              context.report({
                messageId: "badSuper",
                node
              });
            } else {
              info.validNodes.push(node);
            }
          }
        } else if (funcInfo.codePath.currentSegments.some(isReachable$2)) {
          context.report({
            messageId: "unexpected",
            node
          });
        }
      },

      ReturnStatement(node) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        if (!node.argument) {
          return;
        }

        const segments = funcInfo.codePath.currentSegments;

        for (let i = 0; i < segments.length; ++i) {
          const segment = segments[i];

          if (segment.reachable) {
            const info = segInfoMap[segment.id];
            info.calledInSomePaths = info.calledInEveryPaths = true;
          }
        }
      },

      "Program:exit"() {
        segInfoMap = Object.create(null);
      }

    };
  }

};
var curly = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent brace style for all control statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/curly"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["all"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["multi", "multi-line", "multi-or-nest"]
        }, {
          enum: ["consistent"]
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      missingCurlyAfter: "Expected { after '{{name}}'.",
      missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
      unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
      unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
    }
  },

  create(context) {
    const multiOnly = context.options[0] === "multi";
    const multiLine = context.options[0] === "multi-line";
    const multiOrNest = context.options[0] === "multi-or-nest";
    const consistent = context.options[1] === "consistent";
    const sourceCode = context.getSourceCode();

    function isCollapsedOneLiner(node) {
      const before = sourceCode.getTokenBefore(node);
      const last = sourceCode.getLastToken(node);
      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
    }

    function isOneLiner(node) {
      if (node.type === "EmptyStatement") {
        return true;
      }

      const first = sourceCode.getFirstToken(node);
      const last = sourceCode.getLastToken(node);
      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;
    }

    function isLexicalDeclaration(node) {
      if (node.type === "VariableDeclaration") {
        return node.kind === "const" || node.kind === "let";
      }

      return node.type === "FunctionDeclaration" || node.type === "ClassDeclaration";
    }

    function isElseKeywordToken(token) {
      return token.value === "else" && token.type === "Keyword";
    }

    function getElseKeyword(node) {
      return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
    }

    function isFollowedByElseKeyword(node) {
      const nextToken = sourceCode.getTokenAfter(node);
      return Boolean(nextToken) && isElseKeywordToken(nextToken);
    }

    function needsSemicolon(closingBracket) {
      const tokenBefore = sourceCode.getTokenBefore(closingBracket);
      const tokenAfter = sourceCode.getTokenAfter(closingBracket);
      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);

      if (astUtils.isSemicolonToken(tokenBefore)) {
        return false;
      }

      if (!tokenAfter) {
        return false;
      }

      if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
        return false;
      }

      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
        return true;
      }

      if (/^[([/`+-]/u.test(tokenAfter.value)) {
        return true;
      }

      if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
        return true;
      }

      return false;
    }

    function hasUnsafeIf(node) {
      switch (node.type) {
        case "IfStatement":
          if (!node.alternate) {
            return true;
          }

          return hasUnsafeIf(node.alternate);

        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
        case "LabeledStatement":
        case "WithStatement":
        case "WhileStatement":
          return hasUnsafeIf(node.body);

        default:
          return false;
      }
    }

    function areBracesNecessary(node) {
      const statement = node.body[0];
      return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);
    }

    function prepareCheck(node, body, name, opts) {
      const hasBlock = body.type === "BlockStatement";
      let expected = null;

      if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {
        expected = true;
      } else if (multiOnly) {
        expected = false;
      } else if (multiLine) {
        if (!isCollapsedOneLiner(body)) {
          expected = true;
        }
      } else if (multiOrNest) {
        if (hasBlock) {
          const statement = body.body[0];
          const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);
          expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;
        } else {
          expected = !isOneLiner(body);
        }
      } else {
        expected = true;
      }

      return {
        actual: hasBlock,
        expected,

        check() {
          if (this.expected !== null && this.expected !== this.actual) {
            if (this.expected) {
              context.report({
                node,
                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                data: {
                  name
                },
                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)
              });
            } else {
              context.report({
                node,
                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                data: {
                  name
                },

                fix(fixer) {
                  const needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(body, {
                    skip: 1
                  }));
                  const openingBracket = sourceCode.getFirstToken(body);
                  const closingBracket = sourceCode.getLastToken(body);
                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);

                  if (needsSemicolon(closingBracket)) {
                    return null;
                  }

                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
                  return fixer.replaceText(body, (needsPrecedingSpace ? " " : "") + resultingBodyText);
                }

              });
            }
          }
        }

      };
    }

    function prepareIfChecks(node) {
      const preparedChecks = [];

      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {
        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, "if", {
          condition: true
        }));

        if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") {
          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, "else"));
          break;
        }
      }

      if (consistent) {
        const expected = preparedChecks.some(preparedCheck => {
          if (preparedCheck.expected !== null) {
            return preparedCheck.expected;
          }

          return preparedCheck.actual;
        });
        preparedChecks.forEach(preparedCheck => {
          preparedCheck.expected = expected;
        });
      }

      return preparedChecks;
    }

    return {
      IfStatement(node) {
        const parent = node.parent;
        const isElseIf = parent.type === "IfStatement" && parent.alternate === node;

        if (!isElseIf) {
          prepareIfChecks(node).forEach(preparedCheck => {
            preparedCheck.check();
          });
        }
      },

      WhileStatement(node) {
        prepareCheck(node, node.body, "while", {
          condition: true
        }).check();
      },

      DoWhileStatement(node) {
        prepareCheck(node, node.body, "do").check();
      },

      ForStatement(node) {
        prepareCheck(node, node.body, "for", {
          condition: true
        }).check();
      },

      ForInStatement(node) {
        prepareCheck(node, node.body, "for-in").check();
      },

      ForOfStatement(node) {
        prepareCheck(node, node.body, "for-of").check();
      }

    };
  }

};
var defaultCaseLast = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce default clauses in switch statements to be last",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/default-case-last"
    },
    schema: [],
    messages: {
      notLast: "Default clause should be the last clause."
    }
  },

  create(context) {
    return {
      SwitchStatement(node) {
        const cases = node.cases,
              indexOfDefault = cases.findIndex(c => c.test === null);

        if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {
          const defaultClause = cases[indexOfDefault];
          context.report({
            node: defaultClause,
            messageId: "notLast"
          });
        }
      }

    };
  }

};
const DEFAULT_COMMENT_PATTERN = /^no default$/iu;
var defaultCase = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `default` cases in `switch` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/default-case"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string"
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingDefaultCase: "Expected a default case."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const commentPattern = options.commentPattern ? new RegExp(options.commentPattern, "u") : DEFAULT_COMMENT_PATTERN;
    const sourceCode = context.getSourceCode();

    function last(collection) {
      return collection[collection.length - 1];
    }

    return {
      SwitchStatement(node) {
        if (!node.cases.length) {
          return;
        }

        const hasDefault = node.cases.some(v => v.test === null);

        if (!hasDefault) {
          let comment;
          const lastCase = last(node.cases);
          const comments = sourceCode.getCommentsAfter(lastCase);

          if (comments.length) {
            comment = last(comments);
          }

          if (!comment || !commentPattern.test(comment.value.trim())) {
            context.report({
              node,
              messageId: "missingDefaultCase"
            });
          }
        }
      }

    };
  }

};
var defaultParamLast = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce default parameters to be last",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/default-param-last"
    },
    schema: [],
    messages: {
      shouldBeLast: "Default parameters should be last."
    }
  },

  create(context) {
    function handleFunction(node) {
      let hasSeenPlainParam = false;

      for (let i = node.params.length - 1; i >= 0; i -= 1) {
        const param = node.params[i];

        if (param.type !== "AssignmentPattern" && param.type !== "RestElement") {
          hasSeenPlainParam = true;
          continue;
        }

        if (hasSeenPlainParam && param.type === "AssignmentPattern") {
          context.report({
            node: param,
            messageId: "shouldBeLast"
          });
        }
      }
    }

    return {
      FunctionDeclaration: handleFunction,
      FunctionExpression: handleFunction,
      ArrowFunctionExpression: handleFunction
    };
  }

};
var dotLocation = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent newlines before and after dots",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/dot-location"
    },
    schema: [{
      enum: ["object", "property"]
    }],
    fixable: "code",
    messages: {
      expectedDotAfterObject: "Expected dot to be on same line as object.",
      expectedDotBeforeProperty: "Expected dot to be on same line as property."
    }
  },

  create(context) {
    const config = context.options[0];
    const sourceCode = context.getSourceCode();

    function checkDotLocation(node) {
      const property = node.property;
      const dotToken = sourceCode.getTokenBefore(property);

      if (config === "object" || !config) {
        const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);

        if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {
          context.report({
            node,
            loc: dotToken.loc,
            messageId: "expectedDotAfterObject",

            *fix(fixer) {
              if (dotToken.value.startsWith(".") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {
                yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);
              } else {
                yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);
              }

              yield fixer.remove(dotToken);
            }

          });
        }
      } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {
        context.report({
          node,
          loc: dotToken.loc,
          messageId: "expectedDotBeforeProperty",

          *fix(fixer) {
            yield fixer.remove(dotToken);
            yield fixer.insertTextBefore(property, dotToken.value);
          }

        });
      }
    }

    return {
      MemberExpression: function (node) {
        if (!node.computed) {
          checkDotLocation(node);
        }
      }
    };
  }

};
var keywords = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"];
const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;
const literalTypesToCheck = new Set(["string", "boolean"]);
var dotNotation = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce dot notation whenever possible",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/dot-notation"
    },
    schema: [{
      type: "object",
      properties: {
        allowKeywords: {
          type: "boolean",
          default: true
        },
        allowPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      useDot: "[{{key}}] is better written in dot notation.",
      useBrackets: ".{{key}} is a syntax error."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
    const sourceCode = context.getSourceCode();
    let allowPattern;

    if (options.allowPattern) {
      allowPattern = new RegExp(options.allowPattern, "u");
    }

    function checkComputedProperty(node, value) {
      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
        const formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;
        context.report({
          node: node.property,
          messageId: "useDot",
          data: {
            key: formattedValue
          },

          *fix(fixer) {
            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
            const rightBracket = sourceCode.getLastToken(node);
            const nextToken = sourceCode.getTokenAfter(node);

            if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {
              return;
            }

            if (!node.optional) {
              yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? " ." : ".");
            }

            yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value);

            if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {
              yield fixer.insertTextAfter(node, " ");
            }
          }

        });
      }
    }

    return {
      MemberExpression(node) {
        if (node.computed && node.property.type === "Literal" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {
          checkComputedProperty(node, node.property.value);
        }

        if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
          checkComputedProperty(node, node.property.quasis[0].value.cooked);
        }

        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
          context.report({
            node: node.property,
            messageId: "useBrackets",
            data: {
              key: node.property.name
            },

            *fix(fixer) {
              const dotToken = sourceCode.getTokenBefore(node.property);

              if (node.object.type === "Identifier" && node.object.name === "let" && !node.optional) {
                return;
              }

              if (sourceCode.commentsExistBetween(dotToken, node.property)) {
                return;
              }

              if (!node.optional) {
                yield fixer.remove(dotToken);
              }

              yield fixer.replaceText(node.property, `["${node.property.name}"]`);
            }

          });
        }
      }

    };
  }

};
var eolLast = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newline at the end of files",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/eol-last"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never", "unix", "windows"]
    }],
    messages: {
      missing: "Newline required at end of file but not found.",
      unexpected: "Newline not allowed at end of file."
    }
  },

  create(context) {
    return {
      Program: function (node) {
        const sourceCode = context.getSourceCode(),
              src = sourceCode.getText(),
              location = {
          column: lodash__default['default'].last(sourceCode.lines).length,
          line: sourceCode.lines.length
        },
              endsWithNewline = src.endsWith("\n");

        if (!src.length) {
          return;
        }

        let mode = context.options[0] || "always",
            appendCRLF = false;

        if (mode === "unix") {
          mode = "always";
        }

        if (mode === "windows") {
          mode = "always";
          appendCRLF = true;
        }

        if (mode === "always" && !endsWithNewline) {
          context.report({
            node,
            loc: location,
            messageId: "missing",

            fix(fixer) {
              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? `\r${"\n"}` : "\n");
            }

          });
        } else if (mode === "never" && endsWithNewline) {
          context.report({
            node,
            loc: location,
            messageId: "unexpected",

            fix(fixer) {
              const match = /(?:\r?\n)+$/u.exec(sourceCode.text),
                    start = match.index,
                    end = sourceCode.text.length;
              return fixer.replaceTextRange([start, end], "");
            }

          });
        }
      }
    };
  }

};
var eqeqeq = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require the use of `===` and `!==`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/eqeqeq"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            null: {
              enum: ["always", "never", "ignore"]
            }
          },
          additionalProperties: false
        }],
        additionalItems: false
      }, {
        type: "array",
        items: [{
          enum: ["smart", "allow-null"]
        }],
        additionalItems: false
      }]
    },
    fixable: "code",
    messages: {
      unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
    }
  },

  create(context) {
    const config = context.options[0] || "always";
    const options = context.options[1] || {};
    const sourceCode = context.getSourceCode();
    const nullOption = config === "always" ? options.null || "always" : "ignore";

    function isTypeOf(node) {
      return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    function isTypeOfBinary(node) {
      return isTypeOf(node.left) || isTypeOf(node.right);
    }

    function areLiteralsAndSameType(node) {
      return node.left.type === "Literal" && node.right.type === "Literal" && typeof node.left.value === typeof node.right.value;
    }

    function isNullCheck(node) {
      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
    }

    function report(node, expectedOperator) {
      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
      context.report({
        node,
        loc: operatorToken.loc,
        messageId: "unexpected",
        data: {
          expectedOperator,
          actualOperator: node.operator
        },

        fix(fixer) {
          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
            return fixer.replaceText(operatorToken, expectedOperator);
          }

          return null;
        }

      });
    }

    return {
      BinaryExpression(node) {
        const isNull = isNullCheck(node);

        if (node.operator !== "==" && node.operator !== "!=") {
          if (nullOption === "never" && isNull) {
            report(node, node.operator.slice(0, -1));
          }

          return;
        }

        if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
          return;
        }

        if (!(nullOption === "always") && isNull) {
          return;
        }

        report(node, `${node.operator}=`);
      }

    };
  }

};
var forDirection = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce \"for\" loop update clause moving the counter in the right direction.",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/for-direction"
    },
    fixable: null,
    schema: [],
    messages: {
      incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
    }
  },

  create(context) {
    function report(node) {
      context.report({
        node,
        messageId: "incorrectDirection"
      });
    }

    function getRightDirection(update, dir) {
      if (update.right.type === "UnaryExpression") {
        if (update.right.operator === "-") {
          return -dir;
        }
      } else if (update.right.type === "Identifier") {
        return 0;
      }

      return dir;
    }

    function getUpdateDirection(update, counter) {
      if (update.argument.type === "Identifier" && update.argument.name === counter) {
        if (update.operator === "++") {
          return 1;
        }

        if (update.operator === "--") {
          return -1;
        }
      }

      return 0;
    }

    function getAssignmentDirection(update, counter) {
      if (update.left.name === counter) {
        if (update.operator === "+=") {
          return getRightDirection(update, 1);
        }

        if (update.operator === "-=") {
          return getRightDirection(update, -1);
        }
      }

      return 0;
    }

    return {
      ForStatement(node) {
        if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
          const counter = node.test.left.name;
          const operator = node.test.operator;
          const update = node.update;
          let wrongDirection;

          if (operator === "<" || operator === "<=") {
            wrongDirection = -1;
          } else if (operator === ">" || operator === ">=") {
            wrongDirection = 1;
          } else {
            return;
          }

          if (update.type === "UpdateExpression") {
            if (getUpdateDirection(update, counter) === wrongDirection) {
              report(node);
            }
          } else if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) === wrongDirection) {
            report(node);
          }
        }
      }

    };
  }

};
var funcCallSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between function identifiers and their invocations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-call-spacing"
    },
    fixable: "whitespace",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            allowNewlines: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
      unexpectedNewline: "Unexpected newline between function name and paren.",
      missing: "Missing space between function name and paren."
    }
  },

  create(context) {
    const never = context.options[0] !== "always";
    const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
    const sourceCode = context.getSourceCode();
    const text = sourceCode.getText();

    function checkSpacing(node, leftToken, rightToken) {
      const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\/\*.*?\*\//gu, "");
      const hasWhitespace = /\s/u.test(textBetweenTokens);
      const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);

      if (never && hasWhitespace) {
        context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: {
              line: rightToken.loc.start.line,
              column: rightToken.loc.start.column - 1
            }
          },
          messageId: "unexpectedWhitespace",

          fix(fixer) {
            if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
              return null;
            }

            if (node.optional) {
              return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], "?.");
            }

            if (hasNewline) {
              return null;
            }

            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }

        });
      } else if (!never && !hasWhitespace) {
        context.report({
          node,
          loc: {
            start: {
              line: leftToken.loc.end.line,
              column: leftToken.loc.end.column - 1
            },
            end: rightToken.loc.start
          },
          messageId: "missing",

          fix(fixer) {
            if (node.optional) {
              return null;
            }

            return fixer.insertTextBefore(rightToken, " ");
          }

        });
      } else if (!never && !allowNewlines && hasNewline) {
        context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: rightToken.loc.start
          },
          messageId: "unexpectedNewline",

          fix(fixer) {
            if (!node.optional) {
              return null;
            }

            if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
              return null;
            }

            const range = [leftToken.range[1], rightToken.range[0]];
            const qdToken = sourceCode.getTokenAfter(leftToken);

            if (qdToken.range[0] === leftToken.range[1]) {
              return fixer.replaceTextRange(range, "?. ");
            }

            if (qdToken.range[1] === rightToken.range[0]) {
              return fixer.replaceTextRange(range, " ?.");
            }

            return fixer.replaceTextRange(range, " ?. ");
          }

        });
      }
    }

    return {
      "CallExpression, NewExpression"(node) {
        const lastToken = sourceCode.getLastToken(node);
        const lastCalleeToken = sourceCode.getLastToken(node.callee);
        const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
        const prevToken = parenToken && sourceCode.getTokenBefore(parenToken, astUtils.isNotQuestionDotToken);

        if (!(parenToken && parenToken.range[1] < node.range[1])) {
          return;
        }

        checkSpacing(node, prevToken, parenToken);
      },

      ImportExpression(node) {
        const leftToken = sourceCode.getFirstToken(node);
        const rightToken = sourceCode.getTokenAfter(leftToken);
        checkSpacing(node, leftToken, rightToken);
      }

    };
  }

};

function isModuleExports(pattern) {
  if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
    if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
      return true;
    }

    if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
      return true;
    }
  }

  return false;
}

function isIdentifier(name, ecmaVersion) {
  if (ecmaVersion >= 6) {
    return esutils__default['default'].keyword.isIdentifierES6(name);
  }

  return esutils__default['default'].keyword.isIdentifierES5(name);
}

const alwaysOrNever = {
  enum: ["always", "never"]
};
const optionsObject = {
  type: "object",
  properties: {
    considerPropertyDescriptor: {
      type: "boolean"
    },
    includeCommonJSModuleExports: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
var funcNameMatching = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require function names to match the name of the variable or property to which they are assigned",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-name-matching"
    },
    schema: {
      anyOf: [{
        type: "array",
        additionalItems: false,
        items: [alwaysOrNever, optionsObject]
      }, {
        type: "array",
        additionalItems: false,
        items: [optionsObject]
      }]
    },
    messages: {
      matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
      matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
      notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
      notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
    }
  },

  create(context) {
    const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
    const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
    const considerPropertyDescriptor = options.considerPropertyDescriptor;
    const includeModuleExports = options.includeCommonJSModuleExports;
    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;

    function isPropertyCall(objName, funcName, node) {
      if (!node) {
        return false;
      }

      return node.type === "CallExpression" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);
    }

    function shouldWarn(x, y) {
      return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
    }

    function report(node, name, funcName, isProp) {
      let messageId;

      if (nameMatches === "always" && isProp) {
        messageId = "matchProperty";
      } else if (nameMatches === "always") {
        messageId = "matchVariable";
      } else if (isProp) {
        messageId = "notMatchProperty";
      } else {
        messageId = "notMatchVariable";
      }

      context.report({
        node,
        messageId,
        data: {
          name,
          funcName
        }
      });
    }

    function isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string";
    }

    return {
      VariableDeclarator(node) {
        if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
          return;
        }

        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
          report(node, node.id.name, node.init.id.name, false);
        }
      },

      AssignmentExpression(node) {
        if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
          return;
        }

        const isProp = node.left.type === "MemberExpression";
        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;

        if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
          report(node, name, node.right.id.name, isProp);
        }
      },

      Property(node) {
        if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
          return;
        }

        if (node.key.type === "Identifier") {
          const functionName = node.value.id.name;
          let propertyName = node.key.name;

          if (considerPropertyDescriptor && propertyName === "value") {
            if (isPropertyCall("Object", "defineProperty", node.parent.parent) || isPropertyCall("Reflect", "defineProperty", node.parent.parent)) {
              const property = node.parent.parent.arguments[1];

              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {
                report(node, property.value, functionName, true);
              }
            } else if (isPropertyCall("Object", "defineProperties", node.parent.parent.parent.parent)) {
              propertyName = node.parent.parent.key.name;

              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
            } else if (isPropertyCall("Object", "create", node.parent.parent.parent.parent)) {
              propertyName = node.parent.parent.key.name;

              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
            } else if (shouldWarn(propertyName, functionName)) {
              report(node, propertyName, functionName, true);
            }
          } else if (shouldWarn(propertyName, functionName)) {
            report(node, propertyName, functionName, true);
          }

          return;
        }

        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
          report(node, node.key.value, node.value.id.name, true);
        }
      }

    };
  }

};

function isFunctionName$1(variable) {
  return variable && variable.defs[0].type === "FunctionName";
}

var funcNames = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow named `function` expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-names"
    },
    schema: {
      definitions: {
        value: {
          enum: ["always", "as-needed", "never"]
        }
      },
      items: [{
        $ref: "#/definitions/value"
      }, {
        type: "object",
        properties: {
          generators: {
            $ref: "#/definitions/value"
          }
        },
        additionalProperties: false
      }]
    },
    messages: {
      unnamed: "Unexpected unnamed {{name}}.",
      named: "Unexpected named {{name}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function getConfigForNode(node) {
      if (node.generator && context.options.length > 1 && context.options[1].generators) {
        return context.options[1].generators;
      }

      return context.options[0] || "always";
    }

    function isObjectOrClassMethod(node) {
      const parent = node.parent;
      return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
    }

    function hasInferredName(node) {
      const parent = node.parent;
      return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node;
    }

    function reportUnexpectedUnnamedFunction(node) {
      context.report({
        node,
        messageId: "unnamed",
        loc: astUtils.getFunctionHeadLoc(node, sourceCode),
        data: {
          name: astUtils.getFunctionNameWithKind(node)
        }
      });
    }

    function reportUnexpectedNamedFunction(node) {
      context.report({
        node,
        messageId: "named",
        loc: astUtils.getFunctionHeadLoc(node, sourceCode),
        data: {
          name: astUtils.getFunctionNameWithKind(node)
        }
      });
    }

    function handleFunction(node) {
      const nameVar = context.getDeclaredVariables(node)[0];

      if (isFunctionName$1(nameVar) && nameVar.references.length > 0) {
        return;
      }

      const hasName = Boolean(node.id && node.id.name);
      const config = getConfigForNode(node);

      if (config === "never") {
        if (hasName && node.type !== "FunctionDeclaration") {
          reportUnexpectedNamedFunction(node);
        }
      } else if (config === "as-needed") {
        if (!hasName && !hasInferredName(node)) {
          reportUnexpectedUnnamedFunction(node);
        }
      } else {
        if (!hasName && !isObjectOrClassMethod(node)) {
          reportUnexpectedUnnamedFunction(node);
        }
      }
    }

    return {
      "FunctionExpression:exit": handleFunction,
      "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
    };
  }

};
var funcStyle = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of either `function` declarations or expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-style"
    },
    schema: [{
      enum: ["declaration", "expression"]
    }, {
      type: "object",
      properties: {
        allowArrowFunctions: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expression: "Expected a function expression.",
      declaration: "Expected a function declaration."
    }
  },

  create(context) {
    const style = context.options[0],
          allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions,
          enforceDeclarations = style === "declaration",
          stack = [];
    const nodesToCheck = {
      FunctionDeclaration(node) {
        stack.push(false);

        if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
          context.report({
            node,
            messageId: "expression"
          });
        }
      },

      "FunctionDeclaration:exit"() {
        stack.pop();
      },

      FunctionExpression(node) {
        stack.push(false);

        if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
          context.report({
            node: node.parent,
            messageId: "declaration"
          });
        }
      },

      "FunctionExpression:exit"() {
        stack.pop();
      },

      ThisExpression() {
        if (stack.length > 0) {
          stack[stack.length - 1] = true;
        }
      }

    };

    if (!allowArrowFunctions) {
      nodesToCheck.ArrowFunctionExpression = function () {
        stack.push(false);
      };

      nodesToCheck["ArrowFunctionExpression:exit"] = function (node) {
        const hasThisExpr = stack.pop();

        if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
          context.report({
            node: node.parent,
            messageId: "declaration"
          });
        }
      };
    }

    return nodesToCheck;
  }

};
var functionCallArgumentNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks between arguments of a function call",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/function-call-argument-newline"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never", "consistent"]
    }],
    messages: {
      unexpectedLineBreak: "There should be no line break here.",
      missingLineBreak: "There should be a line break after this argument."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const checkers = {
      unexpected: {
        messageId: "unexpectedLineBreak",
        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,
        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
      },
      missing: {
        messageId: "missingLineBreak",
        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,
        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
      }
    };

    function checkArguments(node, checker) {
      for (let i = 1; i < node.arguments.length; i++) {
        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);
        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);

        if (checker.check(prevArgToken, currentArgToken)) {
          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {
            includeComments: true
          });
          const hasLineCommentBefore = tokenBefore.type === "Line";
          context.report({
            node,
            loc: {
              start: tokenBefore.loc.end,
              end: currentArgToken.loc.start
            },
            messageId: checker.messageId,
            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
          });
        }
      }
    }

    function check(node) {
      if (node.arguments.length < 2) {
        return;
      }

      const option = context.options[0] || "always";

      if (option === "never") {
        checkArguments(node, checkers.unexpected);
      } else if (option === "always") {
        checkArguments(node, checkers.missing);
      } else if (option === "consistent") {
        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);
        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);

        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {
          checkArguments(node, checkers.unexpected);
        } else {
          checkArguments(node, checkers.missing);
        }
      }
    }

    return {
      CallExpression: check,
      NewExpression: check
    };
  }

};
var functionParenNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks inside function parentheses",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/function-paren-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
      }, {
        type: "object",
        properties: {
          minItems: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      expectedBefore: "Expected newline before ')'.",
      expectedAfter: "Expected newline after '('.",
      expectedBetween: "Expected newline between arguments/params.",
      unexpectedBefore: "Unexpected newline before ')'.",
      unexpectedAfter: "Unexpected newline after '('."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const rawOption = context.options[0] || "multiline";
    const multilineArgumentsOption = rawOption === "multiline-arguments";
    let minItems;

    if (typeof rawOption === "object") {
      minItems = rawOption.minItems;
    } else if (rawOption === "always") {
      minItems = 0;
    } else if (rawOption === "never") {
      minItems = Infinity;
    } else {
      minItems = null;
    }

    function shouldHaveNewlines(elements, hasLeftNewline) {
      if (multilineArgumentsOption && elements.length === 1) {
        return hasLeftNewline;
      }

      if (rawOption === "multiline" || multilineArgumentsOption) {
        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
      }

      if (rawOption === "consistent") {
        return hasLeftNewline;
      }

      return elements.length >= minItems;
    }

    function validateParens(parens, elements) {
      const leftParen = parens.leftParen;
      const rightParen = parens.rightParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

      if (hasLeftNewline && !needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "unexpectedAfter",

          fix(fixer) {
            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
          }

        });
      } else if (!hasLeftNewline && needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "expectedAfter",
          fix: fixer => fixer.insertTextAfter(leftParen, "\n")
        });
      }

      if (hasRightNewline && !needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "unexpectedBefore",

          fix(fixer) {
            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
          }

        });
      } else if (!hasRightNewline && needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "expectedBefore",
          fix: fixer => fixer.insertTextBefore(rightParen, "\n")
        });
      }
    }

    function validateArguments(parens, elements) {
      const leftParen = parens.leftParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

      for (let i = 0; i <= elements.length - 2; i++) {
        const currentElement = elements[i];
        const nextElement = elements[i + 1];
        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;

        if (!hasNewLine && needsNewlines) {
          context.report({
            node: currentElement,
            messageId: "expectedBetween",
            fix: fixer => fixer.insertTextBefore(nextElement, "\n")
          });
        }
      }
    }

    function getParenTokens(node) {
      switch (node.type) {
        case "NewExpression":
          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {
            skip: 1
          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
            return null;
          }

        case "CallExpression":
          return {
            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
            rightParen: sourceCode.getLastToken(node)
          };

        case "FunctionDeclaration":
        case "FunctionExpression":
          {
            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
            return {
              leftParen,
              rightParen
            };
          }

        case "ArrowFunctionExpression":
          {
            const firstToken = sourceCode.getFirstToken(node, {
              skip: node.async ? 1 : 0
            });

            if (!astUtils.isOpeningParenToken(firstToken)) {
              return null;
            }

            return {
              leftParen: firstToken,
              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
            };
          }

        case "ImportExpression":
          {
            const leftParen = sourceCode.getFirstToken(node, 1);
            const rightParen = sourceCode.getLastToken(node);
            return {
              leftParen,
              rightParen
            };
          }

        default:
          throw new TypeError(`unexpected node with type ${node.type}`);
      }
    }

    return {
      [["ArrowFunctionExpression", "CallExpression", "FunctionDeclaration", "FunctionExpression", "ImportExpression", "NewExpression"]](node) {
        const parens = getParenTokens(node);
        let params;

        if (node.type === "ImportExpression") {
          params = [node.source];
        } else if (astUtils.isFunction(node)) {
          params = node.params;
        } else {
          params = node.arguments;
        }

        if (parens) {
          validateParens(parens, params);

          if (multilineArgumentsOption) {
            validateArguments(parens, params);
          }
        }
      }

    };
  }

};
const OVERRIDE_SCHEMA = {
  oneOf: [{
    enum: ["before", "after", "both", "neither"]
  }, {
    type: "object",
    properties: {
      before: {
        type: "boolean"
      },
      after: {
        type: "boolean"
      }
    },
    additionalProperties: false
  }]
};
var generatorStarSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing around `*` operators in generator functions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/generator-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          },
          named: OVERRIDE_SCHEMA,
          anonymous: OVERRIDE_SCHEMA,
          method: OVERRIDE_SCHEMA
        },
        additionalProperties: false
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },

  create(context) {
    const optionDefinitions = {
      before: {
        before: true,
        after: false
      },
      after: {
        before: false,
        after: true
      },
      both: {
        before: true,
        after: true
      },
      neither: {
        before: false,
        after: false
      }
    };

    function optionToDefinition(option, defaults) {
      if (!option) {
        return defaults;
      }

      return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
    }

    const modes = function (option) {
      const defaults = optionToDefinition(option, optionDefinitions.before);
      return {
        named: optionToDefinition(option.named, defaults),
        anonymous: optionToDefinition(option.anonymous, defaults),
        method: optionToDefinition(option.method, defaults)
      };
    }(context.options[0] || {});

    const sourceCode = context.getSourceCode();

    function isStarToken(token) {
      return token.value === "*" && token.type === "Punctuator";
    }

    function getStarToken(node) {
      return sourceCode.getFirstToken(node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }

    function checkSpacing(kind, side, leftToken, rightToken) {
      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
        const after = leftToken.value === "*";
        const spaceRequired = modes[kind][side];
        const node = after ? leftToken : rightToken;
        const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
        context.report({
          node,
          messageId,

          fix(fixer) {
            if (spaceRequired) {
              if (after) {
                return fixer.insertTextAfter(node, " ");
              }

              return fixer.insertTextBefore(node, " ");
            }

            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }

        });
      }
    }

    function checkFunction(node) {
      if (!node.generator) {
        return;
      }

      const starToken = getStarToken(node);
      const prevToken = sourceCode.getTokenBefore(starToken);
      const nextToken = sourceCode.getTokenAfter(starToken);
      let kind = "named";

      if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
        kind = "method";
      } else if (!node.id) {
        kind = "anonymous";
      }

      if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
        checkSpacing(kind, "before", prevToken, starToken);
      }

      checkSpacing(kind, "after", starToken, nextToken);
    }

    return {
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction
    };
  }

};
const TARGET_NODE_TYPE$1 = /^(?:Arrow)?FunctionExpression$/u;

function isReachable$1(segment) {
  return segment.reachable;
}

var getterReturn = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in getters",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/getter-return"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected to return a value in {{name}}.",
      expectedAlways: "Expected {{name}} to always return a value."
    }
  },

  create(context) {
    const options = context.options[0] || {
      allowImplicit: false
    };
    const sourceCode = context.getSourceCode();
    let funcInfo = {
      upper: null,
      codePath: null,
      hasReturn: false,
      shouldCheck: false,
      node: null
    };

    function checkLastSegment(node) {
      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable$1)) {
        context.report({
          node,
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          messageId: funcInfo.hasReturn ? "expectedAlways" : "expected",
          data: {
            name: astUtils.getFunctionNameWithKind(funcInfo.node)
          }
        });
      }
    }

    function isGetter(node) {
      const parent = node.parent;

      if (TARGET_NODE_TYPE$1.test(node.type) && node.body.type === "BlockStatement") {
        if (parent.kind === "get") {
          return true;
        }

        if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
          if (parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
            return true;
          }

          if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
            return true;
          }
        }
      }

      return false;
    }

    return {
      onCodePathStart(codePath, node) {
        funcInfo = {
          upper: funcInfo,
          codePath,
          hasReturn: false,
          shouldCheck: isGetter(node),
          node
        };
      },

      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },

      ReturnStatement(node) {
        if (funcInfo.shouldCheck) {
          funcInfo.hasReturn = true;

          if (!options.allowImplicit && !node.argument) {
            context.report({
              node,
              messageId: "expected",
              data: {
                name: astUtils.getFunctionNameWithKind(funcInfo.node)
              }
            });
          }
        }
      },

      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }

};
const ACCEPTABLE_PARENTS = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration", "ChainExpression"];

function findReference$1(scope, node) {
  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);

  if (references.length === 1) {
    return references[0];
  }

  return null;
}

function isShadowed$2(scope, node) {
  const reference = findReference$1(scope, node);
  return reference && reference.resolved && reference.resolved.defs.length > 0;
}

var globalRequire = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require `require()` calls to be placed at top-level module scope",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/global-require"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected require()."
    }
  },

  create(context) {
    return {
      CallExpression(node) {
        const currentScope = context.getScope();

        if (node.callee.name === "require" && !isShadowed$2(currentScope, node.callee)) {
          const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);

          if (!isGoodRequire) {
            context.report({
              node,
              messageId: "unexpected"
            });
          }
        }
      }

    };
  }

};

function areEqualTokenLists(left, right) {
  if (left.length !== right.length) {
    return false;
  }

  for (let i = 0; i < left.length; i++) {
    const leftToken = left[i],
          rightToken = right[i];

    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
      return false;
    }
  }

  return true;
}

function areEqualKeys(left, right) {
  if (typeof left === "string" && typeof right === "string") {
    return left === right;
  }

  if (Array.isArray(left) && Array.isArray(right)) {
    return areEqualTokenLists(left, right);
  }

  return false;
}

function isAccessorKind(node) {
  return node.kind === "get" || node.kind === "set";
}

var groupedAccessorPairs = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require grouped accessor pairs in object literals and classes",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/grouped-accessor-pairs"
    },
    schema: [{
      enum: ["anyOrder", "getBeforeSet", "setBeforeGet"]
    }],
    messages: {
      notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
      invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
    }
  },

  create(context) {
    const order = context.options[0] || "anyOrder";
    const sourceCode = context.getSourceCode();

    function report(messageId, formerNode, latterNode) {
      context.report({
        node: latterNode,
        messageId,
        loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),
        data: {
          formerName: astUtils.getFunctionNameWithKind(formerNode.value),
          latterName: astUtils.getFunctionNameWithKind(latterNode.value)
        }
      });
    }

    function createAccessorData(node) {
      const name = astUtils.getStaticPropertyName(node);
      const key = name !== null ? name : sourceCode.getTokens(node.key);
      return {
        key,
        getters: node.kind === "get" ? [node] : [],
        setters: node.kind === "set" ? [node] : []
      };
    }

    function mergeAccessorData(accessors, accessorData) {
      const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));

      if (equalKeyElement) {
        equalKeyElement.getters.push(...accessorData.getters);
        equalKeyElement.setters.push(...accessorData.setters);
      } else {
        accessors.push(accessorData);
      }

      return accessors;
    }

    function checkList(nodes, shouldCheck) {
      const accessors = nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);

      for (const {
        getters,
        setters
      } of accessors) {
        if (getters.length === 1 && setters.length === 1) {
          const [getter] = getters,
                [setter] = setters,
                getterIndex = nodes.indexOf(getter),
                setterIndex = nodes.indexOf(setter),
                formerNode = getterIndex < setterIndex ? getter : setter,
                latterNode = getterIndex < setterIndex ? setter : getter;

          if (Math.abs(getterIndex - setterIndex) > 1) {
            report("notGrouped", formerNode, latterNode);
          } else if (order === "getBeforeSet" && getterIndex > setterIndex || order === "setBeforeGet" && getterIndex < setterIndex) {
            report("invalidOrder", formerNode, latterNode);
          }
        }
      }
    }

    return {
      ObjectExpression(node) {
        checkList(node.properties, n => n.type === "Property");
      },

      ClassBody(node) {
        checkList(node.body, n => n.type === "MethodDefinition" && !n.static);
        checkList(node.body, n => n.type === "MethodDefinition" && n.static);
      }

    };
  }

};
var guardForIn = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `for-in` loops to include an `if` statement",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/guard-for-in"
    },
    schema: [],
    messages: {
      wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
    }
  },

  create(context) {
    return {
      ForInStatement(node) {
        const body = node.body;

        if (body.type === "EmptyStatement") {
          return;
        }

        if (body.type === "IfStatement") {
          return;
        }

        if (body.type === "BlockStatement" && body.body.length === 0) {
          return;
        }

        if (body.type === "BlockStatement" && body.body.length === 1 && body.body[0].type === "IfStatement") {
          return;
        }

        if (body.type === "BlockStatement" && body.body.length >= 1 && body.body[0].type === "IfStatement") {
          const i = body.body[0];

          if (i.consequent.type === "ContinueStatement") {
            return;
          }

          if (i.consequent.type === "BlockStatement" && i.consequent.body.length === 1 && i.consequent.body[0].type === "ContinueStatement") {
            return;
          }
        }

        context.report({
          node,
          messageId: "wrap"
        });
      }

    };
  }

};
var handleCallbackErr = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require error handling in callbacks",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/handle-callback-err"
    },
    schema: [{
      type: "string"
    }],
    messages: {
      expected: "Expected error to be handled."
    }
  },

  create(context) {
    const errorArgument = context.options[0] || "err";

    function isPattern(stringToCheck) {
      const firstChar = stringToCheck[0];
      return firstChar === "^";
    }

    function matchesConfiguredErrorName(name) {
      if (isPattern(errorArgument)) {
        const regexp = new RegExp(errorArgument, "u");
        return regexp.test(name);
      }

      return name === errorArgument;
    }

    function getParameters(scope) {
      return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === "Parameter");
    }

    function checkForError(node) {
      const scope = context.getScope(),
            parameters = getParameters(scope),
            firstParameter = parameters[0];

      if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
        if (firstParameter.references.length === 0) {
          context.report({
            node,
            messageId: "expected"
          });
        }
      }
    }

    return {
      FunctionDeclaration: checkForError,
      FunctionExpression: checkForError,
      ArrowFunctionExpression: checkForError
    };
  }

};

function isAssignmentTarget$1(node) {
  const parent = node.parent;
  return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node;
}

function isRenamedImport$1(node) {
  const parent = node.parent;
  return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && parent.local !== parent.exported && parent.local === node;
}

function isRenamedInDestructuring$1(node) {
  const parent = node.parent;
  return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node && parent.key === node;
}

function isShorthandPropertyDefinition$1(node) {
  const parent = node.parent;
  return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
}

var idBlacklist = {
  meta: {
    deprecated: true,
    replacedBy: ["id-denylist"],
    type: "suggestion",
    docs: {
      description: "disallow specified identifiers",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-blacklist"
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true
    },
    messages: {
      restricted: "Identifier '{{name}}' is restricted."
    }
  },

  create(context) {
    const denyList = new Set(context.options);
    const reportedNodes = new Set();
    let globalScope;

    function isRestricted(name) {
      return denyList.has(name);
    }

    function isReferenceToGlobalVariable(node) {
      const variable = globalScope.set.get(node.name);
      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);
    }

    function shouldCheck(node) {
      const parent = node.parent;

      if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
        return isAssignmentTarget$1(parent);
      }

      return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport$1(node) && !isRenamedInDestructuring$1(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition$1(node));
    }

    function report(node) {
      if (!reportedNodes.has(node)) {
        context.report({
          node,
          messageId: "restricted",
          data: {
            name: node.name
          }
        });
        reportedNodes.add(node);
      }
    }

    return {
      Program() {
        globalScope = context.getScope();
      },

      Identifier(node) {
        if (isRestricted(node.name) && shouldCheck(node)) {
          report(node);
        }
      }

    };
  }

};

function isAssignmentTarget(node) {
  const parent = node.parent;
  return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node;
}

function isRenamedImport(node) {
  const parent = node.parent;
  return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && parent.local !== parent.exported && parent.local === node;
}

function isRenamedInDestructuring(node) {
  const parent = node.parent;
  return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node && parent.key === node;
}

function isShorthandPropertyDefinition(node) {
  const parent = node.parent;
  return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
}

var idDenylist = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified identifiers",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-denylist"
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true
    },
    messages: {
      restricted: "Identifier '{{name}}' is restricted."
    }
  },

  create(context) {
    const denyList = new Set(context.options);
    const reportedNodes = new Set();
    let globalScope;

    function isRestricted(name) {
      return denyList.has(name);
    }

    function isReferenceToGlobalVariable(node) {
      const variable = globalScope.set.get(node.name);
      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);
    }

    function shouldCheck(node) {
      const parent = node.parent;

      if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
        return isAssignmentTarget(parent);
      }

      return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));
    }

    function report(node) {
      if (!reportedNodes.has(node)) {
        context.report({
          node,
          messageId: "restricted",
          data: {
            name: node.name
          }
        });
        reportedNodes.add(node);
      }
    }

    return {
      Program() {
        globalScope = context.getScope();
      },

      Identifier(node) {
        if (isRestricted(node.name) && shouldCheck(node)) {
          report(node);
        }
      }

    };
  }

};
var idLength = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce minimum and maximum identifier lengths",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-length"
    },
    schema: [{
      type: "object",
      properties: {
        min: {
          type: "integer",
          default: 2
        },
        max: {
          type: "integer"
        },
        exceptions: {
          type: "array",
          uniqueItems: true,
          items: {
            type: "string"
          }
        },
        exceptionPatterns: {
          type: "array",
          uniqueItems: true,
          items: {
            type: "string"
          }
        },
        properties: {
          enum: ["always", "never"]
        }
      },
      additionalProperties: false
    }],
    messages: {
      tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
      tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const minLength = typeof options.min !== "undefined" ? options.min : 2;
    const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
    const properties = options.properties !== "never";
    const exceptions = new Set(options.exceptions);
    const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, "u"));
    const reportedNode = new Set();

    function matchesExceptionPattern(name) {
      return exceptionPatterns.some(pattern => pattern.test(name));
    }

    const SUPPORTED_EXPRESSIONS = {
      MemberExpression: properties && function (parent) {
        return !parent.computed && (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" || parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
      },

      AssignmentPattern(parent, node) {
        return parent.left === node;
      },

      VariableDeclarator(parent, node) {
        return parent.id === node;
      },

      Property(parent, node) {
        if (parent.parent.type === "ObjectPattern") {
          return parent.value !== parent.key && parent.value === node || parent.value === parent.key && parent.key === node && properties;
        }

        return properties && !parent.computed && parent.key === node;
      },

      ImportDefaultSpecifier: true,
      RestElement: true,
      FunctionExpression: true,
      ArrowFunctionExpression: true,
      ClassDeclaration: true,
      FunctionDeclaration: true,
      MethodDefinition: true,
      CatchClause: true,
      ArrayPattern: true
    };
    return {
      Identifier(node) {
        const name = node.name;
        const parent = node.parent;
        const isShort = name.length < minLength;
        const isLong = name.length > maxLength;

        if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {
          return;
        }

        const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

        if (isValidExpression && !reportedNode.has(node) && (isValidExpression === true || isValidExpression(parent, node))) {
          reportedNode.add(node);
          context.report({
            node,
            messageId: isShort ? "tooShort" : "tooLong",
            data: {
              name,
              min: minLength,
              max: maxLength
            }
          });
        }
      }

    };
  }

};
var idMatch = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require identifiers to match a specified regular expression",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-match"
    },
    schema: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        properties: {
          type: "boolean",
          default: false
        },
        onlyDeclarations: {
          type: "boolean",
          default: false
        },
        ignoreDestructuring: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'."
    }
  },

  create(context) {
    const pattern = context.options[0] || "^.+$",
          regexp = new RegExp(pattern, "u");
    const options = context.options[1] || {},
          properties = !!options.properties,
          onlyDeclarations = !!options.onlyDeclarations,
          ignoreDestructuring = !!options.ignoreDestructuring;
    const reported = new Map();
    const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
    const DECLARATION_TYPES = new Set(["FunctionDeclaration", "VariableDeclarator"]);
    const IMPORT_TYPES = new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);

    function isInvalid(name) {
      return !regexp.test(name);
    }

    function isInsideObjectPattern(node) {
      let {
        parent
      } = node;

      while (parent) {
        if (parent.type === "ObjectPattern") {
          return true;
        }

        parent = parent.parent;
      }

      return false;
    }

    function shouldReport(effectiveParent, name) {
      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);
    }

    function report(node) {
      if (!reported.has(node)) {
        context.report({
          node,
          messageId: "notMatch",
          data: {
            name: node.name,
            pattern
          }
        });
        reported.set(node, true);
      }
    }

    return {
      Identifier(node) {
        const name = node.name,
              parent = node.parent,
              effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;

        if (parent.type === "MemberExpression") {
          if (!properties) {
            return;
          }

          if (parent.object.type === "Identifier" && parent.object.name === name) {
            if (isInvalid(name)) {
              report(node);
            }
          } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name) {
            if (isInvalid(name)) {
              report(node);
            }
          } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.right.type !== "MemberExpression") {
            if (isInvalid(name)) {
              report(node);
            }
          }
        } else if (parent.type === "Property" || parent.type === "AssignmentPattern") {
          if (parent.parent && parent.parent.type === "ObjectPattern") {
            if (parent.shorthand && parent.value.left && isInvalid(name)) {
              report(node);
            }

            const assignmentKeyEqualsValue = parent.key.name === parent.value.name;

            if (!assignmentKeyEqualsValue && parent.key === node) {
              return;
            }

            const valueIsInvalid = parent.value.name && isInvalid(name);

            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
              report(node);
            }
          }

          if (!properties || ignoreDestructuring && isInsideObjectPattern(node)) {
            return;
          }

          if (parent.right !== node && shouldReport(effectiveParent, name)) {
            report(node);
          }
        } else if (IMPORT_TYPES.has(parent.type)) {
          if (parent.local && parent.local.name === node.name && isInvalid(name)) {
            report(node);
          }
        } else if (shouldReport(effectiveParent, name)) {
          report(node);
        }
      }

    };
  }

};
const {
  isCommentToken,
  isNotOpeningParenToken
} = astUtils;
var implicitArrowLinebreak = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of arrow function bodies",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/implicit-arrow-linebreak"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["beside", "below"]
    }],
    messages: {
      expected: "Expected a linebreak before this expression.",
      unexpected: "Expected no linebreak before this expression."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "beside";

    function validateExpression(node) {
      if (node.body.type === "BlockStatement") {
        return;
      }

      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);
      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);

      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === "below") {
        context.report({
          node: firstTokenOfBody,
          messageId: "expected",
          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, "\n")
        });
      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === "beside") {
        context.report({
          node: firstTokenOfBody,
          messageId: "unexpected",

          fix(fixer) {
            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {
              includeComments: true,
              filter: isCommentToken
            })) {
              return null;
            }

            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], " ");
          }

        });
      }
    }

    return {
      ArrowFunctionExpression: node => validateExpression(node)
    };
  }

};
var indentLegacy = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/indent-legacy"
    },
    deprecated: true,
    replacedBy: ["indent"],
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0
        },
        VariableDeclarator: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            type: "object",
            properties: {
              var: {
                type: "integer",
                minimum: 0
              },
              let: {
                type: "integer",
                minimum: 0
              },
              const: {
                type: "integer",
                minimum: 0
              }
            }
          }]
        },
        outerIIFEBody: {
          type: "integer",
          minimum: 0
        },
        MemberExpression: {
          type: "integer",
          minimum: 0
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        CallExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            }
          }
        },
        ArrayExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        },
        ObjectExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },

  create(context) {
    const DEFAULT_PARAMETER_INDENT = null;
    let indentType = "space";
    let indentSize = 4;
    const options = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: 1,
        let: 1,
        const: 1
      },
      outerIIFEBody: null,
      FunctionDeclaration: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: 1
      },
      FunctionExpression: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: 1
      },
      CallExpression: {
        arguments: DEFAULT_PARAMETER_INDENT
      },
      ArrayExpression: 1,
      ObjectExpression: 1
    };
    const sourceCode = context.getSourceCode();

    if (context.options.length) {
      if (context.options[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else if (typeof context.options[0] === "number") {
        indentSize = context.options[0];
        indentType = "space";
      }

      if (context.options[1]) {
        const opts = context.options[1];
        options.SwitchCase = opts.SwitchCase || 0;
        const variableDeclaratorRules = opts.VariableDeclarator;

        if (typeof variableDeclaratorRules === "number") {
          options.VariableDeclarator = {
            var: variableDeclaratorRules,
            let: variableDeclaratorRules,
            const: variableDeclaratorRules
          };
        } else if (typeof variableDeclaratorRules === "object") {
          Object.assign(options.VariableDeclarator, variableDeclaratorRules);
        }

        if (typeof opts.outerIIFEBody === "number") {
          options.outerIIFEBody = opts.outerIIFEBody;
        }

        if (typeof opts.MemberExpression === "number") {
          options.MemberExpression = opts.MemberExpression;
        }

        if (typeof opts.FunctionDeclaration === "object") {
          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
        }

        if (typeof opts.FunctionExpression === "object") {
          Object.assign(options.FunctionExpression, opts.FunctionExpression);
        }

        if (typeof opts.CallExpression === "object") {
          Object.assign(options.CallExpression, opts.CallExpression);
        }

        if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
          options.ArrayExpression = opts.ArrayExpression;
        }

        if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
          options.ObjectExpression = opts.ObjectExpression;
        }
      }
    }

    const caseIndentStore = {};

    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
      const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
      const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
      let foundStatement;

      if (actualSpaces > 0 && actualTabs > 0) {
        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;
      } else if (actualSpaces > 0) {
        foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
      } else if (actualTabs > 0) {
        foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
      } else {
        foundStatement = "0";
      }

      return {
        expected: expectedStatement,
        actual: foundStatement
      };
    }

    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
      if (gottenSpaces && gottenTabs) {
        return;
      }

      const desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);
      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];
      context.report({
        node,
        loc,
        messageId: "expected",
        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)
      });
    }

    function getNodeIndent(node, byLastLine) {
      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t"));
      const spaces = indentChars.filter(char => char === " ").length;
      const tabs = indentChars.filter(char => char === "\t").length;
      return {
        space: spaces,
        tab: tabs,
        goodChar: indentType === "space" ? spaces : tabs,
        badChar: indentType === "space" ? tabs : spaces
      };
    }

    function isNodeFirstInLine(node, byEndLocation) {
      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
            endLine = firstToken ? firstToken.loc.end.line : -1;
      return startLine !== endLine;
    }

    function checkNodeIndent(node, neededIndent) {
      const actualIndent = getNodeIndent(node, false);

      if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
        report(node, neededIndent, actualIndent.space, actualIndent.tab);
      }

      if (node.type === "IfStatement" && node.alternate) {
        const elseToken = sourceCode.getTokenBefore(node.alternate);
        checkNodeIndent(elseToken, neededIndent);

        if (!isNodeFirstInLine(node.alternate)) {
          checkNodeIndent(node.alternate, neededIndent);
        }
      }

      if (node.type === "TryStatement" && node.handler) {
        const catchToken = sourceCode.getFirstToken(node.handler);
        checkNodeIndent(catchToken, neededIndent);
      }

      if (node.type === "TryStatement" && node.finalizer) {
        const finallyToken = sourceCode.getTokenBefore(node.finalizer);
        checkNodeIndent(finallyToken, neededIndent);
      }

      if (node.type === "DoWhileStatement") {
        const whileToken = sourceCode.getTokenAfter(node.body);
        checkNodeIndent(whileToken, neededIndent);
      }
    }

    function checkNodesIndent(nodes, indent) {
      nodes.forEach(node => checkNodeIndent(node, indent));
    }

    function checkLastNodeLineIndent(node, lastLineIndent) {
      const lastToken = sourceCode.getLastToken(node);
      const endIndent = getNodeIndent(lastToken, true);

      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
        report(node, lastLineIndent, endIndent.space, endIndent.tab, {
          line: lastToken.loc.start.line,
          column: lastToken.loc.start.column
        }, true);
      }
    }

    function checkLastReturnStatementLineIndent(node, firstLineIndent) {
      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);

      if (textBeforeClosingParenthesis.trim()) {
        return;
      }

      const endIndent = getNodeIndent(lastToken, true);

      if (endIndent.goodChar !== firstLineIndent) {
        report(node, firstLineIndent, endIndent.space, endIndent.tab, {
          line: lastToken.loc.start.line,
          column: lastToken.loc.start.column
        }, true);
      }
    }

    function checkFirstNodeLineIndent(node, firstLineIndent) {
      const startIndent = getNodeIndent(node, false);

      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
        report(node, firstLineIndent, startIndent.space, startIndent.tab, {
          line: node.loc.start.line,
          column: node.loc.start.column
        });
      }
    }

    function getParentNodeByType(node, type, stopAtList) {
      let parent = node.parent;
      const stopAtSet = new Set(stopAtList || ["Program"]);

      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== "Program") {
        parent = parent.parent;
      }

      return parent.type === type ? parent : null;
    }

    function getVariableDeclaratorNode(node) {
      return getParentNodeByType(node, "VariableDeclarator");
    }

    function isNodeInVarOnTop(node, varNode) {
      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
    }

    function isArgBeforeCalleeNodeMultiline(node) {
      const parent = node.parent;

      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
      }

      return false;
    }

    function isOuterIIFE(node) {
      const parent = node.parent;
      let stmt = parent.parent;

      if (parent.type !== "CallExpression" || parent.callee !== node) {
        return false;
      }

      while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {
        stmt = stmt.parent;
      }

      return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
    }

    function checkIndentInFunctionBlock(node) {
      const calleeNode = node.parent;
      let indent;

      if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
        indent = getNodeIndent(calleeNode, false).goodChar;
      } else {
        indent = getNodeIndent(calleeNode).goodChar;
      }

      if (calleeNode.parent.type === "CallExpression") {
        const calleeParent = calleeNode.parent;

        if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
            indent = getNodeIndent(calleeParent).goodChar;
          }
        } else {
          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
            indent = getNodeIndent(calleeParent).goodChar;
          }
        }
      }

      let functionOffset = indentSize;

      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
        functionOffset = options.outerIIFEBody * indentSize;
      } else if (calleeNode.type === "FunctionExpression") {
        functionOffset = options.FunctionExpression.body * indentSize;
      } else if (calleeNode.type === "FunctionDeclaration") {
        functionOffset = options.FunctionDeclaration.body * indentSize;
      }

      indent += functionOffset;
      const parentVarNode = getVariableDeclaratorNode(node);

      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
      }

      if (node.body.length > 0) {
        checkNodesIndent(node.body, indent);
      }

      checkLastNodeLineIndent(node, indent - functionOffset);
    }

    function isSingleLineNode(node) {
      const lastToken = sourceCode.getLastToken(node),
            startLine = node.loc.start.line,
            endLine = lastToken.loc.end.line;
      return startLine === endLine;
    }

    function checkIndentInArrayOrObjectBlock(node) {
      if (isSingleLineNode(node)) {
        return;
      }

      let elements = node.type === "ArrayExpression" ? node.elements : node.properties;
      elements = elements.filter(elem => elem !== null);
      let nodeIndent;
      let elementsIndent;
      const parentVarNode = getVariableDeclaratorNode(node);

      if (isNodeFirstInLine(node)) {
        const parent = node.parent;
        nodeIndent = getNodeIndent(parent).goodChar;

        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
          if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
            if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
            } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
              const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;
              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) ;else if (typeof options[parent.type] === "number") {
                nodeIndent += options[parent.type] * indentSize;
              } else {
                nodeIndent = parentElements[0].loc.start.column;
              }
            } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
              if (typeof options.CallExpression.arguments === "number") {
                nodeIndent += options.CallExpression.arguments * indentSize;
              } else if (options.CallExpression.arguments === "first") {
                if (parent.arguments.indexOf(node) !== -1) {
                  nodeIndent = parent.arguments[0].loc.start.column;
                }
              } else {
                nodeIndent += indentSize;
              }
            } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
              nodeIndent += indentSize;
            }
          }
        }

        checkFirstNodeLineIndent(node, nodeIndent);
      } else {
        nodeIndent = getNodeIndent(node).goodChar;
      }

      if (options[node.type] === "first") {
        elementsIndent = elements.length ? elements[0].loc.start.column : 0;
      } else {
        elementsIndent = nodeIndent + indentSize * options[node.type];
      }

      if (isNodeInVarOnTop(node, parentVarNode)) {
        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
      }

      checkNodesIndent(elements, elementsIndent);

      if (elements.length > 0) {
        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
          return;
        }
      }

      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
    }

    function isNodeBodyBlock(node) {
      return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
    }

    function blockIndentationCheck(node) {
      if (isSingleLineNode(node)) {
        return;
      }

      if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
        checkIndentInFunctionBlock(node);
        return;
      }

      let indent;
      let nodesToCheck = [];

      if (node.parent && ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"].indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
        indent = getNodeIndent(node.parent).goodChar;
      } else if (node.parent && node.parent.type === "CatchClause") {
        indent = getNodeIndent(node.parent.parent).goodChar;
      } else {
        indent = getNodeIndent(node).goodChar;
      }

      if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
        nodesToCheck = [node.consequent];
      } else if (Array.isArray(node.body)) {
        nodesToCheck = node.body;
      } else {
        nodesToCheck = [node.body];
      }

      if (nodesToCheck.length > 0) {
        checkNodesIndent(nodesToCheck, indent + indentSize);
      }

      if (node.type === "BlockStatement") {
        checkLastNodeLineIndent(node, indent);
      }
    }

    function filterOutSameLineVars(node) {
      return node.declarations.reduce((finalCollection, elem) => {
        const lastElem = finalCollection[finalCollection.length - 1];

        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
          finalCollection.push(elem);
        }

        return finalCollection;
      }, []);
    }

    function checkIndentInVariableDeclarations(node) {
      const elements = filterOutSameLineVars(node);
      const nodeIndent = getNodeIndent(node).goodChar;
      const lastElement = elements[elements.length - 1];
      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
      checkNodesIndent(elements, elementsIndent);

      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
        return;
      }

      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);

      if (tokenBeforeLastElement.value === ",") {
        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
      } else {
        checkLastNodeLineIndent(node, elementsIndent - indentSize);
      }
    }

    function blockLessNodes(node) {
      if (node.body.type !== "BlockStatement") {
        blockIndentationCheck(node);
      }
    }

    function expectedCaseIndent(node, providedSwitchIndent) {
      const switchNode = node.type === "SwitchStatement" ? node : node.parent;
      const switchIndent = typeof providedSwitchIndent === "undefined" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;
      let caseIndent;

      if (caseIndentStore[switchNode.loc.start.line]) {
        return caseIndentStore[switchNode.loc.start.line];
      }

      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
        caseIndent = switchIndent;
      } else {
        caseIndent = switchIndent + indentSize * options.SwitchCase;
      }

      caseIndentStore[switchNode.loc.start.line] = caseIndent;
      return caseIndent;
    }

    function isWrappedInParenthesis(node) {
      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), "");
      return /^return\s*?\(\s*?\);*?/u.test(statementWithoutArgument);
    }

    return {
      Program(node) {
        if (node.body.length > 0) {
          checkNodesIndent(node.body, getNodeIndent(node).goodChar);
        }
      },

      ClassBody: blockIndentationCheck,
      BlockStatement: blockIndentationCheck,
      WhileStatement: blockLessNodes,
      ForStatement: blockLessNodes,
      ForInStatement: blockLessNodes,
      ForOfStatement: blockLessNodes,
      DoWhileStatement: blockLessNodes,

      IfStatement(node) {
        if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
          blockIndentationCheck(node);
        }
      },

      VariableDeclaration(node) {
        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
          checkIndentInVariableDeclarations(node);
        }
      },

      ObjectExpression(node) {
        checkIndentInArrayOrObjectBlock(node);
      },

      ArrayExpression(node) {
        checkIndentInArrayOrObjectBlock(node);
      },

      MemberExpression(node) {
        if (typeof options.MemberExpression === "undefined") {
          return;
        }

        if (isSingleLineNode(node)) {
          return;
        }

        if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
          return;
        }

        if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
          return;
        }

        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
        const checkNodes = [node.property];
        const dot = sourceCode.getTokenBefore(node.property);

        if (dot.type === "Punctuator" && dot.value === ".") {
          checkNodes.push(dot);
        }

        checkNodesIndent(checkNodes, propertyIndent);
      },

      SwitchStatement(node) {
        const switchIndent = getNodeIndent(node).goodChar;
        const caseIndent = expectedCaseIndent(node, switchIndent);
        checkNodesIndent(node.cases, caseIndent);
        checkLastNodeLineIndent(node, switchIndent);
      },

      SwitchCase(node) {
        if (isSingleLineNode(node)) {
          return;
        }

        const caseIndent = expectedCaseIndent(node);
        checkNodesIndent(node.consequent, caseIndent + indentSize);
      },

      FunctionDeclaration(node) {
        if (isSingleLineNode(node)) {
          return;
        }

        if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
        } else if (options.FunctionDeclaration.parameters !== null) {
          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
        }
      },

      FunctionExpression(node) {
        if (isSingleLineNode(node)) {
          return;
        }

        if (options.FunctionExpression.parameters === "first" && node.params.length) {
          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
        } else if (options.FunctionExpression.parameters !== null) {
          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
        }
      },

      ReturnStatement(node) {
        if (isSingleLineNode(node)) {
          return;
        }

        const firstLineIndent = getNodeIndent(node).goodChar;

        if (isWrappedInParenthesis(node)) {
          checkLastReturnStatementLineIndent(node, firstLineIndent);
        } else {
          checkNodeIndent(node, firstLineIndent);
        }
      },

      CallExpression(node) {
        if (isSingleLineNode(node)) {
          return;
        }

        if (options.CallExpression.arguments === "first" && node.arguments.length) {
          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
        } else if (options.CallExpression.arguments !== null) {
          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
        }
      }

    };
  }

};
const KNOWN_NODES = new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ChainExpression", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXFragment", "JSXOpeningFragment", "JSXClosingFragment", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "ImportExpression"]);

class BinarySearchTree {
  constructor() {
    this._rbTree = functionalRedBlackTree__default['default']();
  }

  insert(key, value) {
    const iterator = this._rbTree.find(key);

    if (iterator.valid) {
      this._rbTree = iterator.update(value);
    } else {
      this._rbTree = this._rbTree.insert(key, value);
    }
  }

  findLe(key) {
    const iterator = this._rbTree.le(key);

    return iterator && {
      key: iterator.key,
      value: iterator.value
    };
  }

  deleteRange(start, end) {
    if (start === end) {
      return;
    }

    const iterator = this._rbTree.ge(start);

    while (iterator.valid && iterator.key < end) {
      this._rbTree = this._rbTree.remove(iterator.key);
      iterator.next();
    }
  }

}

class TokenInfo {
  constructor(sourceCode) {
    this.sourceCode = sourceCode;
    this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {
      if (!map.has(token.loc.start.line)) {
        map.set(token.loc.start.line, token);
      }

      if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
        map.set(token.loc.end.line, token);
      }

      return map;
    }, new Map());
  }

  getFirstTokenOfLine(token) {
    return this.firstTokensByLineNumber.get(token.loc.start.line);
  }

  isFirstTokenOfLine(token) {
    return this.getFirstTokenOfLine(token) === token;
  }

  getTokenIndent(token) {
    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
  }

}

class OffsetStorage {
  constructor(tokenInfo, indentSize, indentType) {
    this._tokenInfo = tokenInfo;
    this._indentSize = indentSize;
    this._indentType = indentType;
    this._tree = new BinarySearchTree();

    this._tree.insert(0, {
      offset: 0,
      from: null,
      force: false
    });

    this._lockedFirstTokens = new WeakMap();
    this._desiredIndentCache = new WeakMap();
    this._ignoredTokens = new WeakSet();
  }

  _getOffsetDescriptor(token) {
    return this._tree.findLe(token.range[0]).value;
  }

  matchOffsetOf(baseToken, offsetToken) {
    this._lockedFirstTokens.set(offsetToken, baseToken);
  }

  setDesiredOffset(token, fromToken, offset) {
    return this.setDesiredOffsets(token.range, fromToken, offset);
  }

  setDesiredOffsets(range, fromToken, offset, force) {
    const descriptorToInsert = {
      offset,
      from: fromToken,
      force
    };

    const descriptorAfterRange = this._tree.findLe(range[1]).value;

    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];

    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);

    this._tree.deleteRange(range[0] + 1, range[1]);

    this._tree.insert(range[0], descriptorToInsert);

    if (fromTokenIsInRange) {
      this._tree.insert(fromToken.range[0], fromTokenDescriptor);

      this._tree.insert(fromToken.range[1], descriptorToInsert);
    }

    this._tree.insert(range[1], descriptorAfterRange);
  }

  getDesiredIndent(token) {
    if (!this._desiredIndentCache.has(token)) {
      if (this._ignoredTokens.has(token)) {
        this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
      } else if (this._lockedFirstTokens.has(token)) {
        const firstToken = this._lockedFirstTokens.get(token);

        this._desiredIndentCache.set(token, this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) + this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));
      } else {
        const offsetInfo = this._getOffsetDescriptor(token);

        const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;

        this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset));
      }
    }

    return this._desiredIndentCache.get(token);
  }

  ignoreToken(token) {
    if (this._tokenInfo.isFirstTokenOfLine(token)) {
      this._ignoredTokens.add(token);
    }
  }

  getFirstDependency(token) {
    return this._getOffsetDescriptor(token).from;
  }

}

const ELEMENT_LIST_SCHEMA = {
  oneOf: [{
    type: "integer",
    minimum: 0
  }, {
    enum: ["first", "off"]
  }]
};
var indent = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/indent"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0,
          default: 0
        },
        VariableDeclarator: {
          oneOf: [ELEMENT_LIST_SCHEMA, {
            type: "object",
            properties: {
              var: ELEMENT_LIST_SCHEMA,
              let: ELEMENT_LIST_SCHEMA,
              const: ELEMENT_LIST_SCHEMA
            },
            additionalProperties: false
          }]
        },
        outerIIFEBody: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["off"]
          }]
        },
        MemberExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["off"]
          }]
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        CallExpression: {
          type: "object",
          properties: {
            arguments: ELEMENT_LIST_SCHEMA
          },
          additionalProperties: false
        },
        ArrayExpression: ELEMENT_LIST_SCHEMA,
        ObjectExpression: ELEMENT_LIST_SCHEMA,
        ImportDeclaration: ELEMENT_LIST_SCHEMA,
        flatTernaryExpressions: {
          type: "boolean",
          default: false
        },
        offsetTernaryExpressions: {
          type: "boolean",
          default: false
        },
        ignoredNodes: {
          type: "array",
          items: {
            type: "string",
            not: {
              pattern: ":exit$"
            }
          }
        },
        ignoreComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },

  create(context) {
    const DEFAULT_VARIABLE_INDENT = 1;
    let indentType = "space";
    let indentSize = 4;
    const options = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: 1,
        let: 1,
        const: 1
      },
      outerIIFEBody: 1,
      FunctionDeclaration: {
        parameters: 1,
        body: 1
      },
      FunctionExpression: {
        parameters: 1,
        body: 1
      },
      CallExpression: {
        arguments: 1
      },
      MemberExpression: 1,
      ArrayExpression: 1,
      ObjectExpression: 1,
      ImportDeclaration: 1,
      flatTernaryExpressions: false,
      ignoredNodes: [],
      ignoreComments: false
    };

    if (context.options.length) {
      if (context.options[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else {
        indentSize = context.options[0];
        indentType = "space";
      }

      if (context.options[1]) {
        Object.assign(options, context.options[1]);

        if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
          options.VariableDeclarator = {
            var: options.VariableDeclarator,
            let: options.VariableDeclarator,
            const: options.VariableDeclarator
          };
        }
      }
    }

    const sourceCode = context.getSourceCode();
    const tokenInfo = new TokenInfo(sourceCode);
    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "\t");
    const parameterParens = new WeakSet();

    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
      const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
      const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
      let foundStatement;

      if (actualSpaces > 0) {
        foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
      } else if (actualTabs > 0) {
        foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
      } else {
        foundStatement = "0";
      }

      return {
        expected: expectedStatement,
        actual: foundStatement
      };
    }

    function report(token, neededIndent) {
      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
      const numSpaces = actualIndent.filter(char => char === " ").length;
      const numTabs = actualIndent.filter(char => char === "\t").length;
      context.report({
        node: token,
        messageId: "wrongIndentation",
        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
        loc: {
          start: {
            line: token.loc.start.line,
            column: 0
          },
          end: {
            line: token.loc.start.line,
            column: token.loc.start.column
          }
        },

        fix(fixer) {
          const range = [token.range[0] - token.loc.start.column, token.range[0]];
          return fixer.replaceTextRange(range, neededIndent);
        }

      });
    }

    function validateTokenIndent(token, desiredIndent) {
      const indentation = tokenInfo.getTokenIndent(token);
      return indentation === desiredIndent || indentation.includes(" ") && indentation.includes("\t");
    }

    function isOuterIIFE(node) {
      if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
        return false;
      }

      let statement = node.parent && node.parent.parent;

      while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
        statement = statement.parent;
      }

      return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
    }

    function countTrailingLinebreaks(string) {
      const trailingWhitespace = string.match(/\s*$/u)[0];
      const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());
      return linebreakMatches === null ? 0 : linebreakMatches.length;
    }

    function addElementListIndent(elements, startToken, endToken, offset) {
      function getFirstToken(element) {
        let token = sourceCode.getTokenBefore(element);

        while (astUtils.isOpeningParenToken(token) && token !== startToken) {
          token = sourceCode.getTokenBefore(token);
        }

        return sourceCode.getTokenAfter(token);
      }

      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === "number" ? offset : 1);
      offsets.setDesiredOffset(endToken, startToken, 0);

      if (offset === "first" && elements.length && !elements[0]) {
        return;
      }

      elements.forEach((element, index) => {
        if (!element) {
          return;
        }

        if (offset === "off") {
          offsets.ignoreToken(getFirstToken(element));
        }

        if (index === 0) {
          return;
        }

        if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
          offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
        } else {
          const previousElement = elements[index - 1];
          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);

          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {
            offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);
          }
        }
      });
    }

    function addBlocklessNodeIndent(node) {
      if (node.type !== "BlockStatement") {
        const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);
        let firstBodyToken = sourceCode.getFirstToken(node);
        let lastBodyToken = sourceCode.getLastToken(node);

        while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
        }

        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
        const lastToken = sourceCode.getLastToken(node);

        if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
          offsets.setDesiredOffset(lastToken, lastParentToken, 0);
        }
      }
    }

    function addFunctionCallIndent(node) {
      let openingParen;

      if (node.arguments.length) {
        openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
      } else {
        openingParen = sourceCode.getLastToken(node, 1);
      }

      const closingParen = sourceCode.getLastToken(node);
      parameterParens.add(openingParen);
      parameterParens.add(closingParen);

      if (node.optional) {
        const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);
        const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, {
          filter: astUtils.isClosingParenToken
        }).length;
        const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, {
          skip: calleeParenCount - 1
        }) : sourceCode.getFirstToken(node.callee);
        const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
        const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;
        offsets.setDesiredOffset(dotToken, offsetBase, 1);
      }

      const offsetAfterToken = node.callee.type === "TaggedTemplateExpression" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;
      const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);
      offsets.setDesiredOffset(openingParen, offsetToken, 0);
      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
    }

    function addParensIndent(tokens) {
      const parenStack = [];
      const parenPairs = [];
      tokens.forEach(nextToken => {
        if (astUtils.isOpeningParenToken(nextToken)) {
          parenStack.push(nextToken);
        } else if (astUtils.isClosingParenToken(nextToken)) {
          parenPairs.unshift({
            left: parenStack.pop(),
            right: nextToken
          });
        }
      });
      parenPairs.forEach(pair => {
        const leftParen = pair.left;
        const rightParen = pair.right;

        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
          parenthesizedTokens.forEach(token => {
            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
              offsets.setDesiredOffset(token, leftParen, 1);
            }
          });
        }

        offsets.setDesiredOffset(rightParen, leftParen, 0);
      });
    }

    function ignoreNode(node) {
      const unknownNodeTokens = new Set(sourceCode.getTokens(node, {
        includeComments: true
      }));
      unknownNodeTokens.forEach(token => {
        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);

          if (token === firstTokenOfLine) {
            offsets.ignoreToken(token);
          } else {
            offsets.setDesiredOffset(token, firstTokenOfLine, 0);
          }
        }
      });
    }

    function isOnFirstLineOfStatement(token, leafNode) {
      let node = leafNode;

      while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
        node = node.parent;
      }

      node = node.parent;
      return !node || node.loc.start.line === token.loc.start.line;
    }

    function hasBlankLinesBetween(firstToken, secondToken) {
      const firstTokenLine = firstToken.loc.end.line;
      const secondTokenLine = secondToken.loc.start.line;

      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
        return false;
      }

      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
        if (!tokenInfo.firstTokensByLineNumber.has(line)) {
          return true;
        }
      }

      return false;
    }

    const ignoredNodeFirstTokens = new Set();
    const listenerCallQueue = [];
    const offsetListeners = lodash__default['default'].mapValues({
      "ArrayExpression, ArrayPattern"(node) {
        const openingBracket = sourceCode.getFirstToken(node);
        const closingBracket = sourceCode.getTokenAfter(lodash__default['default'].findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);
        addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
      },

      "ObjectExpression, ObjectPattern"(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);
        addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
      },

      ArrowFunctionExpression(node) {
        const maybeOpeningParen = sourceCode.getFirstToken(node, {
          skip: node.async ? 1 : 0
        });

        if (astUtils.isOpeningParenToken(maybeOpeningParen)) {
          const openingParen = maybeOpeningParen;
          const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
        }

        addBlocklessNodeIndent(node.body);
      },

      AssignmentExpression(node) {
        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
        offsets.ignoreToken(operator);
        offsets.ignoreToken(sourceCode.getTokenAfter(operator));
      },

      "BinaryExpression, LogicalExpression"(node) {
        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        const tokenAfterOperator = sourceCode.getTokenAfter(operator);
        offsets.ignoreToken(operator);
        offsets.ignoreToken(tokenAfterOperator);
        offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
      },

      "BlockStatement, ClassBody"(node) {
        let blockIndentLevel;

        if (node.parent && isOuterIIFE(node.parent)) {
          blockIndentLevel = options.outerIIFEBody;
        } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
          blockIndentLevel = options.FunctionExpression.body;
        } else if (node.parent && node.parent.type === "FunctionDeclaration") {
          blockIndentLevel = options.FunctionDeclaration.body;
        } else {
          blockIndentLevel = 1;
        }

        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
          offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
        }

        addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
      },

      CallExpression: addFunctionCallIndent,

      "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
        const classToken = sourceCode.getFirstToken(node);
        const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);
        offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
      },

      ConditionalExpression(node) {
        const firstToken = sourceCode.getFirstToken(node);

        if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
          const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === "Punctuator" && token.value === "?");
          const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === "Punctuator" && token.value === ":");
          const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
          const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
          const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
          offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
          offsets.setDesiredOffset(colonToken, firstToken, 1);
          offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);

          if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
            offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
          } else {
            offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);
          }
        }
      },

      "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": node => addBlocklessNodeIndent(node.body),

      ExportNamedDeclaration(node) {
        if (node.declaration === null) {
          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {
            skip: 1
          }), closingCurly, 1);

          if (node.source) {
            offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
          }
        }
      },

      ForStatement(node) {
        const forOpeningParen = sourceCode.getFirstToken(node, 1);

        if (node.init) {
          offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
        }

        if (node.test) {
          offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
        }

        if (node.update) {
          offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
        }

        addBlocklessNodeIndent(node.body);
      },

      "FunctionDeclaration, FunctionExpression"(node) {
        const closingParen = sourceCode.getTokenBefore(node.body);
        const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
      },

      IfStatement(node) {
        addBlocklessNodeIndent(node.consequent);

        if (node.alternate && node.alternate.type !== "IfStatement") {
          addBlocklessNodeIndent(node.alternate);
        }
      },

      ImportDeclaration(node) {
        if (node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) {
          const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
          addElementListIndent(node.specifiers.filter(specifier => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
        }

        const fromToken = sourceCode.getLastToken(node, token => token.type === "Identifier" && token.value === "from");
        const sourceToken = sourceCode.getLastToken(node, token => token.type === "String");
        const semiToken = sourceCode.getLastToken(node, token => token.type === "Punctuator" && token.value === ";");

        if (fromToken) {
          const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];
          offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);
        }
      },

      ImportExpression(node) {
        const openingParen = sourceCode.getFirstToken(node, 1);
        const closingParen = sourceCode.getLastToken(node);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
        addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);
      },

      "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
        const object = node.type === "MetaProperty" ? node.meta : node.object;
        const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
        const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
        const objectParenCount = sourceCode.getTokensBetween(object, node.property, {
          filter: astUtils.isClosingParenToken
        }).length;
        const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {
          skip: objectParenCount - 1
        }) : sourceCode.getFirstToken(object);
        const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
        const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;

        if (node.computed) {
          offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
          offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
        }

        const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;

        if (typeof options.MemberExpression === "number") {
          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
          offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
        } else {
          offsets.ignoreToken(firstNonObjectToken);
          offsets.ignoreToken(secondNonObjectToken);
          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
          offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
        }
      },

      NewExpression(node) {
        if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
          addFunctionCallIndent(node);
        }
      },

      Property(node) {
        if (!node.shorthand && !node.method && node.kind === "init") {
          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);
          offsets.ignoreToken(sourceCode.getTokenAfter(colon));
        }
      },

      SwitchStatement(node) {
        const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);

        if (node.cases.length) {
          sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {
            includeComments: true,
            filter: astUtils.isCommentToken
          }).forEach(token => offsets.ignoreToken(token));
        }
      },

      SwitchCase(node) {
        if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
          const caseKeyword = sourceCode.getFirstToken(node);
          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);
          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
        }
      },

      TemplateLiteral(node) {
        node.expressions.forEach((expression, index) => {
          const previousQuasi = node.quasis[index];
          const nextQuasi = node.quasis[index + 1];
          const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;
          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
        });
      },

      VariableDeclaration(node) {
        let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;
        const firstToken = sourceCode.getFirstToken(node),
              lastToken = sourceCode.getLastToken(node);

        if (options.VariableDeclarator[node.kind] === "first") {
          if (node.declarations.length > 1) {
            addElementListIndent(node.declarations, firstToken, lastToken, "first");
            return;
          }

          variableIndent = DEFAULT_VARIABLE_INDENT;
        }

        if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
        } else {
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
        }

        if (astUtils.isSemicolonToken(lastToken)) {
          offsets.ignoreToken(lastToken);
        }
      },

      VariableDeclarator(node) {
        if (node.init) {
          const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
          const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);
          offsets.ignoreToken(equalOperator);
          offsets.ignoreToken(tokenAfterOperator);
          offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
          offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
        }
      },

      "JSXAttribute[value]"(node) {
        const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === "Punctuator" && token.value === "=");
        offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
      },

      JSXElement(node) {
        if (node.closingElement) {
          addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
        }
      },

      JSXOpeningElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        let closingToken;

        if (node.selfClosing) {
          closingToken = sourceCode.getLastToken(node, {
            skip: 1
          });
          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
        } else {
          closingToken = sourceCode.getLastToken(node);
        }

        offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
        addElementListIndent(node.attributes, firstToken, closingToken, 1);
      },

      JSXClosingElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        offsets.setDesiredOffsets(node.name.range, firstToken, 1);
      },

      JSXFragment(node) {
        const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);
        const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);
        addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);
      },

      JSXOpeningFragment(node) {
        const firstToken = sourceCode.getFirstToken(node);
        const closingToken = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets(node.range, firstToken, 1);
        offsets.matchOffsetOf(firstToken, closingToken);
      },

      JSXClosingFragment(node) {
        const firstToken = sourceCode.getFirstToken(node);
        const slashToken = sourceCode.getLastToken(node, {
          skip: 1
        });
        const closingToken = sourceCode.getLastToken(node);
        const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;
        offsets.setDesiredOffsets(node.range, firstToken, 1);
        offsets.matchOffsetOf(firstToken, tokenToMatch);
      },

      JSXExpressionContainer(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
      },

      JSXSpreadAttribute(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
      },

      "*"(node) {
        const firstToken = sourceCode.getFirstToken(node);

        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
          offsets.setDesiredOffsets(node.range, firstToken, 0);
        }
      }

    }, listener => node => listenerCallQueue.push({
      listener,
      node
    }));
    const ignoredNodes = new Set();

    function addToIgnoredNodes(node) {
      ignoredNodes.add(node);
      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
    }

    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {
      [ignoredSelector]: addToIgnoredNodes
    }), {});
    return Object.assign(offsetListeners, ignoredNodeListeners, {
      "*:exit"(node) {
        if (!KNOWN_NODES.has(node.type)) {
          addToIgnoredNodes(node);
        }
      },

      "Program:exit"() {
        if (options.ignoreComments) {
          sourceCode.getAllComments().forEach(comment => offsets.ignoreToken(comment));
        }

        listenerCallQueue.filter(nodeInfo => !ignoredNodes.has(nodeInfo.node)).forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));
        ignoredNodes.forEach(ignoreNode);
        addParensIndent(sourceCode.ast.tokens);
        const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {
          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
        }, new WeakMap());
        sourceCode.lines.forEach((line, lineIndex) => {
          const lineNumber = lineIndex + 1;

          if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
            return;
          }

          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);

          if (firstTokenOfLine.loc.start.line !== lineNumber) {
            return;
          }

          if (astUtils.isCommentToken(firstTokenOfLine)) {
            const tokenBefore = precedingTokens.get(firstTokenOfLine);
            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);

            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {
              offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);
            }

            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
              return;
            }
          }

          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
            return;
          }

          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
        });
      }

    });
  }

};

function isForLoop(block) {
  return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
}

function isInitialized$1(node) {
  const declaration = node.parent;
  const block = declaration.parent;

  if (isForLoop(block)) {
    if (block.type === "ForStatement") {
      return block.init === declaration;
    }

    return block.left === declaration;
  }

  return Boolean(node.init);
}

var initDeclarations = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow initialization in variable declarations",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/init-declarations"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            ignoreForLoopInit: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      initialized: "Variable '{{idName}}' should be initialized on declaration.",
      notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
    }
  },

  create(context) {
    const mode = context.options[0] || "always";
    const params = context.options[1] || {};
    return {
      "VariableDeclaration:exit"(node) {
        const kind = node.kind,
              declarations = node.declarations;

        for (let i = 0; i < declarations.length; ++i) {
          const declaration = declarations[i],
                id = declaration.id,
                initialized = isInitialized$1(declaration),
                isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
          let messageId = "";

          if (mode === "always" && !initialized) {
            messageId = "initialized";
          } else if (mode === "never" && kind !== "const" && initialized && !isIgnoredForLoop) {
            messageId = "notInitialized";
          }

          if (id.type === "Identifier" && messageId) {
            context.report({
              node: declaration,
              messageId,
              data: {
                idName: id.name
              }
            });
          }
        }
      }

    };
  }

};
const QUOTE_SETTINGS$1 = {
  "prefer-double": {
    quote: "\"",
    description: "singlequote",

    convert(str) {
      return str.replace(/'/gu, "\"");
    }

  },
  "prefer-single": {
    quote: "'",
    description: "doublequote",

    convert(str) {
      return str.replace(/"/gu, "'");
    }

  }
};
var jsxQuotes = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either double or single quotes in JSX attributes",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/jsx-quotes"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["prefer-single", "prefer-double"]
    }],
    messages: {
      unexpected: "Unexpected usage of {{description}}."
    }
  },

  create(context) {
    const quoteOption = context.options[0] || "prefer-double",
          setting = QUOTE_SETTINGS$1[quoteOption];

    function usesExpectedQuotes(node) {
      return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
    }

    return {
      JSXAttribute(node) {
        const attributeValue = node.value;

        if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
          context.report({
            node: attributeValue,
            messageId: "unexpected",
            data: {
              description: setting.description
            },

            fix(fixer) {
              return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
            }

          });
        }
      }

    };
  }

};

function containsLineTerminator(str) {
  return astUtils.LINEBREAK_MATCHER.test(str);
}

function last(arr) {
  return arr[arr.length - 1];
}

function isSingleLine(node) {
  return node.loc.end.line === node.loc.start.line;
}

function isSingleLineProperties(properties) {
  const [firstProp] = properties,
        lastProp = last(properties);
  return firstProp.loc.start.line === lastProp.loc.end.line;
}

function initOptionProperty(toOptions, fromOptions) {
  toOptions.mode = fromOptions.mode || "strict";

  if (typeof fromOptions.beforeColon !== "undefined") {
    toOptions.beforeColon = +fromOptions.beforeColon;
  } else {
    toOptions.beforeColon = 0;
  }

  if (typeof fromOptions.afterColon !== "undefined") {
    toOptions.afterColon = +fromOptions.afterColon;
  } else {
    toOptions.afterColon = 1;
  }

  if (typeof fromOptions.align !== "undefined") {
    if (typeof fromOptions.align === "object") {
      toOptions.align = fromOptions.align;
    } else {
      toOptions.align = {
        on: fromOptions.align,
        mode: toOptions.mode,
        beforeColon: toOptions.beforeColon,
        afterColon: toOptions.afterColon
      };
    }
  }

  return toOptions;
}

function initOptions(toOptions, fromOptions) {
  if (typeof fromOptions.align === "object") {
    toOptions.align = initOptionProperty({}, fromOptions.align);
    toOptions.align.on = fromOptions.align.on || "colon";
    toOptions.align.mode = fromOptions.align.mode || "strict";
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
  } else {
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);

    if (toOptions.multiLine.align) {
      toOptions.align = {
        on: toOptions.multiLine.align.on,
        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
        beforeColon: toOptions.multiLine.align.beforeColon,
        afterColon: toOptions.multiLine.align.afterColon
      };
    }
  }

  return toOptions;
}

var keySpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing between keys and values in object literal properties",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/key-spacing"
    },
    fixable: "whitespace",
    schema: [{
      anyOf: [{
        type: "object",
        properties: {
          align: {
            anyOf: [{
              enum: ["colon", "value"]
            }, {
              type: "object",
              properties: {
                mode: {
                  enum: ["strict", "minimum"]
                },
                on: {
                  enum: ["colon", "value"]
                },
                beforeColon: {
                  type: "boolean"
                },
                afterColon: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }]
          },
          mode: {
            enum: ["strict", "minimum"]
          },
          beforeColon: {
            type: "boolean"
          },
          afterColon: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              align: {
                anyOf: [{
                  enum: ["colon", "value"]
                }, {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    on: {
                      enum: ["colon", "value"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }]
              },
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          align: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              on: {
                enum: ["colon", "value"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      extraKey: "Extra space after {{computed}}key '{{key}}'.",
      extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
      missingKey: "Missing space after {{computed}}key '{{key}}'.",
      missingValue: "Missing space before value for {{computed}}key '{{key}}'."
    }
  },

  create(context) {
    const options = context.options[0] || {},
          ruleOptions = initOptions({}, options),
          multiLineOptions = ruleOptions.multiLine,
          singleLineOptions = ruleOptions.singleLine,
          alignmentOptions = ruleOptions.align || null;
    const sourceCode = context.getSourceCode();

    function continuesPropertyGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line,
            candidateStartLine = candidate.loc.start.line;

      if (candidateStartLine - groupEndLine <= 1) {
        return true;
      }

      const leadingComments = sourceCode.getCommentsBefore(candidate);

      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {
        for (let i = 1; i < leadingComments.length; i++) {
          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
            return false;
          }
        }

        return true;
      }

      return false;
    }

    function isKeyValueProperty(property) {
      return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
    }

    function getLastTokenBeforeColon(node) {
      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);
      return sourceCode.getTokenBefore(colonToken);
    }

    function getNextColon(node) {
      return sourceCode.getTokenAfter(node, astUtils.isColonToken);
    }

    function getKey(property) {
      const key = property.key;

      if (property.computed) {
        return sourceCode.getText().slice(key.range[0], key.range[1]);
      }

      return astUtils.getStaticPropertyName(property);
    }

    function report(property, side, whitespace, expected, mode) {
      const diff = whitespace.length - expected,
            nextColon = getNextColon(property.key),
            tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {
        includeComments: true
      }),
            tokenAfterColon = sourceCode.getTokenAfter(nextColon, {
        includeComments: true
      }),
            isKeySide = side === "key",
            isExtra = diff > 0,
            diffAbs = Math.abs(diff),
            spaces = Array(diffAbs + 1).join(" ");
      const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
      const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
      const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
      const loc = isExtra ? {
        start: locStart,
        end: locEnd
      } : missingLoc;

      if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
        let fix;

        if (isExtra) {
          let range;

          if (isKeySide) {
            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
          } else {
            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
          }

          fix = function (fixer) {
            return fixer.removeRange(range);
          };
        } else {
          if (isKeySide) {
            fix = function (fixer) {
              return fixer.insertTextAfter(tokenBeforeColon, spaces);
            };
          } else {
            fix = function (fixer) {
              return fixer.insertTextBefore(tokenAfterColon, spaces);
            };
          }
        }

        let messageId = "";

        if (isExtra) {
          messageId = side === "key" ? "extraKey" : "extraValue";
        } else {
          messageId = side === "key" ? "missingKey" : "missingValue";
        }

        context.report({
          node: property[side],
          loc,
          messageId,
          data: {
            computed: property.computed ? "computed " : "",
            key: getKey(property)
          },
          fix
        });
      }
    }

    function getKeyWidth(property) {
      const startToken = sourceCode.getFirstToken(property);
      const endToken = getLastTokenBeforeColon(property.key);
      return endToken.range[1] - startToken.range[0];
    }

    function getPropertyWhitespace(property) {
      const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));

      if (whitespace) {
        return {
          beforeColon: whitespace[1],
          afterColon: whitespace[2]
        };
      }

      return null;
    }

    function createGroups(node) {
      if (node.properties.length === 1) {
        return [node.properties];
      }

      return node.properties.reduce((groups, property) => {
        const currentGroup = last(groups),
              prev = last(currentGroup);

        if (!prev || continuesPropertyGroup(prev, property)) {
          currentGroup.push(property);
        } else {
          groups.push([property]);
        }

        return groups;
      }, [[]]);
    }

    function verifyGroupAlignment(properties) {
      const length = properties.length,
            widths = properties.map(getKeyWidth),
            align = alignmentOptions.on;
      let targetWidth = Math.max(...widths),
          beforeColon,
          afterColon,
          mode;

      if (alignmentOptions && length > 1) {
        beforeColon = alignmentOptions.beforeColon;
        afterColon = alignmentOptions.afterColon;
        mode = alignmentOptions.mode;
      } else {
        beforeColon = multiLineOptions.beforeColon;
        afterColon = multiLineOptions.afterColon;
        mode = alignmentOptions.mode;
      }

      targetWidth += align === "colon" ? beforeColon : afterColon;

      for (let i = 0; i < length; i++) {
        const property = properties[i];
        const whitespace = getPropertyWhitespace(property);

        if (whitespace) {
          const width = widths[i];

          if (align === "value") {
            report(property, "key", whitespace.beforeColon, beforeColon, mode);
            report(property, "value", whitespace.afterColon, targetWidth - width, mode);
          } else {
            report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
            report(property, "value", whitespace.afterColon, afterColon, mode);
          }
        }
      }
    }

    function verifySpacing(node, lineOptions) {
      const actual = getPropertyWhitespace(node);

      if (actual) {
        report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
        report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
      }
    }

    function verifyListSpacing(properties, lineOptions) {
      const length = properties.length;

      for (let i = 0; i < length; i++) {
        verifySpacing(properties[i], lineOptions);
      }
    }

    function verifyAlignment(node) {
      createGroups(node).forEach(group => {
        const properties = group.filter(isKeyValueProperty);

        if (properties.length > 0 && isSingleLineProperties(properties)) {
          verifyListSpacing(properties, multiLineOptions);
        } else {
          verifyGroupAlignment(properties);
        }
      });
    }

    if (alignmentOptions) {
      return {
        ObjectExpression(node) {
          if (isSingleLine(node)) {
            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
          } else {
            verifyAlignment(node);
          }
        }

      };
    }

    return {
      Property(node) {
        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
      }

    };
  }

};
const PREV_TOKEN = /^[)\]}>]$/u;
const NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
const PREV_TOKEN_M = /^[)\]}>*]$/u;
const NEXT_TOKEN_M = /^[{*]$/u;
const TEMPLATE_OPEN_PAREN = /\$\{$/u;
const TEMPLATE_CLOSE_PAREN = /^\}/u;
const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;
const KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);

(function () {
  KEYS.sort();

  for (let i = 1; i < KEYS.length; ++i) {
    if (KEYS[i] === KEYS[i - 1]) {
      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
    }
  }
})();

function isOpenParenOfTemplate(token) {
  return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}

function isCloseParenOfTemplate(token) {
  return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}

var keywordSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after keywords",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/keyword-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: true
        },
        after: {
          type: "boolean",
          default: true
        },
        overrides: {
          type: "object",
          properties: KEYS.reduce((retv, key) => {
            retv[key] = {
              type: "object",
              properties: {
                before: {
                  type: "boolean"
                },
                after: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            };
            return retv;
          }, {}),
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedBefore: "Expected space(s) before \"{{value}}\".",
      expectedAfter: "Expected space(s) after \"{{value}}\".",
      unexpectedBefore: "Unexpected space(s) before \"{{value}}\".",
      unexpectedAfter: "Unexpected space(s) after \"{{value}}\"."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function expectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);

      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
        context.report({
          loc: token.loc,
          messageId: "expectedBefore",
          data: token,

          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }

        });
      }
    }

    function unexpectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);

      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
        context.report({
          loc: {
            start: prevToken.loc.end,
            end: token.loc.start
          },
          messageId: "unexpectedBefore",
          data: token,

          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], token.range[0]]);
          }

        });
      }
    }

    function expectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);

      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
        context.report({
          loc: token.loc,
          messageId: "expectedAfter",
          data: token,

          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }

        });
      }
    }

    function unexpectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);

      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
        context.report({
          loc: {
            start: token.loc.end,
            end: nextToken.loc.start
          },
          messageId: "unexpectedAfter",
          data: token,

          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }

        });
      }
    }

    function parseOptions(options = {}) {
      const before = options.before !== false;
      const after = options.after !== false;
      const defaultValue = {
        before: before ? expectSpaceBefore : unexpectSpaceBefore,
        after: after ? expectSpaceAfter : unexpectSpaceAfter
      };
      const overrides = options && options.overrides || {};
      const retv = Object.create(null);

      for (let i = 0; i < KEYS.length; ++i) {
        const key = KEYS[i];
        const override = overrides[key];

        if (override) {
          const thisBefore = "before" in override ? override.before : before;
          const thisAfter = "after" in override ? override.after : after;
          retv[key] = {
            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
          };
        } else {
          retv[key] = defaultValue;
        }
      }

      return retv;
    }

    const checkMethodMap = parseOptions(context.options[0]);

    function checkSpacingBefore(token, pattern) {
      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
    }

    function checkSpacingAfter(token, pattern) {
      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
    }

    function checkSpacingAround(token) {
      checkSpacingBefore(token);
      checkSpacingAfter(token);
    }

    function checkSpacingAroundFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);

      if (firstToken && firstToken.type === "Keyword") {
        checkSpacingAround(firstToken);
      }
    }

    function checkSpacingBeforeFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);

      if (firstToken && firstToken.type === "Keyword") {
        checkSpacingBefore(firstToken);
      }
    }

    function checkSpacingAroundTokenBefore(node) {
      if (node) {
        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
        checkSpacingAround(token);
      }
    }

    function checkSpacingForFunction(node) {
      const firstToken = node && sourceCode.getFirstToken(node);

      if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
        checkSpacingBefore(firstToken);
      }
    }

    function checkSpacingForClass(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.superClass);
    }

    function checkSpacingForModuleDeclaration(node) {
      const firstToken = sourceCode.getFirstToken(node);
      checkSpacingBefore(firstToken, PREV_TOKEN_M);
      checkSpacingAfter(firstToken, NEXT_TOKEN_M);

      if (node.type === "ExportDefaultDeclaration") {
        checkSpacingAround(sourceCode.getTokenAfter(firstToken));
      }

      if (node.type === "ExportAllDeclaration" && node.exported) {
        const asToken = sourceCode.getTokenBefore(node.exported);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
      }

      if (node.source) {
        const fromToken = sourceCode.getTokenBefore(node.source);
        checkSpacingBefore(fromToken, PREV_TOKEN_M);
        checkSpacingAfter(fromToken, NEXT_TOKEN_M);
      }
    }

    function checkSpacingForProperty(node) {
      if (node.static) {
        checkSpacingAroundFirstToken(node);
      }

      if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
        const token = sourceCode.getTokenBefore(node.key, tok => {
          switch (tok.value) {
            case "get":
            case "set":
            case "async":
              return true;

            default:
              return false;
          }
        });

        if (!token) {
          throw new Error("Failed to find token get, set, or async beside method name");
        }

        checkSpacingAround(token);
      }
    }

    return {
      DebuggerStatement: checkSpacingAroundFirstToken,
      WithStatement: checkSpacingAroundFirstToken,
      BreakStatement: checkSpacingAroundFirstToken,
      ContinueStatement: checkSpacingAroundFirstToken,
      ReturnStatement: checkSpacingAroundFirstToken,
      ThrowStatement: checkSpacingAroundFirstToken,
      TryStatement: function (node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundFirstToken(node.handler);
        checkSpacingAroundTokenBefore(node.finalizer);
      },
      IfStatement: function (node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.alternate);
      },
      SwitchStatement: checkSpacingAroundFirstToken,
      SwitchCase: checkSpacingAroundFirstToken,
      DoWhileStatement: function (node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.test);
      },
      ForInStatement: function (node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.right);
      },
      ForOfStatement: function (node) {
        if (node.await) {
          checkSpacingBefore(sourceCode.getFirstToken(node, 0));
          checkSpacingAfter(sourceCode.getFirstToken(node, 1));
        } else {
          checkSpacingAroundFirstToken(node);
        }

        checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
      },
      ForStatement: checkSpacingAroundFirstToken,
      WhileStatement: checkSpacingAroundFirstToken,
      ClassDeclaration: checkSpacingForClass,
      ExportNamedDeclaration: checkSpacingForModuleDeclaration,
      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
      ExportAllDeclaration: checkSpacingForModuleDeclaration,
      FunctionDeclaration: checkSpacingForFunction,
      ImportDeclaration: checkSpacingForModuleDeclaration,
      VariableDeclaration: checkSpacingAroundFirstToken,
      ArrowFunctionExpression: checkSpacingForFunction,
      AwaitExpression: function (node) {
        checkSpacingBefore(sourceCode.getFirstToken(node));
      },
      ClassExpression: checkSpacingForClass,
      FunctionExpression: checkSpacingForFunction,
      NewExpression: checkSpacingBeforeFirstToken,
      Super: checkSpacingBeforeFirstToken,
      ThisExpression: checkSpacingBeforeFirstToken,
      UnaryExpression: checkSpacingBeforeFirstToken,
      YieldExpression: checkSpacingBeforeFirstToken,
      ImportNamespaceSpecifier: function (node) {
        const asToken = sourceCode.getFirstToken(node, 1);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
      },
      MethodDefinition: checkSpacingForProperty,
      Property: checkSpacingForProperty
    };
  }

};
var lineCommentPosition = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce position of line comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/line-comment-position"
    },
    schema: [{
      oneOf: [{
        enum: ["above", "beside"]
      }, {
        type: "object",
        properties: {
          position: {
            enum: ["above", "beside"]
          },
          ignorePattern: {
            type: "string"
          },
          applyDefaultPatterns: {
            type: "boolean"
          },
          applyDefaultIgnorePatterns: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      above: "Expected comment to be above code.",
      beside: "Expected comment to be beside code."
    }
  },

  create(context) {
    const options = context.options[0];
    let above,
        ignorePattern,
        applyDefaultIgnorePatterns = true;

    if (!options || typeof options === "string") {
      above = !options || options === "above";
    } else {
      above = !options.position || options.position === "above";
      ignorePattern = options.ignorePattern;

      if (Object.prototype.hasOwnProperty.call(options, "applyDefaultIgnorePatterns")) {
        applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;
      } else {
        applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
      }
    }

    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
    const customIgnoreRegExp = new RegExp(ignorePattern, "u");
    const sourceCode = context.getSourceCode();
    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type === "Line").forEach(node => {
          if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || /^\s*falls?\s?through/u.test(node.value))) {
            return;
          }

          if (ignorePattern && customIgnoreRegExp.test(node.value)) {
            return;
          }

          const previous = sourceCode.getTokenBefore(node, {
            includeComments: true
          });
          const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;

          if (above) {
            if (isOnSameLine) {
              context.report({
                node,
                messageId: "above"
              });
            }
          } else {
            if (!isOnSameLine) {
              context.report({
                node,
                messageId: "beside"
              });
            }
          }
        });
      }

    };
  }

};
var linebreakStyle = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/linebreak-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["unix", "windows"]
    }],
    messages: {
      expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
      expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function createFix(range, text) {
      return function (fixer) {
        return fixer.replaceTextRange(range, text);
      };
    }

    return {
      Program: function (node) {
        const linebreakStyle = context.options[0] || "unix",
              expectedLF = linebreakStyle === "unix",
              expectedLFChars = expectedLF ? "\n" : "\r\n",
              source = sourceCode.getText(),
              pattern = astUtils.createGlobalLinebreakMatcher();
        let match;
        let i = 0;

        while ((match = pattern.exec(source)) !== null) {
          i++;

          if (match[0] === expectedLFChars) {
            continue;
          }

          const index = match.index;
          const range = [index, index + match[0].length];
          context.report({
            node,
            loc: {
              start: {
                line: i,
                column: sourceCode.lines[i - 1].length
              },
              end: {
                line: i + 1,
                column: 0
              }
            },
            messageId: expectedLF ? "expectedLF" : "expectedCRLF",
            fix: createFix(range, expectedLFChars)
          });
        }
      }
    };
  }

};

function getEmptyLineNums(lines) {
  const emptyLines = lines.map((line, i) => ({
    code: line.trim(),
    num: i + 1
  })).filter(line => !line.code).map(line => line.num);
  return emptyLines;
}

function getCommentLineNums(comments) {
  const lines = [];
  comments.forEach(token => {
    const start = token.loc.start.line;
    const end = token.loc.end.line;
    lines.push(start, end);
  });
  return lines;
}

var linesAroundComment = {
  meta: {
    type: "layout",
    docs: {
      description: "require empty lines around comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-around-comment"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        beforeBlockComment: {
          type: "boolean",
          default: true
        },
        afterBlockComment: {
          type: "boolean",
          default: false
        },
        beforeLineComment: {
          type: "boolean",
          default: false
        },
        afterLineComment: {
          type: "boolean",
          default: false
        },
        allowBlockStart: {
          type: "boolean",
          default: false
        },
        allowBlockEnd: {
          type: "boolean",
          default: false
        },
        allowClassStart: {
          type: "boolean"
        },
        allowClassEnd: {
          type: "boolean"
        },
        allowObjectStart: {
          type: "boolean"
        },
        allowObjectEnd: {
          type: "boolean"
        },
        allowArrayStart: {
          type: "boolean"
        },
        allowArrayEnd: {
          type: "boolean"
        },
        ignorePattern: {
          type: "string"
        },
        applyDefaultIgnorePatterns: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      after: "Expected line after comment.",
      before: "Expected line before comment."
    }
  },

  create(context) {
    const options = Object.assign({}, context.options[0]);
    const ignorePattern = options.ignorePattern;
    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
    const customIgnoreRegExp = new RegExp(ignorePattern, "u");
    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
    options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
    const sourceCode = context.getSourceCode();
    const lines = sourceCode.lines,
          numLines = lines.length + 1,
          comments = sourceCode.getAllComments(),
          commentLines = getCommentLineNums(comments),
          emptyLines = getEmptyLineNums(lines),
          commentAndEmptyLines = commentLines.concat(emptyLines);

    function codeAroundComment(token) {
      let currentToken = token;

      do {
        currentToken = sourceCode.getTokenBefore(currentToken, {
          includeComments: true
        });
      } while (currentToken && astUtils.isCommentToken(currentToken));

      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
        return true;
      }

      currentToken = token;

      do {
        currentToken = sourceCode.getTokenAfter(currentToken, {
          includeComments: true
        });
      } while (currentToken && astUtils.isCommentToken(currentToken));

      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
        return true;
      }

      return false;
    }

    function isParentNodeType(parent, nodeType) {
      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
    }

    function getParentNodeOfToken(token) {
      return sourceCode.getNodeByRangeIndex(token.range[0]);
    }

    function isCommentAtParentStart(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;
    }

    function isCommentAtParentEnd(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
    }

    function isCommentAtBlockStart(token) {
      return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
    }

    function isCommentAtBlockEnd(token) {
      return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
    }

    function isCommentAtClassStart(token) {
      return isCommentAtParentStart(token, "ClassBody");
    }

    function isCommentAtClassEnd(token) {
      return isCommentAtParentEnd(token, "ClassBody");
    }

    function isCommentAtObjectStart(token) {
      return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
    }

    function isCommentAtObjectEnd(token) {
      return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
    }

    function isCommentAtArrayStart(token) {
      return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
    }

    function isCommentAtArrayEnd(token) {
      return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
    }

    function checkForEmptyLine(token, opts) {
      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
        return;
      }

      if (ignorePattern && customIgnoreRegExp.test(token.value)) {
        return;
      }

      let after = opts.after,
          before = opts.before;
      const prevLineNum = token.loc.start.line - 1,
            nextLineNum = token.loc.end.line + 1,
            commentIsNotAlone = codeAroundComment(token);
      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),
            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),
            classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),
            classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),
            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),
            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),
            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),
            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);

      if (prevLineNum < 1) {
        before = false;
      }

      if (nextLineNum >= numLines) {
        after = false;
      }

      if (commentIsNotAlone) {
        return;
      }

      const previousTokenOrComment = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      const nextTokenOrComment = sourceCode.getTokenAfter(token, {
        includeComments: true
      });

      if (!(blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed) && before && !commentAndEmptyLines.includes(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
        const lineStart = token.range[0] - token.loc.start.column;
        const range = [lineStart, lineStart];
        context.report({
          node: token,
          messageId: "before",

          fix(fixer) {
            return fixer.insertTextBeforeRange(range, "\n");
          }

        });
      }

      if (!(blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed) && after && !commentAndEmptyLines.includes(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
        context.report({
          node: token,
          messageId: "after",

          fix(fixer) {
            return fixer.insertTextAfter(token, "\n");
          }

        });
      }
    }

    return {
      Program() {
        comments.forEach(token => {
          if (token.type === "Line") {
            if (options.beforeLineComment || options.afterLineComment) {
              checkForEmptyLine(token, {
                after: options.afterLineComment,
                before: options.beforeLineComment
              });
            }
          } else if (token.type === "Block") {
            if (options.beforeBlockComment || options.afterBlockComment) {
              checkForEmptyLine(token, {
                after: options.afterBlockComment,
                before: options.beforeBlockComment
              });
            }
          }
        });
      }

    };
  }

};
var linesAroundDirective = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newlines around directives",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-around-directive"
    },
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          before: {
            enum: ["always", "never"]
          },
          after: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: false,
        minProperties: 2
      }]
    }],
    fixable: "whitespace",
    messages: {
      expected: "Expected newline {{location}} \"{{value}}\" directive.",
      unexpected: "Unexpected newline {{location}} \"{{value}}\" directive."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const config = context.options[0] || "always";
    const expectLineBefore = typeof config === "string" ? config : config.before;
    const expectLineAfter = typeof config === "string" ? config : config.after;

    function hasNewlineBefore(node) {
      const tokenBefore = sourceCode.getTokenBefore(node, {
        includeComments: true
      });
      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
      return node.loc.start.line - tokenLineBefore >= 2;
    }

    function getLastTokenOnLine(node) {
      const lastToken = sourceCode.getLastToken(node);
      const secondToLastToken = sourceCode.getTokenBefore(lastToken);
      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
    }

    function hasNewlineAfter(node) {
      const lastToken = getLastTokenOnLine(node);
      const tokenAfter = sourceCode.getTokenAfter(lastToken, {
        includeComments: true
      });
      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
    }

    function reportError(node, location, expected) {
      context.report({
        node,
        messageId: expected ? "expected" : "unexpected",
        data: {
          value: node.expression.value,
          location
        },

        fix(fixer) {
          const lastToken = getLastTokenOnLine(node);

          if (expected) {
            return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
          }

          return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
        }

      });
    }

    function checkDirectives(node) {
      const directives = astUtils.getDirectivePrologue(node);

      if (!directives.length) {
        return;
      }

      const firstDirective = directives[0];
      const leadingComments = sourceCode.getCommentsBefore(firstDirective);

      if (leadingComments.length) {
        if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", true);
        }

        if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", false);
        }
      } else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
        reportError(firstDirective, "before", false);
      }

      const lastDirective = directives[directives.length - 1];
      const statements = node.type === "Program" ? node.body : node.body.body;

      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
        return;
      }

      if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
        reportError(lastDirective, "after", true);
      }

      if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
        reportError(lastDirective, "after", false);
      }
    }

    return {
      Program: checkDirectives,
      FunctionDeclaration: checkDirectives,
      FunctionExpression: checkDirectives,
      ArrowFunctionExpression: checkDirectives
    };
  }

};
var linesBetweenClassMembers = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line between class members",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-between-class-members"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptAfterSingleLine: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      never: "Unexpected blank line between class members.",
      always: "Expected blank line between class members."
    }
  },

  create(context) {
    const options = [];
    options[0] = context.options[0] || "always";
    options[1] = context.options[1] || {
      exceptAfterSingleLine: false
    };
    const sourceCode = context.getSourceCode();

    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {
      const after = sourceCode.getTokenAfter(prevLastToken, {
        includeComments: true
      });

      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {
        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);
      }

      return prevLastToken;
    }

    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {
      const before = sourceCode.getTokenBefore(nextFirstToken, {
        includeComments: true
      });

      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {
        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);
      }

      return nextFirstToken;
    }

    function hasTokenOrCommentBetween(before, after) {
      return sourceCode.getTokensBetween(before, after, {
        includeComments: true
      }).length !== 0;
    }

    return {
      ClassBody(node) {
        const body = node.body;

        for (let i = 0; i < body.length - 1; i++) {
          const curFirst = sourceCode.getFirstToken(body[i]);
          const curLast = sourceCode.getLastToken(body[i]);
          const nextFirst = sourceCode.getFirstToken(body[i + 1]);
          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
          const skip = !isMulti && options[1].exceptAfterSingleLine;
          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);
          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);
          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);

          if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
            context.report({
              node: body[i + 1],
              messageId: isPadded ? "never" : "always",

              fix(fixer) {
                if (hasTokenInPadding) {
                  return null;
                }

                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n") : fixer.insertTextAfter(curLineLastToken, "\n");
              }

            });
          }
        }
      }

    };
  }

};
var maxClassesPerFile = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of classes per file",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-classes-per-file"
    },
    schema: [{
      type: "integer",
      minimum: 1
    }],
    messages: {
      maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
    }
  },

  create(context) {
    const maxClasses = context.options[0] || 1;
    let classCount = 0;
    return {
      Program() {
        classCount = 0;
      },

      "Program:exit"(node) {
        if (classCount > maxClasses) {
          context.report({
            node,
            messageId: "maximumExceeded",
            data: {
              classCount,
              max: maxClasses
            }
          });
        }
      },

      "ClassDeclaration, ClassExpression"() {
        classCount++;
      }

    };
  }

};
var maxDepth = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that blocks can be nested",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-depth"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
    }
  },

  create(context) {
    const functionStack = [],
          option = context.options[0];
    let maxDepth = 4;

    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      maxDepth = option.maximum || option.max;
    }

    if (typeof option === "number") {
      maxDepth = option;
    }

    function startFunction() {
      functionStack.push(0);
    }

    function endFunction() {
      functionStack.pop();
    }

    function pushBlock(node) {
      const len = ++functionStack[functionStack.length - 1];

      if (len > maxDepth) {
        context.report({
          node,
          messageId: "tooDeeply",
          data: {
            depth: len,
            maxDepth
          }
        });
      }
    }

    function popBlock() {
      functionStack[functionStack.length - 1]--;
    }

    return {
      Program: startFunction,
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,

      IfStatement(node) {
        if (node.parent.type !== "IfStatement") {
          pushBlock(node);
        }
      },

      SwitchStatement: pushBlock,
      TryStatement: pushBlock,
      DoWhileStatement: pushBlock,
      WhileStatement: pushBlock,
      WithStatement: pushBlock,
      ForStatement: pushBlock,
      ForInStatement: pushBlock,
      ForOfStatement: pushBlock,
      "IfStatement:exit": popBlock,
      "SwitchStatement:exit": popBlock,
      "TryStatement:exit": popBlock,
      "DoWhileStatement:exit": popBlock,
      "WhileStatement:exit": popBlock,
      "WithStatement:exit": popBlock,
      "ForStatement:exit": popBlock,
      "ForInStatement:exit": popBlock,
      "ForOfStatement:exit": popBlock,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,
      "Program:exit": endFunction
    };
  }

};
const OPTIONS_SCHEMA$1 = {
  type: "object",
  properties: {
    code: {
      type: "integer",
      minimum: 0
    },
    comments: {
      type: "integer",
      minimum: 0
    },
    tabWidth: {
      type: "integer",
      minimum: 0
    },
    ignorePattern: {
      type: "string"
    },
    ignoreComments: {
      type: "boolean"
    },
    ignoreStrings: {
      type: "boolean"
    },
    ignoreUrls: {
      type: "boolean"
    },
    ignoreTemplateLiterals: {
      type: "boolean"
    },
    ignoreRegExpLiterals: {
      type: "boolean"
    },
    ignoreTrailingComments: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
const OPTIONS_OR_INTEGER_SCHEMA$1 = {
  anyOf: [OPTIONS_SCHEMA$1, {
    type: "integer",
    minimum: 0
  }]
};
var maxLen = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum line length",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-len"
    },
    schema: [OPTIONS_OR_INTEGER_SCHEMA$1, OPTIONS_OR_INTEGER_SCHEMA$1, OPTIONS_SCHEMA$1],
    messages: {
      max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
      maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function computeLineLength(line, tabWidth) {
      let extraCharacterCount = 0;
      line.replace(/\t/gu, (match, offset) => {
        const totalOffset = offset + extraCharacterCount,
              previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0;
        extraCharacterCount += tabWidth - previousTabStopOffset - 1;
      });
      return Array.from(line).length + extraCharacterCount;
    }

    const options = Object.assign({}, context.options[context.options.length - 1]);

    if (typeof context.options[0] === "number") {
      options.code = context.options[0];
    }

    if (typeof context.options[1] === "number") {
      options.tabWidth = context.options[1];
    }

    const maxLength = typeof options.code === "number" ? options.code : 80,
          tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4,
          ignoreComments = !!options.ignoreComments,
          ignoreStrings = !!options.ignoreStrings,
          ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,
          ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,
          ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,
          ignoreUrls = !!options.ignoreUrls,
          maxCommentLength = options.comments;
    let ignorePattern = options.ignorePattern || null;

    if (ignorePattern) {
      ignorePattern = new RegExp(ignorePattern, "u");
    }

    function isTrailingComment(line, lineNumber, comment) {
      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
    }

    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start,
            end = comment.loc.end,
            isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
    }

    function isJSXEmptyExpressionInSingleLineContainer(node) {
      if (!node || !node.parent || node.type !== "JSXEmptyExpression" || node.parent.type !== "JSXExpressionContainer") {
        return false;
      }

      const parent = node.parent;
      return parent.loc.start.line === parent.loc.end.line;
    }

    function stripTrailingComment(line, comment) {
      return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
    }

    function ensureArrayAndPush(object, key, value) {
      if (!Array.isArray(object[key])) {
        object[key] = [];
      }

      object[key].push(value);
    }

    function getAllStrings() {
      return sourceCode.ast.tokens.filter(token => token.type === "String" || token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute");
    }

    function getAllTemplateLiterals() {
      return sourceCode.ast.tokens.filter(token => token.type === "Template");
    }

    function getAllRegExpLiterals() {
      return sourceCode.ast.tokens.filter(token => token.type === "RegularExpression");
    }

    function groupByLineNumber(acc, node) {
      for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {
        ensureArrayAndPush(acc, i, node);
      }

      return acc;
    }

    function getAllComments() {
      const comments = [];
      sourceCode.getAllComments().forEach(commentNode => {
        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);

        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
          if (comments[comments.length - 1] !== containingNode.parent) {
            comments.push(containingNode.parent);
          }
        } else {
          comments.push(commentNode);
        }
      });
      return comments;
    }

    return {
      Program: function (node) {
        const lines = sourceCode.lines,
              comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
        let commentsIndex = 0;
        const strings = getAllStrings();
        const stringsByLine = strings.reduce(groupByLineNumber, {});
        const templateLiterals = getAllTemplateLiterals();
        const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});
        const regExpLiterals = getAllRegExpLiterals();
        const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});
        lines.forEach((line, i) => {
          const lineNumber = i + 1;
          let lineIsComment = false;
          let textToMeasure;

          if (commentsIndex < comments.length) {
            let comment = null;

            do {
              comment = comments[++commentsIndex];
            } while (comment && comment.loc.start.line <= lineNumber);

            comment = comments[--commentsIndex];

            if (isFullLineComment(line, lineNumber, comment)) {
              lineIsComment = true;
              textToMeasure = line;
            } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
              textToMeasure = stripTrailingComment(line, comment);
              let lastIndex = commentsIndex;

              while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {
                textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
              }
            } else {
              textToMeasure = line;
            }
          } else {
            textToMeasure = line;
          }

          if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && /[^:/?#]:\/\/[^?#]/u.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
            return;
          }

          const lineLength = computeLineLength(textToMeasure, tabWidth);
          const commentLengthApplies = lineIsComment && maxCommentLength;

          if (lineIsComment && ignoreComments) {
            return;
          }

          const loc = {
            start: {
              line: lineNumber,
              column: 0
            },
            end: {
              line: lineNumber,
              column: textToMeasure.length
            }
          };

          if (commentLengthApplies) {
            if (lineLength > maxCommentLength) {
              context.report({
                node,
                loc,
                messageId: "maxComment",
                data: {
                  lineLength,
                  maxCommentLength
                }
              });
            }
          } else if (lineLength > maxLength) {
            context.report({
              node,
              loc,
              messageId: "max",
              data: {
                lineLength,
                maxLength
              }
            });
          }
        });
      }
    };
  }

};
const OPTIONS_SCHEMA = {
  type: "object",
  properties: {
    max: {
      type: "integer",
      minimum: 0
    },
    skipComments: {
      type: "boolean"
    },
    skipBlankLines: {
      type: "boolean"
    },
    IIFEs: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
const OPTIONS_OR_INTEGER_SCHEMA = {
  oneOf: [OPTIONS_SCHEMA, {
    type: "integer",
    minimum: 1
  }]
};

function getCommentLineNumbers(comments) {
  const map = new Map();
  comments.forEach(comment => {
    for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
      map.set(i, comment);
    }
  });
  return map;
}

var maxLinesPerFunction = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of lines of code in a function",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-lines-per-function"
    },
    schema: [OPTIONS_OR_INTEGER_SCHEMA],
    messages: {
      exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const lines = sourceCode.lines;
    const option = context.options[0];
    let maxLines = 50;
    let skipComments = false;
    let skipBlankLines = false;
    let IIFEs = false;

    if (typeof option === "object") {
      maxLines = typeof option.max === "number" ? option.max : 50;
      skipComments = !!option.skipComments;
      skipBlankLines = !!option.skipBlankLines;
      IIFEs = !!option.IIFEs;
    } else if (typeof option === "number") {
      maxLines = option;
    }

    const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());

    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start,
            end = comment.loc.end,
            isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),
            isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
    }

    function isIIFE(node) {
      return (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
    }

    function isEmbedded(node) {
      if (!node.parent) {
        return false;
      }

      if (node !== node.parent.value) {
        return false;
      }

      if (node.parent.type === "MethodDefinition") {
        return true;
      }

      if (node.parent.type === "Property") {
        return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
      }

      return false;
    }

    function processFunction(funcNode) {
      const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;

      if (!IIFEs && isIIFE(node)) {
        return;
      }

      let lineCount = 0;

      for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {
        const line = lines[i];

        if (skipComments) {
          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
            continue;
          }
        }

        if (skipBlankLines) {
          if (line.match(/^\s*$/u)) {
            continue;
          }
        }

        lineCount++;
      }

      if (lineCount > maxLines) {
        const name = lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(funcNode));
        context.report({
          node,
          messageId: "exceed",
          data: {
            name,
            lineCount,
            maxLines
          }
        });
      }
    }

    return {
      FunctionDeclaration: processFunction,
      FunctionExpression: processFunction,
      ArrowFunctionExpression: processFunction
    };
  }

};
var maxLines = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of lines per file",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-lines"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          max: {
            type: "integer",
            minimum: 0
          },
          skipComments: {
            type: "boolean"
          },
          skipBlankLines: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
    }
  },

  create(context) {
    const option = context.options[0];
    let max = 300;

    if (typeof option === "object" && Object.prototype.hasOwnProperty.call(option, "max")) {
      max = option.max;
    } else if (typeof option === "number") {
      max = option;
    }

    const skipComments = option && option.skipComments;
    const skipBlankLines = option && option.skipBlankLines;
    const sourceCode = context.getSourceCode();

    function isCommentNodeType(token) {
      return token && (token.type === "Block" || token.type === "Line");
    }

    function getLinesWithoutCode(comment) {
      let start = comment.loc.start.line;
      let end = comment.loc.end.line;
      let token = comment;

      do {
        token = sourceCode.getTokenBefore(token, {
          includeComments: true
        });
      } while (isCommentNodeType(token));

      if (token && astUtils.isTokenOnSameLine(token, comment)) {
        start += 1;
      }

      token = comment;

      do {
        token = sourceCode.getTokenAfter(token, {
          includeComments: true
        });
      } while (isCommentNodeType(token));

      if (token && astUtils.isTokenOnSameLine(comment, token)) {
        end -= 1;
      }

      if (start <= end) {
        return lodash__default['default'].range(start, end + 1);
      }

      return [];
    }

    return {
      "Program:exit"() {
        let lines = sourceCode.lines.map((text, i) => ({
          lineNumber: i + 1,
          text
        }));

        if (lines.length > 1 && lodash__default['default'].last(lines).text === "") {
          lines.pop();
        }

        if (skipBlankLines) {
          lines = lines.filter(l => l.text.trim() !== "");
        }

        if (skipComments) {
          const comments = sourceCode.getAllComments();
          const commentLines = lodash__default['default'].flatten(comments.map(comment => getLinesWithoutCode(comment)));
          lines = lines.filter(l => !commentLines.includes(l.lineNumber));
        }

        if (lines.length > max) {
          const loc = {
            start: {
              line: lines[max].lineNumber,
              column: 0
            },
            end: {
              line: sourceCode.lines.length,
              column: lodash__default['default'].last(sourceCode.lines).length
            }
          };
          context.report({
            loc,
            messageId: "exceed",
            data: {
              max,
              actual: lines.length
            }
          });
        }
      }

    };
  }

};
var maxNestedCallbacks = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that callbacks can be nested",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-nested-callbacks"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
    }
  },

  create(context) {
    const option = context.options[0];
    let THRESHOLD = 10;

    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      THRESHOLD = option.maximum || option.max;
    } else if (typeof option === "number") {
      THRESHOLD = option;
    }

    const callbackStack = [];

    function checkFunction(node) {
      const parent = node.parent;

      if (parent.type === "CallExpression") {
        callbackStack.push(node);
      }

      if (callbackStack.length > THRESHOLD) {
        const opts = {
          num: callbackStack.length,
          max: THRESHOLD
        };
        context.report({
          node,
          messageId: "exceed",
          data: opts
        });
      }
    }

    function popStack() {
      callbackStack.pop();
    }

    return {
      ArrowFunctionExpression: checkFunction,
      "ArrowFunctionExpression:exit": popStack,
      FunctionExpression: checkFunction,
      "FunctionExpression:exit": popStack
    };
  }

};
var maxParams = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of parameters in function definitions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-params"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0];
    let numParams = 3;

    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      numParams = option.maximum || option.max;
    }

    if (typeof option === "number") {
      numParams = option;
    }

    function checkFunction(node) {
      if (node.params.length > numParams) {
        context.report({
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          node,
          messageId: "exceed",
          data: {
            name: lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node)),
            count: node.params.length,
            max: numParams
          }
        });
      }
    }

    return {
      FunctionDeclaration: checkFunction,
      ArrowFunctionExpression: checkFunction,
      FunctionExpression: checkFunction
    };
  }

};
var maxStatementsPerLine = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum number of statements allowed per line",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-statements-per-line"
    },
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 1,
          default: 1
        }
      },
      additionalProperties: false
    }],
    messages: {
      exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode(),
          options = context.options[0] || {},
          maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1;
    let lastStatementLine = 0,
        numberOfStatementsOnThisLine = 0,
        firstExtraStatement;

    function reportFirstExtraStatementAndClear() {
      if (firstExtraStatement) {
        context.report({
          node: firstExtraStatement,
          messageId: "exceed",
          data: {
            numberOfStatementsOnThisLine,
            maxStatementsPerLine,
            statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
          }
        });
      }

      firstExtraStatement = null;
    }

    function getActualLastToken(node) {
      return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
    }

    function enterStatement(node) {
      const line = node.loc.start.line;

      if (/^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u.test(node.parent.type) && node.parent.alternate !== node) {
        return;
      }

      if (line === lastStatementLine) {
        numberOfStatementsOnThisLine += 1;
      } else {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }

      if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
        firstExtraStatement = firstExtraStatement || node;
      }
    }

    function leaveStatement(node) {
      const line = getActualLastToken(node).loc.end.line;

      if (line !== lastStatementLine) {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }
    }

    return {
      BreakStatement: enterStatement,
      ClassDeclaration: enterStatement,
      ContinueStatement: enterStatement,
      DebuggerStatement: enterStatement,
      DoWhileStatement: enterStatement,
      ExpressionStatement: enterStatement,
      ForInStatement: enterStatement,
      ForOfStatement: enterStatement,
      ForStatement: enterStatement,
      FunctionDeclaration: enterStatement,
      IfStatement: enterStatement,
      ImportDeclaration: enterStatement,
      LabeledStatement: enterStatement,
      ReturnStatement: enterStatement,
      SwitchStatement: enterStatement,
      ThrowStatement: enterStatement,
      TryStatement: enterStatement,
      VariableDeclaration: enterStatement,
      WhileStatement: enterStatement,
      WithStatement: enterStatement,
      ExportNamedDeclaration: enterStatement,
      ExportDefaultDeclaration: enterStatement,
      ExportAllDeclaration: enterStatement,
      "BreakStatement:exit": leaveStatement,
      "ClassDeclaration:exit": leaveStatement,
      "ContinueStatement:exit": leaveStatement,
      "DebuggerStatement:exit": leaveStatement,
      "DoWhileStatement:exit": leaveStatement,
      "ExpressionStatement:exit": leaveStatement,
      "ForInStatement:exit": leaveStatement,
      "ForOfStatement:exit": leaveStatement,
      "ForStatement:exit": leaveStatement,
      "FunctionDeclaration:exit": leaveStatement,
      "IfStatement:exit": leaveStatement,
      "ImportDeclaration:exit": leaveStatement,
      "LabeledStatement:exit": leaveStatement,
      "ReturnStatement:exit": leaveStatement,
      "SwitchStatement:exit": leaveStatement,
      "ThrowStatement:exit": leaveStatement,
      "TryStatement:exit": leaveStatement,
      "VariableDeclaration:exit": leaveStatement,
      "WhileStatement:exit": leaveStatement,
      "WithStatement:exit": leaveStatement,
      "ExportNamedDeclaration:exit": leaveStatement,
      "ExportDefaultDeclaration:exit": leaveStatement,
      "ExportAllDeclaration:exit": leaveStatement,
      "Program:exit": reportFirstExtraStatementAndClear
    };
  }

};
var maxStatements = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of statements allowed in function blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-statements"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }, {
      type: "object",
      properties: {
        ignoreTopLevelFunctions: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
    }
  },

  create(context) {
    const functionStack = [],
          option = context.options[0],
          ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
          topLevelFunctions = [];
    let maxStatements = 10;

    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      maxStatements = option.maximum || option.max;
    } else if (typeof option === "number") {
      maxStatements = option;
    }

    function reportIfTooManyStatements(node, count, max) {
      if (count > max) {
        const name = lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node));
        context.report({
          node,
          messageId: "exceed",
          data: {
            name,
            count,
            max
          }
        });
      }
    }

    function startFunction() {
      functionStack.push(0);
    }

    function endFunction(node) {
      const count = functionStack.pop();

      if (ignoreTopLevelFunctions && functionStack.length === 0) {
        topLevelFunctions.push({
          node,
          count
        });
      } else {
        reportIfTooManyStatements(node, count, maxStatements);
      }
    }

    return {
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      BlockStatement: function (node) {
        functionStack[functionStack.length - 1] += node.body.length;
      },
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,

      "Program:exit"() {
        if (topLevelFunctions.length === 1) {
          return;
        }

        topLevelFunctions.forEach(element => {
          const count = element.count;
          const node = element.node;
          reportIfTooManyStatements(node, count, maxStatements);
        });
      }

    };
  }

};
var multilineCommentStyle = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a particular style for multiline comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/multiline-comment-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["starred-block", "separate-lines", "bare-block"]
    }],
    messages: {
      expectedBlock: "Expected a block comment instead of consecutive line comments.",
      expectedBareBlock: "Expected a block comment without padding stars.",
      startNewline: "Expected a linebreak after '/*'.",
      endNewline: "Expected a linebreak before '*/'.",
      missingStar: "Expected a '*' at the start of this line.",
      alignment: "Expected this line to be aligned with the start of the comment.",
      expectedLines: "Expected multiple line comments instead of a block comment."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "starred-block";

    function isStarredCommentLine(line) {
      return /^\s*\*/u.test(line);
    }

    function isStarredBlockComment([firstComment]) {
      if (firstComment.type !== "Block") {
        return false;
      }

      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
      return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\s*$/u : /^\s*\*/u).test(line));
    }

    function isJSDocComment([firstComment]) {
      if (firstComment.type !== "Block") {
        return false;
      }

      const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
      return /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\s* /u.test(line)) && /^\s*$/u.test(lines[lines.length - 1]);
    }

    function processSeparateLineComments(commentGroup) {
      const allLinesHaveLeadingSpace = commentGroup.map(({
        value
      }) => value).filter(line => line.trim().length).every(line => line.startsWith(" "));
      return commentGroup.map(({
        value
      }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, "") : value);
    }

    function processStarredBlockComment(comment) {
      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map(line => line.replace(/^\s*$/u, ""));
      const allLinesHaveLeadingSpace = lines.map(line => line.replace(/\s*\*/u, "")).filter(line => line.trim().length).every(line => line.startsWith(" "));
      return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\s*\* ?/u : /\s*\*/u, ""));
    }

    function processBareBlockComment(comment) {
      const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\s*$/u, ""));
      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;
      let offset = "";

      for (const [i, line] of lines.entries()) {
        if (!line.trim().length || i === 0) {
          continue;
        }

        const [, lineOffset] = line.match(/^(\s*\*?\s*)/u);

        if (lineOffset.length < leadingWhitespace.length) {
          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);

          if (newOffset.length > offset.length) {
            offset = newOffset;
          }
        }
      }

      return lines.map(line => {
        const match = line.match(/^(\s*\*?\s*)(.*)/u);
        const [, lineOffset, lineContents] = match;

        if (lineOffset.length > leadingWhitespace.length) {
          return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;
        }

        if (lineOffset.length < leadingWhitespace.length) {
          return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;
        }

        return lineContents;
      });
    }

    function getCommentLines(commentGroup) {
      const [firstComment] = commentGroup;

      if (firstComment.type === "Line") {
        return processSeparateLineComments(commentGroup);
      }

      if (isStarredBlockComment(commentGroup)) {
        return processStarredBlockComment(firstComment);
      }

      return processBareBlockComment(firstComment);
    }

    function getInitialOffset(comment) {
      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);
    }

    function convertToStarredBlock(firstComment, commentLinesList) {
      const initialOffset = getInitialOffset(firstComment);
      return `/*\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join("\n")}\n${initialOffset} */`;
    }

    function convertToSeparateLines(firstComment, commentLinesList) {
      return commentLinesList.map(line => `// ${line}`).join(`\n${getInitialOffset(firstComment)}`);
    }

    function convertToBlock(firstComment, commentLinesList) {
      return `/* ${commentLinesList.join(`\n${getInitialOffset(firstComment)}   `)} */`;
    }

    const commentGroupCheckers = {
      "starred-block"(commentGroup) {
        const [firstComment] = commentGroup;
        const commentLines = getCommentLines(commentGroup);

        if (commentLines.some(value => value.includes("*/"))) {
          return;
        }

        if (commentGroup.length > 1) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: commentGroup[commentGroup.length - 1].loc.end
            },
            messageId: "expectedBlock",

            fix(fixer) {
              const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];
              return commentLines.some(value => value.startsWith("/")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));
            }

          });
        } else {
          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
          const expectedLeadingWhitespace = getInitialOffset(firstComment);
          const expectedLinePrefix = `${expectedLeadingWhitespace} *`;

          if (!/^\*?\s*$/u.test(lines[0])) {
            const start = firstComment.value.startsWith("*") ? firstComment.range[0] + 1 : firstComment.range[0];
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: {
                  line: firstComment.loc.start.line,
                  column: firstComment.loc.start.column + 2
                }
              },
              messageId: "startNewline",
              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\n${expectedLinePrefix}`)
            });
          }

          if (!/^\s*$/u.test(lines[lines.length - 1])) {
            context.report({
              loc: {
                start: {
                  line: firstComment.loc.end.line,
                  column: firstComment.loc.end.column - 2
                },
                end: firstComment.loc.end
              },
              messageId: "endNewline",
              fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\n${expectedLinePrefix}/`)
            });
          }

          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
            const lineText = sourceCode.lines[lineNumber - 1];
            const errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";

            if (!lineText.startsWith(expectedLinePrefix)) {
              context.report({
                loc: {
                  start: {
                    line: lineNumber,
                    column: 0
                  },
                  end: {
                    line: lineNumber,
                    column: lineText.length
                  }
                },
                messageId: errorType,

                fix(fixer) {
                  const lineStartIndex = sourceCode.getIndexFromLoc({
                    line: lineNumber,
                    column: 0
                  });

                  if (errorType === "alignment") {
                    const [, commentTextPrefix = ""] = lineText.match(/^(\s*\*)/u) || [];
                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);
                  }

                  const [, commentTextPrefix = ""] = lineText.match(/^(\s*)/u) || [];
                  const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                  let offset;

                  for (const [idx, line] of lines.entries()) {
                    if (!/\S+/u.test(line)) {
                      continue;
                    }

                    const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];
                    const [, prefix = "", initialOffset = ""] = lineTextToAlignWith.match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                    offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;

                    if (/^\s*\//u.test(lineText) && offset.length === 0) {
                      offset += " ";
                    }

                    break;
                  }

                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);
                }

              });
            }
          }
        }
      },

      "separate-lines"(commentGroup) {
        const [firstComment] = commentGroup;

        if (firstComment.type !== "Block" || isJSDocComment(commentGroup)) {
          return;
        }

        const commentLines = getCommentLines(commentGroup);
        const tokenAfter = sourceCode.getTokenAfter(firstComment, {
          includeComments: true
        });

        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {
          return;
        }

        context.report({
          loc: {
            start: firstComment.loc.start,
            end: {
              line: firstComment.loc.start.line,
              column: firstComment.loc.start.column + 2
            }
          },
          messageId: "expectedLines",

          fix(fixer) {
            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));
          }

        });
      },

      "bare-block"(commentGroup) {
        if (isJSDocComment(commentGroup)) {
          return;
        }

        const [firstComment] = commentGroup;
        const commentLines = getCommentLines(commentGroup);

        if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some(value => value.includes("*/"))) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: commentGroup[commentGroup.length - 1].loc.end
            },
            messageId: "expectedBlock",

            fix(fixer) {
              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));
            }

          });
        }

        if (isStarredBlockComment(commentGroup)) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: {
                line: firstComment.loc.start.line,
                column: firstComment.loc.start.column + 2
              }
            },
            messageId: "expectedBareBlock",

            fix(fixer) {
              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));
            }

          });
        }
      }

    };
    return {
      Program() {
        return sourceCode.getAllComments().filter(comment => comment.type !== "Shebang").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {
          const tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
        }).reduce((commentGroups, comment, index, commentList) => {
          const tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });

          if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
            commentGroups[commentGroups.length - 1].push(comment);
          } else {
            commentGroups.push([comment]);
          }

          return commentGroups;
        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);
      }

    };
  }

};
var multilineTernary = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce newlines between operands of ternary expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/multiline-ternary"
    },
    schema: [{
      enum: ["always", "always-multiline", "never"]
    }],
    messages: {
      expectedTestCons: "Expected newline between test and consequent of ternary expression.",
      expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
      unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
      unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
    },
    fixable: "whitespace"
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0];
    return {
      ConditionalExpression(node) {
        const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);
        const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);
        const firstTokenOfTest = sourceCode.getFirstToken(node);
        const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);
        const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);
        const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);
        const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);
        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);
        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);
        const hasComments = !!sourceCode.getCommentsInside(node).length;

        if (!(option !== "never")) {
          if (!areTestAndConsequentOnSameLine) {
            context.report({
              node: node.test,
              loc: {
                start: firstTokenOfTest.loc.start,
                end: lastTokenOfTest.loc.end
              },
              messageId: "unexpectedTestCons",
              fix: fixer => {
                if (hasComments) {
                  return null;
                }

                const fixers = [];
                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);
                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);

                if (!areTestAndQuestionOnSameLine) {
                  fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));
                }

                if (!areQuestionAndConsOnSameLine) {
                  fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));
                }

                return fixers;
              }
            });
          }

          if (!areConsequentAndAlternateOnSameLine) {
            context.report({
              node: node.consequent,
              loc: {
                start: firstTokenOfConsequent.loc.start,
                end: lastTokenOfConsequent.loc.end
              },
              messageId: "unexpectedConsAlt",
              fix: fixer => {
                if (hasComments) {
                  return null;
                }

                const fixers = [];
                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);
                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);

                if (!areConsAndColonOnSameLine) {
                  fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));
                }

                if (!areColonAndAltOnSameLine) {
                  fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));
                }

                return fixers;
              }
            });
          }
        } else {
          if (option === "always-multiline" && node.loc.start.line === node.loc.end.line) {
            return;
          }

          if (areTestAndConsequentOnSameLine) {
            context.report({
              node: node.test,
              loc: {
                start: firstTokenOfTest.loc.start,
                end: lastTokenOfTest.loc.end
              },
              messageId: "expectedTestCons",
              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], "\n")
            });
          }

          if (areConsequentAndAlternateOnSameLine) {
            context.report({
              node: node.consequent,
              loc: {
                start: firstTokenOfConsequent.loc.start,
                end: lastTokenOfConsequent.loc.end
              },
              messageId: "expectedConsAlt",
              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], "\n")
            });
          }
        }
      }

    };
  }

};
const CAPS_ALLOWED = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol", "BigInt"];

function checkArray(obj, key, fallback) {
  if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
    throw new TypeError(`${key}, if provided, must be an Array`);
  }

  return obj[key] || fallback;
}

function invert(map, key) {
  map[key] = true;
  return map;
}

function calculateCapIsNewExceptions(config) {
  let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

  if (capIsNewExceptions !== CAPS_ALLOWED) {
    capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
  }

  return capIsNewExceptions.reduce(invert, {});
}

var newCap = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require constructor names to begin with a capital letter",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/new-cap"
    },
    schema: [{
      type: "object",
      properties: {
        newIsCap: {
          type: "boolean",
          default: true
        },
        capIsNew: {
          type: "boolean",
          default: true
        },
        newIsCapExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        newIsCapExceptionPattern: {
          type: "string"
        },
        capIsNewExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        capIsNewExceptionPattern: {
          type: "string"
        },
        properties: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
      lower: "A constructor name should not start with a lowercase letter."
    }
  },

  create(context) {
    const config = Object.assign({}, context.options[0]);
    config.newIsCap = config.newIsCap !== false;
    config.capIsNew = config.capIsNew !== false;
    const skipProperties = config.properties === false;
    const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
    const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, "u") : null;
    const capIsNewExceptions = calculateCapIsNewExceptions(config);
    const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, "u") : null;
    const listeners = {};
    const sourceCode = context.getSourceCode();

    function extractNameFromExpression(node) {
      return node.callee.type === "Identifier" ? node.callee.name : astUtils.getStaticPropertyName(node.callee) || "";
    }

    function getCap(str) {
      const firstChar = str.charAt(0);
      const firstCharLower = firstChar.toLowerCase();
      const firstCharUpper = firstChar.toUpperCase();

      if (firstCharLower === firstCharUpper) {
        return "non-alpha";
      }

      if (firstChar === firstCharLower) {
        return "lower";
      }

      return "upper";
    }

    function isCapAllowed(allowedMap, node, calleeName, pattern) {
      const sourceText = sourceCode.getText(node.callee);

      if (allowedMap[calleeName] || allowedMap[sourceText]) {
        return true;
      }

      if (pattern && pattern.test(sourceText)) {
        return true;
      }

      const callee = astUtils.skipChainExpression(node.callee);

      if (calleeName === "UTC" && callee.type === "MemberExpression") {
        return callee.object.type === "Identifier" && callee.object.name === "Date";
      }

      return skipProperties && callee.type === "MemberExpression";
    }

    function report(node, messageId) {
      let callee = astUtils.skipChainExpression(node.callee);

      if (callee.type === "MemberExpression") {
        callee = callee.property;
      }

      context.report({
        node,
        loc: callee.loc,
        messageId
      });
    }

    if (config.newIsCap) {
      listeners.NewExpression = function (node) {
        const constructorName = extractNameFromExpression(node);

        if (constructorName) {
          const capitalization = getCap(constructorName);
          const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);

          if (!isAllowed) {
            report(node, "lower");
          }
        }
      };
    }

    if (config.capIsNew) {
      listeners.CallExpression = function (node) {
        const calleeName = extractNameFromExpression(node);

        if (calleeName) {
          const capitalization = getCap(calleeName);
          const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);

          if (!isAllowed) {
            report(node, "upper");
          }
        }
      };
    }

    return listeners;
  }

};
var newParens = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce or disallow parentheses when invoking a constructor with no arguments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/new-parens"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "never"]
        }],
        minItems: 0,
        maxItems: 1
      }]
    },
    messages: {
      missing: "Missing '()' invoking a constructor.",
      unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
    }
  },

  create(context) {
    const options = context.options;
    const always = options[0] !== "never";
    const sourceCode = context.getSourceCode();
    return {
      NewExpression(node) {
        if (node.arguments.length !== 0) {
          return;
        }

        const lastToken = sourceCode.getLastToken(node);
        const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
        const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken)) && node.callee.range[1] < node.range[1];

        if (always) {
          if (!hasParens) {
            context.report({
              node,
              messageId: "missing",
              fix: fixer => fixer.insertTextAfter(node, "()")
            });
          }
        } else {
          if (hasParens) {
            context.report({
              node,
              messageId: "unnecessary",
              fix: fixer => [fixer.remove(sourceCode.getTokenBefore(lastToken)), fixer.remove(lastToken), fixer.insertTextBefore(node, "("), fixer.insertTextAfter(node, ")")]
            });
          }
        }
      }

    };
  }

};
var newlineAfterVar = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line after variable declarations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-after-var"
    },
    schema: [{
      enum: ["never", "always"]
    }],
    fixable: "whitespace",
    messages: {
      expected: "Expected blank line after variable declarations.",
      unexpected: "Unexpected blank line after variable declarations."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const mode = context.options[0] === "never" ? "never" : "always";
    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {
      result[token.loc.start.line] = token.loc.end.line;
      return result;
    }, {});

    function getLastToken(node) {
      const lastToken = sourceCode.getLastToken(node);

      if (lastToken.type === "Punctuator" && lastToken.value === ";") {
        const prevToken = sourceCode.getTokenBefore(lastToken);

        if (prevToken.loc.end.line !== lastToken.loc.start.line) {
          return prevToken;
        }
      }

      return lastToken;
    }

    function isVar(keyword) {
      return keyword === "var" || keyword === "let" || keyword === "const";
    }

    function isForTypeSpecifier(keyword) {
      return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    function isExportSpecifier(nodeType) {
      return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
    }

    function isLastNode(node) {
      const token = sourceCode.getTokenAfter(node);
      return !token || token.type === "Punctuator" && token.value === "}";
    }

    function getLastCommentLineOfBlock(commentStartLine) {
      const currentCommentEnd = commentEndLine[commentStartLine];
      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
    }

    function hasBlankLineAfterComment(token, commentStartLine) {
      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
    }

    return {
      VariableDeclaration: function (node) {
        const lastToken = getLastToken(node),
              nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
              nextLineNum = lastToken.loc.end.line + 1;

        if (!nextToken) {
          return;
        }

        if (isForTypeSpecifier(node.parent.type)) {
          return;
        }

        if (isExportSpecifier(node.parent.type)) {
          return;
        }

        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
          return;
        }

        if (isLastNode(node)) {
          return;
        }

        const noNextLineToken = nextToken.loc.start.line > nextLineNum;
        const hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";

        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              identifier: node.name
            },

            fix(fixer) {
              const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);
              return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}\n${linesBetween[linesBetween.length - 1]}`);
            }

          });
        }

        if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
          context.report({
            node,
            messageId: "expected",
            data: {
              identifier: node.name
            },

            fix(fixer) {
              if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
                return fixer.insertTextBefore(nextToken, "\n\n");
              }

              return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
            }

          });
        }
      }
    };
  }

};
var newlineBeforeReturn = {
  meta: {
    type: "layout",
    docs: {
      description: "require an empty line before `return` statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-before-return"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      expected: "Expected newline before return statement."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function isPrecededByTokens(node, testTokens) {
      const tokenBefore = sourceCode.getTokenBefore(node);
      return testTokens.some(token => tokenBefore.value === token);
    }

    function isFirstNode(node) {
      const parentType = node.parent.type;

      if (node.parent.body) {
        return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
      }

      if (parentType === "IfStatement") {
        return isPrecededByTokens(node, ["else", ")"]);
      }

      if (parentType === "DoWhileStatement") {
        return isPrecededByTokens(node, ["do"]);
      }

      if (parentType === "SwitchCase") {
        return isPrecededByTokens(node, [":"]);
      }

      return isPrecededByTokens(node, [")"]);
    }

    function calcCommentLines(node, lineNumTokenBefore) {
      const comments = sourceCode.getCommentsBefore(node);
      let numLinesComments = 0;

      if (!comments.length) {
        return numLinesComments;
      }

      comments.forEach(comment => {
        numLinesComments++;

        if (comment.type === "Block") {
          numLinesComments += comment.loc.end.line - comment.loc.start.line;
        }

        if (comment.loc.start.line === lineNumTokenBefore) {
          numLinesComments--;
        }

        if (comment.loc.end.line === node.loc.start.line) {
          numLinesComments--;
        }
      });
      return numLinesComments;
    }

    function getLineNumberOfTokenBefore(node) {
      const tokenBefore = sourceCode.getTokenBefore(node);
      let lineNumTokenBefore;

      if (tokenBefore) {
        lineNumTokenBefore = tokenBefore.loc.end.line;
      } else {
        lineNumTokenBefore = 0;
      }

      return lineNumTokenBefore;
    }

    function hasNewlineBefore(node) {
      const lineNumNode = node.loc.start.line;
      const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
      const commentLines = calcCommentLines(node, lineNumTokenBefore);
      return lineNumNode - lineNumTokenBefore - commentLines > 1;
    }

    function canFix(node) {
      const leadingComments = sourceCode.getCommentsBefore(node);
      const lastLeadingComment = leadingComments[leadingComments.length - 1];
      const tokenBefore = sourceCode.getTokenBefore(node);

      if (leadingComments.length === 0) {
        return true;
      }

      if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
        return true;
      }

      return false;
    }

    return {
      ReturnStatement(node) {
        if (!isFirstNode(node) && !hasNewlineBefore(node)) {
          context.report({
            node,
            messageId: "expected",

            fix(fixer) {
              if (canFix(node)) {
                const tokenBefore = sourceCode.getTokenBefore(node);
                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
                return fixer.insertTextBefore(node, newlines);
              }

              return null;
            }

          });
        }
      }

    };
  }

};
var newlinePerChainedCall = {
  meta: {
    type: "layout",
    docs: {
      description: "require a newline after each call in a method chain",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-per-chained-call"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        ignoreChainWithDepth: {
          type: "integer",
          minimum: 1,
          maximum: 10,
          default: 2
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected line break before `{{callee}}`."
    }
  },

  create(context) {
    const options = context.options[0] || {},
          ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
    const sourceCode = context.getSourceCode();

    function getPrefix(node) {
      if (node.computed) {
        if (node.optional) {
          return "?.[";
        }

        return "[";
      }

      if (node.optional) {
        return "?.";
      }

      return ".";
    }

    function getPropertyText(node) {
      const prefix = getPrefix(node);
      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
      const suffix = node.computed && lines.length === 1 ? "]" : "";
      return prefix + lines[0] + suffix;
    }

    return {
      "CallExpression:exit"(node) {
        const callee = astUtils.skipChainExpression(node.callee);

        if (callee.type !== "MemberExpression") {
          return;
        }

        let parent = astUtils.skipChainExpression(callee.object);
        let depth = 1;

        while (parent && parent.callee) {
          depth += 1;
          parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);
        }

        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
          const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);
          context.report({
            node: callee.property,
            loc: {
              start: firstTokenAfterObject.loc.start,
              end: callee.loc.end
            },
            messageId: "expected",
            data: {
              callee: getPropertyText(callee)
            },

            fix(fixer) {
              return fixer.insertTextBefore(firstTokenAfterObject, "\n");
            }

          });
        }
      }

    };
  }

};
const {
  getStaticPropertyName: getPropertyName$2,
  getVariableByName,
  skipChainExpression
} = astUtils;

function isProhibitedIdentifier(name) {
  return /^(alert|confirm|prompt)$/u.test(name);
}

function findReference(scope, node) {
  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);

  if (references.length === 1) {
    return references[0];
  }

  return null;
}

function isShadowed$1(scope, node) {
  const reference = findReference(scope, node);
  return reference && reference.resolved && reference.resolved.defs.length > 0;
}

function isGlobalThisReferenceOrGlobalWindow(scope, node) {
  if (scope.type === "global" && node.type === "ThisExpression") {
    return true;
  }

  if (node.type === "Identifier" && (node.name === "window" || node.name === "globalThis" && getVariableByName(scope, "globalThis"))) {
    return !isShadowed$1(scope, node);
  }

  return false;
}

var noAlert = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `alert`, `confirm`, and `prompt`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-alert"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected {{name}}."
    }
  },

  create(context) {
    return {
      CallExpression(node) {
        const callee = skipChainExpression(node.callee),
              currentScope = context.getScope();

        if (callee.type === "Identifier") {
          const name = callee.name;

          if (!isShadowed$1(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                name
              }
            });
          }
        } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
          const name = getPropertyName$2(callee);

          if (isProhibitedIdentifier(name)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                name
              }
            });
          }
        }
      }

    };
  }

};
var noArrayConstructor = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Array` constructors",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-array-constructor"
    },
    schema: [],
    messages: {
      preferLiteral: "The array literal notation [] is preferable."
    }
  },

  create(context) {
    function check(node) {
      if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
        context.report({
          node,
          messageId: "preferLiteral"
        });
      }
    }

    return {
      CallExpression: check,
      NewExpression: check
    };
  }

};
var noAsyncPromiseExecutor = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow using an async function as a Promise executor",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-async-promise-executor"
    },
    fixable: null,
    schema: [],
    messages: {
      async: "Promise executor functions should not be async."
    }
  },

  create(context) {
    return {
      "NewExpression[callee.name='Promise'][arguments.0.async=true]"(node) {
        context.report({
          node: context.getSourceCode().getFirstToken(node.arguments[0], token => token.value === "async"),
          messageId: "async"
        });
      }

    };
  }

};

function isBoundary(node) {
  const t = node.type;
  return t === "FunctionDeclaration" || t === "FunctionExpression" || t === "ArrowFunctionExpression" || t === "ForOfStatement" && node.await === true;
}

function isLooped(node, parent) {
  switch (parent.type) {
    case "ForStatement":
      return node === parent.test || node === parent.update || node === parent.body;

    case "ForOfStatement":
    case "ForInStatement":
      return node === parent.body;

    case "WhileStatement":
    case "DoWhileStatement":
      return node === parent.test || node === parent.body;

    default:
      return false;
  }
}

var noAwaitInLoop = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `await` inside of loops",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-await-in-loop"
    },
    schema: [],
    messages: {
      unexpectedAwait: "Unexpected `await` inside a loop."
    }
  },

  create(context) {
    function validate(awaitNode) {
      if (awaitNode.type === "ForOfStatement" && !awaitNode.await) {
        return;
      }

      let node = awaitNode;
      let parent = node.parent;

      while (parent && !isBoundary(parent)) {
        if (isLooped(node, parent)) {
          context.report({
            node: awaitNode,
            messageId: "unexpectedAwait"
          });
          return;
        }

        node = parent;
        parent = parent.parent;
      }
    }

    return {
      AwaitExpression: validate,
      ForOfStatement: validate
    };
  }

};
const BITWISE_OPERATORS$1 = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"];
var noBitwise = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow bitwise operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-bitwise"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: BITWISE_OPERATORS$1
          },
          uniqueItems: true
        },
        int32Hint: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected use of '{{operator}}'."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];
    const int32Hint = options.int32Hint === true;

    function report(node) {
      context.report({
        node,
        messageId: "unexpected",
        data: {
          operator: node.operator
        }
      });
    }

    function hasBitwiseOperator(node) {
      return BITWISE_OPERATORS$1.indexOf(node.operator) !== -1;
    }

    function allowedOperator(node) {
      return allowed.indexOf(node.operator) !== -1;
    }

    function isInt32Hint(node) {
      return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
    }

    function checkNodeForBitwiseOperator(node) {
      if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
        report(node);
      }
    }

    return {
      AssignmentExpression: checkNodeForBitwiseOperator,
      BinaryExpression: checkNodeForBitwiseOperator,
      UnaryExpression: checkNodeForBitwiseOperator
    };
  }

};
var noBufferConstructor = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "problem",
    docs: {
      description: "disallow use of the `Buffer()` constructor",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-buffer-constructor"
    },
    schema: [],
    messages: {
      deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
    }
  },

  create(context) {
    return {
      "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node) {
        context.report({
          node,
          messageId: "deprecated",
          data: {
            expr: node.type === "CallExpression" ? "Buffer()" : "new Buffer()"
          }
        });
      }

    };
  }

};
var noCaller = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `arguments.caller` or `arguments.callee`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-caller"
    },
    schema: [],
    messages: {
      unexpected: "Avoid arguments.{{prop}}."
    }
  },

  create(context) {
    return {
      MemberExpression(node) {
        const objectName = node.object.name,
              propertyName = node.property.name;

        if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              prop: propertyName
            }
          });
        }
      }

    };
  }

};
var noCaseDeclarations = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow lexical declarations in case clauses",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-case-declarations"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected lexical declaration in case block."
    }
  },

  create(context) {
    function isLexicalDeclaration(node) {
      switch (node.type) {
        case "FunctionDeclaration":
        case "ClassDeclaration":
          return true;

        case "VariableDeclaration":
          return node.kind !== "var";

        default:
          return false;
      }
    }

    return {
      SwitchCase(node) {
        for (let i = 0; i < node.consequent.length; i++) {
          const statement = node.consequent[i];

          if (isLexicalDeclaration(statement)) {
            context.report({
              node: statement,
              messageId: "unexpected"
            });
          }
        }
      }

    };
  }

};
var noCatchShadow = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-catch-shadow"
    },
    replacedBy: ["no-shadow"],
    deprecated: true,
    schema: [],
    messages: {
      mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
    }
  },

  create(context) {
    function paramIsShadowing(scope, name) {
      return astUtils.getVariableByName(scope, name) !== null;
    }

    return {
      "CatchClause[param!=null]"(node) {
        let scope = context.getScope();

        if (scope.block === node) {
          scope = scope.upper;
        }

        if (paramIsShadowing(scope, node.param.name)) {
          context.report({
            node,
            messageId: "mutable",
            data: {
              name: node.param.name
            }
          });
        }
      }

    };
  }

};
var noClassAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning class members",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-class-assign"
    },
    schema: [],
    messages: {
      class: "'{{name}}' is a class."
    }
  },

  create(context) {
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "class",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }

    function checkForClass(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
      ClassDeclaration: checkForClass,
      ClassExpression: checkForClass
    };
  }

};
var noCompareNegZero = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparing against -0",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-compare-neg-zero"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Do not use the '{{operator}}' operator to compare against -0."
    }
  },

  create(context) {
    function isNegZero(node) {
      return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
    }

    const OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
    return {
      BinaryExpression(node) {
        if (OPERATORS_TO_CHECK.has(node.operator)) {
          if (isNegZero(node.left) || isNegZero(node.right)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                operator: node.operator
              }
            });
          }
        }
      }

    };
  }

};
const TEST_CONDITION_PARENT_TYPES = new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]);
const NODE_DESCRIPTIONS = {
  DoWhileStatement: "a 'do...while' statement",
  ForStatement: "a 'for' statement",
  IfStatement: "an 'if' statement",
  WhileStatement: "a 'while' statement"
};
var noCondAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignment operators in conditional expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-cond-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }],
    messages: {
      unexpected: "Unexpected assignment within {{type}}.",
      missing: "Expected a conditional expression and instead saw an assignment."
    }
  },

  create(context) {
    const prohibitAssign = context.options[0] || "except-parens";
    const sourceCode = context.getSourceCode();

    function isConditionalTestExpression(node) {
      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;
    }

    function findConditionalAncestor(node) {
      let currentAncestor = node;

      do {
        if (isConditionalTestExpression(currentAncestor)) {
          return currentAncestor.parent;
        }
      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));

      return null;
    }

    function isParenthesisedTwice(node) {
      const previousToken = sourceCode.getTokenBefore(node, 1),
            nextToken = sourceCode.getTokenAfter(node, 1);
      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
    }

    function testForAssign(node) {
      if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
        context.report({
          node: node.test,
          messageId: "missing"
        });
      }
    }

    function testForConditionalAncestor(node) {
      const ancestor = findConditionalAncestor(node);

      if (ancestor) {
        context.report({
          node,
          messageId: "unexpected",
          data: {
            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
          }
        });
      }
    }

    if (prohibitAssign === "always") {
      return {
        AssignmentExpression: testForConditionalAncestor
      };
    }

    return {
      DoWhileStatement: testForAssign,
      ForStatement: testForAssign,
      IfStatement: testForAssign,
      WhileStatement: testForAssign,
      ConditionalExpression: testForAssign
    };
  }

};

function isConditional(node) {
  return node && node.type === "ConditionalExpression";
}

var noConfusingArrow = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow arrow functions where they could be confused with comparisons",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-confusing-arrow"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        allowParens: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      confusing: "Arrow function used ambiguously with a conditional expression."
    }
  },

  create(context) {
    const config = context.options[0] || {};
    const allowParens = config.allowParens || config.allowParens === void 0;
    const sourceCode = context.getSourceCode();
    return {
      ArrowFunctionExpression: function (node) {
        const body = node.body;

        if (isConditional(body) && !(allowParens && astUtils.isParenthesised(sourceCode, body))) {
          context.report({
            node,
            messageId: "confusing",

            fix(fixer) {
              return allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);
            }

          });
        }
      }
    };
  }

};
var noConsole = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `console`",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-console"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          },
          minItems: 1,
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected console statement."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];

    function isConsole(reference) {
      const id = reference.identifier;
      return id && id.name === "console";
    }

    function isAllowed(node) {
      const propertyName = astUtils.getStaticPropertyName(node);
      return propertyName && allowed.indexOf(propertyName) !== -1;
    }

    function isMemberAccessExceptAllowed(reference) {
      const node = reference.identifier;
      const parent = node.parent;
      return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
    }

    function report(reference) {
      const node = reference.identifier.parent;
      context.report({
        node,
        loc: node.loc,
        messageId: "unexpected"
      });
    }

    return {
      "Program:exit"() {
        const scope = context.getScope();
        const consoleVar = astUtils.getVariableByName(scope, "console");
        const shadowed = consoleVar && consoleVar.defs.length > 0;
        const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);

        if (!shadowed) {
          references.filter(isMemberAccessExceptAllowed).forEach(report);
        }
      }

    };
  }

};
var noConstAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `const` variables",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-const-assign"
    },
    schema: [],
    messages: {
      const: "'{{name}}' is constant."
    }
  },

  create(context) {
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "const",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }

    return {
      VariableDeclaration(node) {
        if (node.kind === "const") {
          context.getDeclaredVariables(node).forEach(checkVariable);
        }
      }

    };
  }

};
var noConstantCondition = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow constant expressions in conditions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-constant-condition"
    },
    schema: [{
      type: "object",
      properties: {
        checkLoops: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected constant condition."
    }
  },

  create(context) {
    const options = context.options[0] || {},
          checkLoops = options.checkLoops !== false,
          loopSetStack = [];
    let loopsInCurrentScope = new Set();

    function getBooleanValue(node) {
      if (node.value === null) {
        if (node.raw === "null") {
          return false;
        }

        if (typeof node.regex === "object") {
          return true;
        }

        return null;
      }

      return !!node.value;
    }

    function isLogicalIdentity(node, operator) {
      switch (node.type) {
        case "Literal":
          return operator === "||" && getBooleanValue(node) === true || operator === "&&" && getBooleanValue(node) === false;

        case "UnaryExpression":
          return operator === "&&" && node.operator === "void";

        case "LogicalExpression":
          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));

        case "AssignmentExpression":
          return ["||=", "&&="].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);
      }

      return false;
    }

    function isConstant(node, inBooleanPosition) {
      if (!node) {
        return true;
      }

      switch (node.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ObjectExpression":
          return true;

        case "TemplateLiteral":
          return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(exp, inBooleanPosition));

        case "ArrayExpression":
          {
            if (node.parent.type === "BinaryExpression" && node.parent.operator === "+") {
              return node.elements.every(element => isConstant(element, false));
            }

            return true;
          }

        case "UnaryExpression":
          if (node.operator === "void" || node.operator === "typeof" && inBooleanPosition) {
            return true;
          }

          if (node.operator === "!") {
            return isConstant(node.argument, true);
          }

          return isConstant(node.argument, false);

        case "BinaryExpression":
          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== "in";

        case "LogicalExpression":
          {
            const isLeftConstant = isConstant(node.left, inBooleanPosition);
            const isRightConstant = isConstant(node.right, inBooleanPosition);
            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);
            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
          }

        case "AssignmentExpression":
          if (node.operator === "=") {
            return isConstant(node.right, inBooleanPosition);
          }

          if (["||=", "&&="].includes(node.operator) && inBooleanPosition) {
            return isLogicalIdentity(node.right, node.operator.slice(0, -1));
          }

          return false;

        case "SequenceExpression":
          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
      }

      return false;
    }

    function trackConstantConditionLoop(node) {
      if (node.test && isConstant(node.test, true)) {
        loopsInCurrentScope.add(node);
      }
    }

    function checkConstantConditionLoopInSet(node) {
      if (loopsInCurrentScope.has(node)) {
        loopsInCurrentScope.delete(node);
        context.report({
          node: node.test,
          messageId: "unexpected"
        });
      }
    }

    function reportIfConstant(node) {
      if (node.test && isConstant(node.test, true)) {
        context.report({
          node: node.test,
          messageId: "unexpected"
        });
      }
    }

    function enterFunction() {
      loopSetStack.push(loopsInCurrentScope);
      loopsInCurrentScope = new Set();
    }

    function exitFunction() {
      loopsInCurrentScope = loopSetStack.pop();
    }

    function checkLoop(node) {
      if (checkLoops) {
        trackConstantConditionLoop(node);
      }
    }

    return {
      ConditionalExpression: reportIfConstant,
      IfStatement: reportIfConstant,
      WhileStatement: checkLoop,
      "WhileStatement:exit": checkConstantConditionLoopInSet,
      DoWhileStatement: checkLoop,
      "DoWhileStatement:exit": checkConstantConditionLoopInSet,
      ForStatement: checkLoop,
      "ForStatement > .test": node => checkLoop(node.parent),
      "ForStatement:exit": checkConstantConditionLoopInSet,
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      YieldExpression: () => loopsInCurrentScope.clear()
    };
  }

};
var noConstructorReturn = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning value from constructor",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-constructor-return"
    },
    schema: {},
    fixable: null,
    messages: {
      unexpected: "Unexpected return statement in constructor."
    }
  },

  create(context) {
    const stack = [];
    return {
      onCodePathStart(_, node) {
        stack.push(node);
      },

      onCodePathEnd() {
        stack.pop();
      },

      ReturnStatement(node) {
        const last = stack[stack.length - 1];

        if (!last.parent) {
          return;
        }

        if (last.parent.type === "MethodDefinition" && last.parent.kind === "constructor" && (node.parent.parent === last || node.argument)) {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }

    };
  }

};
var noContinue = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `continue` statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-continue"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected use of continue statement."
    }
  },

  create(context) {
    return {
      ContinueStatement(node) {
        context.report({
          node,
          messageId: "unexpected"
        });
      }

    };
  }

};
const RegExpValidator$1 = regexpp__default['default'].RegExpValidator;
const collector = new class {
  constructor() {
    this._source = "";
    this._controlChars = [];
    this._validator = new RegExpValidator$1(this);
  }

  onPatternEnter() {
    this._controlChars = [];
  }

  onCharacter(start, end, cp) {
    if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
      this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);
    }
  }

  collectControlChars(regexpStr) {
    try {
      this._source = regexpStr;

      this._validator.validatePattern(regexpStr);
    } catch {}

    return this._controlChars;
  }

}();
var noControlRegex = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control characters in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-control-regex"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
    }
  },

  create(context) {
    function getRegExpPattern(node) {
      if (node.regex) {
        return node.regex.pattern;
      }

      if (typeof node.value === "string" && (node.parent.type === "NewExpression" || node.parent.type === "CallExpression") && node.parent.callee.type === "Identifier" && node.parent.callee.name === "RegExp" && node.parent.arguments[0] === node) {
        return node.value;
      }

      return null;
    }

    return {
      Literal(node) {
        const pattern = getRegExpPattern(node);

        if (pattern) {
          const controlCharacters = collector.collectControlChars(pattern);

          if (controlCharacters.length > 0) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                controlChars: controlCharacters.join(", ")
              }
            });
          }
        }
      }

    };
  }

};
var noDebugger = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of `debugger`",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-debugger"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Unexpected 'debugger' statement."
    }
  },

  create(context) {
    return {
      DebuggerStatement(node) {
        context.report({
          node,
          messageId: "unexpected"
        });
      }

    };
  }

};
var noDeleteVar = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow deleting variables",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-delete-var"
    },
    schema: [],
    messages: {
      unexpected: "Variables should not be deleted."
    }
  },

  create(context) {
    return {
      UnaryExpression(node) {
        if (node.operator === "delete" && node.argument.type === "Identifier") {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }

    };
  }

};
var noDivRegex = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow division operators explicitly at the beginning of regular expressions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-div-regex"
    },
    fixable: "code",
    schema: [],
    messages: {
      unexpected: "A regular expression literal can be confused with '/='."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node);

        if (token.type === "RegularExpression" && token.value[1] === "=") {
          context.report({
            node,
            messageId: "unexpected",

            fix(fixer) {
              return fixer.replaceTextRange([token.range[0] + 1, token.range[0] + 2], "[=]");
            }

          });
        }
      }

    };
  }

};
var noDupeArgs = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate arguments in `function` definitions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-args"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate param '{{name}}'."
    }
  },

  create(context) {
    function isParameter(def) {
      return def.type === "Parameter";
    }

    function checkParams(node) {
      const variables = context.getDeclaredVariables(node);

      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        const defs = variable.defs.filter(isParameter);

        if (defs.length >= 2) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              name: variable.name
            }
          });
        }
      }
    }

    return {
      FunctionDeclaration: checkParams,
      FunctionExpression: checkParams
    };
  }

};
var noDupeClassMembers = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate class members",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-class-members"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate name '{{name}}'."
    }
  },

  create(context) {
    let stack = [];

    function getState(name, isStatic) {
      const stateMap = stack[stack.length - 1];
      const key = `$${name}`;

      if (!stateMap[key]) {
        stateMap[key] = {
          nonStatic: {
            init: false,
            get: false,
            set: false
          },
          static: {
            init: false,
            get: false,
            set: false
          }
        };
      }

      return stateMap[key][isStatic ? "static" : "nonStatic"];
    }

    return {
      Program() {
        stack = [];
      },

      ClassBody() {
        stack.push(Object.create(null));
      },

      "ClassBody:exit"() {
        stack.pop();
      },

      MethodDefinition(node) {
        const name = astUtils.getStaticPropertyName(node);

        if (name === null || node.kind === "constructor") {
          return;
        }

        const state = getState(name, node.static);
        let isDuplicate = false;

        if (node.kind === "get") {
          isDuplicate = state.init || state.get;
          state.get = true;
        } else if (node.kind === "set") {
          isDuplicate = state.init || state.set;
          state.set = true;
        } else {
          isDuplicate = state.init || state.get || state.set;
          state.init = true;
        }

        if (isDuplicate) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              name
            }
          });
        }
      }

    };
  }

};

function isSubsetByComparator(comparator, arrA, arrB) {
  return arrA.every(a => arrB.some(b => comparator(a, b)));
}

function splitByLogicalOperator(operator, node) {
  if (node.type === "LogicalExpression" && node.operator === operator) {
    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];
  }

  return [node];
}

const splitByOr = splitByLogicalOperator.bind(null, "||");
const splitByAnd = splitByLogicalOperator.bind(null, "&&");
var noDupeElseIf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate conditions in if-else-if chains",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-else-if"
    },
    schema: [],
    messages: {
      unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function equal(a, b) {
      if (a.type !== b.type) {
        return false;
      }

      if (a.type === "LogicalExpression" && (a.operator === "||" || a.operator === "&&") && a.operator === b.operator) {
        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);
      }

      return astUtils.equalTokens(a, b, sourceCode);
    }

    const isSubset = isSubsetByComparator.bind(null, equal);
    return {
      IfStatement(node) {
        const test = node.test,
              conditionsToCheck = test.type === "LogicalExpression" && test.operator === "&&" ? [test, ...splitByAnd(test)] : [test];
        let current = node,
            listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));

        while (current.parent && current.parent.type === "IfStatement" && current.parent.alternate === current) {
          current = current.parent;
          const currentOrOperands = splitByOr(current.test).map(splitByAnd);
          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));

          if (listToCheck.some(orOperands => orOperands.length === 0)) {
            context.report({
              node: test,
              messageId: "unexpected"
            });
            break;
          }
        }
      }

    };
  }

};
const GET_KIND = /^(?:init|get)$/u;
const SET_KIND = /^(?:init|set)$/u;

class ObjectInfo {
  constructor(upper, node) {
    this.upper = upper;
    this.node = node;
    this.properties = new Map();
  }

  getPropertyInfo(node) {
    const name = astUtils.getStaticPropertyName(node);

    if (!this.properties.has(name)) {
      this.properties.set(name, {
        get: false,
        set: false
      });
    }

    return this.properties.get(name);
  }

  isPropertyDefined(node) {
    const entry = this.getPropertyInfo(node);
    return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
  }

  defineProperty(node) {
    const entry = this.getPropertyInfo(node);

    if (GET_KIND.test(node.kind)) {
      entry.get = true;
    }

    if (SET_KIND.test(node.kind)) {
      entry.set = true;
    }
  }

}

var noDupeKeys = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys in object literals",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-keys"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate key '{{name}}'."
    }
  },

  create(context) {
    let info = null;
    return {
      ObjectExpression(node) {
        info = new ObjectInfo(info, node);
      },

      "ObjectExpression:exit"() {
        info = info.upper;
      },

      Property(node) {
        const name = astUtils.getStaticPropertyName(node);

        if (node.parent.type !== "ObjectExpression") {
          return;
        }

        if (name === null) {
          return;
        }

        if (info.isPropertyDefined(node)) {
          context.report({
            node: info.node,
            loc: node.key.loc,
            messageId: "unexpected",
            data: {
              name
            }
          });
        }

        info.defineProperty(node);
      }

    };
  }

};
var noDuplicateCase = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate case labels",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-duplicate-case"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate case label."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function equal(a, b) {
      if (a.type !== b.type) {
        return false;
      }

      return astUtils.equalTokens(a, b, sourceCode);
    }

    return {
      SwitchStatement(node) {
        const previousTests = [];

        for (const switchCase of node.cases) {
          if (switchCase.test) {
            const test = switchCase.test;

            if (previousTests.some(previousTest => equal(previousTest, test))) {
              context.report({
                node: switchCase,
                messageId: "unexpected"
              });
            } else {
              previousTests.push(test);
            }
          }
        }
      }

    };
  }

};

function getValue(node) {
  if (node && node.source && node.source.value) {
    return node.source.value.trim();
  }

  return "";
}

function checkAndReport(context, node, value, array, messageId) {
  if (array.indexOf(value) !== -1) {
    context.report({
      node,
      messageId,
      data: {
        module: value
      }
    });
  }
}

function handleImports(context, includeExports, importsInFile, exportsInFile) {
  return function (node) {
    const value = getValue(node);

    if (value) {
      checkAndReport(context, node, value, importsInFile, "import");

      if (includeExports) {
        checkAndReport(context, node, value, exportsInFile, "importAs");
      }

      importsInFile.push(value);
    }
  };
}

function handleExports(context, importsInFile, exportsInFile) {
  return function (node) {
    const value = getValue(node);

    if (value) {
      checkAndReport(context, node, value, exportsInFile, "export");
      checkAndReport(context, node, value, importsInFile, "exportAs");
      exportsInFile.push(value);
    }
  };
}

var noDuplicateImports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate module imports",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-duplicate-imports"
    },
    schema: [{
      type: "object",
      properties: {
        includeExports: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      import: "'{{module}}' import is duplicated.",
      importAs: "'{{module}}' import is duplicated as export.",
      export: "'{{module}}' export is duplicated.",
      exportAs: "'{{module}}' export is duplicated as import."
    }
  },

  create(context) {
    const includeExports = (context.options[0] || {}).includeExports,
          importsInFile = [],
          exportsInFile = [];
    const handlers = {
      ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
    };

    if (includeExports) {
      handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
      handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
    }

    return handlers;
  }

};

class FixTracker {
  constructor(fixer, sourceCode) {
    this.fixer = fixer;
    this.sourceCode = sourceCode;
    this.retainedRange = null;
  }

  retainRange(range) {
    this.retainedRange = range;
    return this;
  }

  retainEnclosingFunction(node) {
    const functionNode = astUtils.getUpperFunction(node);
    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
  }

  retainSurroundingTokens(nodeOrToken) {
    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
  }

  replaceTextRange(range, text) {
    let actualRange;

    if (this.retainedRange) {
      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];
    } else {
      actualRange = range;
    }

    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
  }

  remove(nodeOrToken) {
    return this.replaceTextRange(nodeOrToken.range, "");
  }

}

var fixTracker = FixTracker;
var noElseReturn = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `else` blocks after `return` statements in `if` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-else-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowElseIf: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unexpected: "Unnecessary 'else' after 'return'."
    }
  },

  create(context) {
    function isSafeToDeclare(names, scope) {
      if (names.length === 0) {
        return true;
      }

      const functionScope = scope.variableScope;
      const declaredVariables = scope.variables.filter(({
        defs
      }) => defs.length > 0);

      if (declaredVariables.some(({
        name
      }) => names.includes(name))) {
        return false;
      }

      if (scope !== functionScope && scope.upper.type === "catch") {
        if (scope.upper.variables.some(({
          name
        }) => names.includes(name))) {
          return false;
        }
      }

      const usedImplicitVariables = scope.variables.filter(({
        defs,
        references
      }) => defs.length === 0 && references.length > 0);

      if (usedImplicitVariables.some(({
        name
      }) => names.includes(name))) {
        return false;
      }

      if (scope.through.some(t => names.includes(t.identifier.name))) {
        return false;
      }

      if (scope !== functionScope) {
        const scopeNodeRange = scope.block.range;
        const variablesToCheck = functionScope.variables.filter(({
          name
        }) => names.includes(name));

        if (variablesToCheck.some(v => v.defs.some(({
          node: {
            range
          }
        }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {
          return false;
        }
      }

      return true;
    }

    function isSafeFromNameCollisions(node, scope) {
      if (node.type === "FunctionDeclaration") {
        return false;
      }

      if (node.type !== "BlockStatement") {
        return true;
      }

      const elseBlockScope = scope.childScopes.find(({
        block
      }) => block === node);

      if (!elseBlockScope) {
        return true;
      }

      const namesToCheck = elseBlockScope.variables.map(({
        name
      }) => name);
      return isSafeToDeclare(namesToCheck, scope);
    }

    function displayReport(node) {
      const currentScope = context.getScope();
      context.report({
        node,
        messageId: "unexpected",
        fix: fixer => {
          if (!isSafeFromNameCollisions(node, currentScope)) {
            return null;
          }

          const sourceCode = context.getSourceCode();
          const startToken = sourceCode.getFirstToken(node);
          const elseToken = sourceCode.getTokenBefore(startToken);
          const source = sourceCode.getText(node);
          const lastIfToken = sourceCode.getTokenBefore(elseToken);
          let fixedSource, firstTokenOfElseBlock;

          if (startToken.type === "Punctuator" && startToken.value === "{") {
            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
          } else {
            firstTokenOfElseBlock = startToken;
          }

          const ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);

          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
            return null;
          }

          const endToken = sourceCode.getLastToken(node);
          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);

          if (lastTokenOfElseBlock.value !== ";") {
            const nextToken = sourceCode.getTokenAfter(endToken);
            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;

            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
              return null;
            }
          }

          if (startToken.type === "Punctuator" && startToken.value === "{") {
            fixedSource = source.slice(1, -1);
          } else {
            fixedSource = source;
          }

          return new fixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
        }
      });
    }

    function checkForReturn(node) {
      return node.type === "ReturnStatement";
    }

    function naiveHasReturn(node) {
      if (node.type === "BlockStatement") {
        const body = node.body,
              lastChildNode = body[body.length - 1];
        return lastChildNode && checkForReturn(lastChildNode);
      }

      return checkForReturn(node);
    }

    function hasElse(node) {
      return node.alternate && node.consequent;
    }

    function checkForIf(node) {
      return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
    }

    function checkForReturnOrIf(node) {
      return checkForReturn(node) || checkForIf(node);
    }

    function alwaysReturns(node) {
      if (node.type === "BlockStatement") {
        return node.body.some(checkForReturnOrIf);
      }

      return checkForReturnOrIf(node);
    }

    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);
    return {
      "IfStatement:exit": allowElseIf ? function (node) {
        const parent = node.parent;

        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }

        const consequents = [];
        let alternate;

        for (let currentNode = node; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) {
          if (!currentNode.alternate) {
            return;
          }

          consequents.push(currentNode.consequent);
          alternate = currentNode.alternate;
        }

        if (consequents.every(alwaysReturns)) {
          displayReport(alternate);
        }
      } : function (node) {
        const parent = node.parent;

        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }

        const alternate = node.alternate;

        if (alternate && alwaysReturns(node.consequent)) {
          displayReport(alternate);
        }
      }
    };
  }

};
const regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuys]*$/u;
var noEmptyCharacterClass = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty character classes in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty-character-class"
    },
    schema: [],
    messages: {
      unexpected: "Empty class."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node);

        if (token.type === "RegularExpression" && !regex.test(token.value)) {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }

    };
  }

};
const ALLOW_OPTIONS = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors", "asyncFunctions", "asyncMethods"]);

function getKind(node) {
  const parent = node.parent;
  let kind = "";

  if (node.type === "ArrowFunctionExpression") {
    return "arrowFunctions";
  }

  if (parent.type === "Property") {
    if (parent.kind === "get") {
      return "getters";
    }

    if (parent.kind === "set") {
      return "setters";
    }

    kind = parent.method ? "methods" : "functions";
  } else if (parent.type === "MethodDefinition") {
    if (parent.kind === "get") {
      return "getters";
    }

    if (parent.kind === "set") {
      return "setters";
    }

    if (parent.kind === "constructor") {
      return "constructors";
    }

    kind = "methods";
  } else {
    kind = "functions";
  }

  let prefix = "";

  if (node.generator) {
    prefix = "generator";
  } else if (node.async) {
    prefix = "async";
  } else {
    return kind;
  }

  return prefix + kind[0].toUpperCase() + kind.slice(1);
}

var noEmptyFunction = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty functions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-empty-function"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: ALLOW_OPTIONS
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected empty {{name}}."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];
    const sourceCode = context.getSourceCode();

    function reportIfEmpty(node) {
      const kind = getKind(node);
      const name = astUtils.getFunctionNameWithKind(node);
      const innerComments = sourceCode.getTokens(node.body, {
        includeComments: true,
        filter: astUtils.isCommentToken
      });

      if (allowed.indexOf(kind) === -1 && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
        context.report({
          node,
          loc: node.body.loc,
          messageId: "unexpected",
          data: {
            name
          }
        });
      }
    }

    return {
      ArrowFunctionExpression: reportIfEmpty,
      FunctionDeclaration: reportIfEmpty,
      FunctionExpression: reportIfEmpty
    };
  }

};
var noEmptyPattern = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty destructuring patterns",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty-pattern"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected empty {{type}} pattern."
    }
  },

  create(context) {
    return {
      ObjectPattern(node) {
        if (node.properties.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "object"
            }
          });
        }
      },

      ArrayPattern(node) {
        if (node.elements.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "array"
            }
          });
        }
      }

    };
  }

};
var noEmpty = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty block statements",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty"
    },
    schema: [{
      type: "object",
      properties: {
        allowEmptyCatch: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Empty {{type}} statement."
    }
  },

  create(context) {
    const options = context.options[0] || {},
          allowEmptyCatch = options.allowEmptyCatch || false;
    const sourceCode = context.getSourceCode();
    return {
      BlockStatement(node) {
        if (node.body.length !== 0) {
          return;
        }

        if (astUtils.isFunction(node.parent)) {
          return;
        }

        if (allowEmptyCatch && node.parent.type === "CatchClause") {
          return;
        }

        if (sourceCode.getCommentsInside(node).length > 0) {
          return;
        }

        context.report({
          node,
          messageId: "unexpected",
          data: {
            type: "block"
          }
        });
      },

      SwitchStatement(node) {
        if (typeof node.cases === "undefined" || node.cases.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "switch"
            }
          });
        }
      }

    };
  }

};
var noEqNull = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `null` comparisons without type-checking operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-eq-null"
    },
    schema: [],
    messages: {
      unexpected: "Use '===' to compare with null."
    }
  },

  create(context) {
    return {
      BinaryExpression(node) {
        const badOperator = node.operator === "==" || node.operator === "!=";

        if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }

    };
  }

};
const candidatesOfGlobalObject = Object.freeze(["global", "window", "globalThis"]);

function isMember(node, name) {
  return astUtils.isSpecificMemberAccess(node, null, name);
}

var noEval = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-eval"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndirect: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "eval can be harmful."
    }
  },

  create(context) {
    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);
    const sourceCode = context.getSourceCode();
    let funcInfo = null;

    function enterVarScope(node) {
      const strict = context.getScope().isStrict;
      funcInfo = {
        upper: funcInfo,
        node,
        strict,
        defaultThis: false,
        initialized: strict
      };
    }

    function exitVarScope() {
      funcInfo = funcInfo.upper;
    }

    function report(node) {
      const parent = node.parent;
      const locationNode = node.type === "MemberExpression" ? node.property : node;
      const reportNode = parent.type === "CallExpression" && parent.callee === node ? parent : node;
      context.report({
        node: reportNode,
        loc: locationNode.loc,
        messageId: "unexpected"
      });
    }

    function reportAccessingEvalViaGlobalObject(globalScope) {
      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
        const name = candidatesOfGlobalObject[i];
        const variable = astUtils.getVariableByName(globalScope, name);

        if (!variable) {
          continue;
        }

        const references = variable.references;

        for (let j = 0; j < references.length; ++j) {
          const identifier = references[j].identifier;
          let node = identifier.parent;

          while (isMember(node, name)) {
            node = node.parent;
          }

          if (isMember(node, "eval")) {
            report(node);
          }
        }
      }
    }

    function reportAccessingEval(globalScope) {
      const variable = astUtils.getVariableByName(globalScope, "eval");

      if (!variable) {
        return;
      }

      const references = variable.references;

      for (let i = 0; i < references.length; ++i) {
        const reference = references[i];
        const id = reference.identifier;

        if (id.name === "eval" && !astUtils.isCallee(id)) {
          report(id);
        }
      }
    }

    if (allowIndirect) {
      return {
        "CallExpression:exit"(node) {
          const callee = node.callee;

          if (!node.optional && astUtils.isSpecificId(callee, "eval")) {
            report(callee);
          }
        }

      };
    }

    return {
      "CallExpression:exit"(node) {
        const callee = node.callee;

        if (astUtils.isSpecificId(callee, "eval")) {
          report(callee);
        }
      },

      Program(node) {
        const scope = context.getScope(),
              features = context.parserOptions.ecmaFeatures || {},
              strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict;
        funcInfo = {
          upper: null,
          node,
          strict,
          defaultThis: true,
          initialized: true
        };
      },

      "Program:exit"() {
        const globalScope = context.getScope();
        exitVarScope();
        reportAccessingEval(globalScope);
        reportAccessingEvalViaGlobalObject(globalScope);
      },

      FunctionDeclaration: enterVarScope,
      "FunctionDeclaration:exit": exitVarScope,
      FunctionExpression: enterVarScope,
      "FunctionExpression:exit": exitVarScope,
      ArrowFunctionExpression: enterVarScope,
      "ArrowFunctionExpression:exit": exitVarScope,

      ThisExpression(node) {
        if (!isMember(node.parent, "eval")) {
          return;
        }

        if (!funcInfo.initialized) {
          funcInfo.initialized = true;
          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);
        }

        if (!funcInfo.strict && funcInfo.defaultThis) {
          report(node.parent);
        }
      }

    };
  }

};
var noExAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning exceptions in `catch` clauses",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-ex-assign"
    },
    schema: [],
    messages: {
      unexpected: "Do not assign to the exception parameter."
    }
  },

  create(context) {
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "unexpected"
        });
      });
    }

    return {
      CatchClause(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
      }

    };
  }

};
var noExtendNative = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow extending native types",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extend-native"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "{{builtin}} prototype is read only, properties should not be added."
    }
  },

  create(context) {
    const config = context.options[0] || {};
    const exceptions = new Set(config.exceptions || []);
    const modifiedBuiltins = new Set(Object.keys(globals__default['default'].builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));

    function reportNode(node, builtin) {
      context.report({
        node,
        messageId: "unexpected",
        data: {
          builtin
        }
      });
    }

    function isPrototypePropertyAccessed(identifierNode) {
      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype");
    }

    function isAssigningToPropertyOf(node) {
      return node.parent.type === "MemberExpression" && node.parent.object === node && node.parent.parent.type === "AssignmentExpression" && node.parent.parent.left === node.parent;
    }

    function isInDefinePropertyCall(node) {
      return node.parent.type === "CallExpression" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, "Object", /^definePropert(?:y|ies)$/u);
    }

    function checkAndReportPrototypeExtension(identifierNode) {
      if (!isPrototypePropertyAccessed(identifierNode)) {
        return;
      }

      const prototypeNode = identifierNode.parent.parent.type === "ChainExpression" ? identifierNode.parent.parent : identifierNode.parent;

      if (isAssigningToPropertyOf(prototypeNode)) {
        reportNode(prototypeNode.parent.parent, identifierNode.name);
      } else if (isInDefinePropertyCall(prototypeNode)) {
        reportNode(prototypeNode.parent, identifierNode.name);
      }
    }

    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        modifiedBuiltins.forEach(builtin => {
          const builtinVar = globalScope.set.get(builtin);

          if (builtinVar && builtinVar.references) {
            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);
          }
        });
      }

    };
  }

};
const SIDE_EFFECT_FREE_NODE_TYPES = new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);
var noExtraBind = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.bind()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-bind"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "The function binding is unnecessary."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    function isSideEffectFree(node) {
      return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);
    }

    function report(node) {
      const memberNode = node.parent;
      const callNode = memberNode.parent.type === "ChainExpression" ? memberNode.parent.parent : memberNode.parent;
      context.report({
        node: callNode,
        messageId: "unexpected",
        loc: memberNode.property.loc,

        fix(fixer) {
          if (!isSideEffectFree(callNode.arguments[0])) {
            return null;
          }

          const tokenPairs = [[sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken), sourceCode.getLastToken(memberNode)], [sourceCode.getTokenAfter(memberNode, astUtils.isNotClosingParenToken), sourceCode.getLastToken(callNode)]];
          const firstTokenToRemove = tokenPairs[0][0];
          const lastTokenToRemove = tokenPairs[1][1];

          if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
            return null;
          }

          return tokenPairs.map(([start, end]) => fixer.removeRange([start.range[0], end.range[1]]));
        }

      });
    }

    function isCalleeOfBindMethod(node) {
      if (!astUtils.isSpecificMemberAccess(node.parent, null, "bind")) {
        return false;
      }

      const bindNode = node.parent.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
      return bindNode.parent.type === "CallExpression" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== "SpreadElement";
    }

    function enterFunction(node) {
      scopeInfo = {
        isBound: isCalleeOfBindMethod(node),
        thisFound: false,
        upper: scopeInfo
      };
    }

    function exitFunction(node) {
      if (scopeInfo.isBound && !scopeInfo.thisFound) {
        report(node);
      }

      scopeInfo = scopeInfo.upper;
    }

    function markAsThisFound() {
      if (scopeInfo) {
        scopeInfo.thisFound = true;
      }
    }

    return {
      "ArrowFunctionExpression:exit": function (node) {
        if (isCalleeOfBindMethod(node)) {
          report(node);
        }
      },
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      ThisExpression: markAsThisFound
    };
  }

};
const precedence = astUtils.getPrecedence;
var noExtraBooleanCast = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary boolean casts",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-extra-boolean-cast"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForLogicalOperands: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unexpectedCall: "Redundant Boolean call.",
      unexpectedNegation: "Redundant double negation."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const BOOLEAN_NODE_TYPES = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];

    function isBooleanFunctionOrConstructorCall(node) {
      return (node.type === "CallExpression" || node.type === "NewExpression") && node.callee.type === "Identifier" && node.callee.name === "Boolean";
    }

    function isLogicalContext(node) {
      return node.type === "LogicalExpression" && (node.operator === "||" || node.operator === "&&") && context.options.length && context.options[0].enforceForLogicalOperands === true;
    }

    function isInBooleanContext(node) {
      return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test || node.parent.type === "UnaryExpression" && node.parent.operator === "!";
    }

    function isInFlaggedContext(node) {
      if (node.parent.type === "ChainExpression") {
        return isInFlaggedContext(node.parent);
      }

      return isInBooleanContext(node) || isLogicalContext(node.parent) && isInFlaggedContext(node.parent);
    }

    function hasCommentsInside(node) {
      return Boolean(sourceCode.getCommentsInside(node).length);
    }

    function isParenthesized(node) {
      return eslintUtils__default['default'].isParenthesized(1, node, sourceCode);
    }

    function needsParens(previousNode, node) {
      if (previousNode.parent.type === "ChainExpression") {
        return needsParens(previousNode.parent, node);
      }

      if (isParenthesized(previousNode)) {
        return false;
      }

      const parent = previousNode.parent;

      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          return node.type === "SequenceExpression";

        case "IfStatement":
        case "DoWhileStatement":
        case "WhileStatement":
        case "ForStatement":
          return false;

        case "ConditionalExpression":
          return precedence(node) <= precedence(parent);

        case "UnaryExpression":
          return precedence(node) < precedence(parent);

        case "LogicalExpression":
          if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {
            return true;
          }

          if (previousNode === parent.left) {
            return precedence(node) < precedence(parent);
          }

          return precedence(node) <= precedence(parent);

        default:
          throw new Error(`Unexpected parent type: ${parent.type}`);
      }
    }

    return {
      UnaryExpression(node) {
        const parent = node.parent;

        if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
          return;
        }

        if (isInFlaggedContext(parent)) {
          context.report({
            node: parent,
            messageId: "unexpectedNegation",

            fix(fixer) {
              if (hasCommentsInside(parent)) {
                return null;
              }

              if (needsParens(parent, node.argument)) {
                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);
              }

              let prefix = "";
              const tokenBefore = sourceCode.getTokenBefore(parent);
              const firstReplacementToken = sourceCode.getFirstToken(node.argument);

              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                prefix = " ";
              }

              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));
            }

          });
        }
      },

      CallExpression(node) {
        if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
          return;
        }

        if (isInFlaggedContext(node)) {
          context.report({
            node,
            messageId: "unexpectedCall",

            fix(fixer) {
              const parent = node.parent;

              if (node.arguments.length === 0) {
                if (parent.type === "UnaryExpression" && parent.operator === "!") {
                  if (hasCommentsInside(parent)) {
                    return null;
                  }

                  let prefix = "";
                  const tokenBefore = sourceCode.getTokenBefore(parent);

                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, "true")) {
                    prefix = " ";
                  }

                  return fixer.replaceText(parent, prefix + "true");
                }

                if (hasCommentsInside(node)) {
                  return null;
                }

                return fixer.replaceText(node, "false");
              }

              if (node.arguments.length === 1) {
                const argument = node.arguments[0];

                if (argument.type === "SpreadElement" || hasCommentsInside(node)) {
                  return null;
                }

                if (needsParens(node, argument)) {
                  return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);
                }

                return fixer.replaceText(node, sourceCode.getText(argument));
              }

              return null;
            }

          });
        }
      }

    };
  }

};
var noExtraLabel = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary labels",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-label"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "This label '{{name}}' is unnecessary."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    function enterBreakableStatement(node) {
      scopeInfo = {
        label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
        breakable: true,
        upper: scopeInfo
      };
    }

    function exitBreakableStatement() {
      scopeInfo = scopeInfo.upper;
    }

    function enterLabeledStatement(node) {
      if (!astUtils.isBreakableStatement(node.body)) {
        scopeInfo = {
          label: node.label,
          breakable: false,
          upper: scopeInfo
        };
      }
    }

    function exitLabeledStatement(node) {
      if (!astUtils.isBreakableStatement(node.body)) {
        scopeInfo = scopeInfo.upper;
      }
    }

    function reportIfUnnecessary(node) {
      if (!node.label) {
        return;
      }

      const labelNode = node.label;

      for (let info = scopeInfo; info !== null; info = info.upper) {
        if (info.breakable || info.label && info.label.name === labelNode.name) {
          if (info.breakable && info.label && info.label.name === labelNode.name) {
            context.report({
              node: labelNode,
              messageId: "unexpected",
              data: labelNode,

              fix(fixer) {
                const breakOrContinueToken = sourceCode.getFirstToken(node);

                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {
                  return null;
                }

                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);
              }

            });
          }

          return;
        }
      }
    }

    return {
      WhileStatement: enterBreakableStatement,
      "WhileStatement:exit": exitBreakableStatement,
      DoWhileStatement: enterBreakableStatement,
      "DoWhileStatement:exit": exitBreakableStatement,
      ForStatement: enterBreakableStatement,
      "ForStatement:exit": exitBreakableStatement,
      ForInStatement: enterBreakableStatement,
      "ForInStatement:exit": exitBreakableStatement,
      ForOfStatement: enterBreakableStatement,
      "ForOfStatement:exit": exitBreakableStatement,
      SwitchStatement: enterBreakableStatement,
      "SwitchStatement:exit": exitBreakableStatement,
      LabeledStatement: enterLabeledStatement,
      "LabeledStatement:exit": exitLabeledStatement,
      BreakStatement: reportIfUnnecessary,
      ContinueStatement: reportIfUnnecessary
    };
  }

};
const {
  isParenthesized: isParenthesizedRaw
} = eslintUtils__default['default'];
var noExtraParens = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow unnecessary parentheses",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-parens"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["functions"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["all"]
        }, {
          type: "object",
          properties: {
            conditionalAssign: {
              type: "boolean"
            },
            nestedBinaryExpressions: {
              type: "boolean"
            },
            returnAssign: {
              type: "boolean"
            },
            ignoreJSX: {
              enum: ["none", "all", "single-line", "multi-line"]
            },
            enforceForArrowConditionals: {
              type: "boolean"
            },
            enforceForSequenceExpressions: {
              type: "boolean"
            },
            enforceForNewInMemberExpressions: {
              type: "boolean"
            },
            enforceForFunctionPrototypeMethods: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpected: "Unnecessary parentheses around expression."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const tokensToIgnore = new WeakSet();
    const precedence = astUtils.getPrecedence;
    const ALL_NODES = context.options[0] !== "functions";
    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;
    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;
    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;
    const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;
    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({
      type: "AssignmentExpression"
    });
    const PRECEDENCE_OF_UPDATE_EXPR = precedence({
      type: "UpdateExpression"
    });
    let reportsBuffer;

    function isImmediateFunctionPrototypeMethodCall(node) {
      const callNode = astUtils.skipChainExpression(node);

      if (callNode.type !== "CallExpression") {
        return false;
      }

      const callee = astUtils.skipChainExpression(callNode.callee);
      return callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && ["call", "apply"].includes(astUtils.getStaticPropertyName(callee));
    }

    function ruleApplies(node) {
      if (node.type === "JSXElement" || node.type === "JSXFragment") {
        const isSingleLine = node.loc.start.line === node.loc.end.line;

        switch (IGNORE_JSX) {
          case "all":
            return false;

          case "multi-line":
            return isSingleLine;

          case "single-line":
            return !isSingleLine;
        }
      }

      if (node.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) {
        return false;
      }

      if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {
        return false;
      }

      return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }

    function isParenthesised(node) {
      return isParenthesizedRaw(1, node, sourceCode);
    }

    function isParenthesisedTwice(node) {
      return isParenthesizedRaw(2, node, sourceCode);
    }

    function hasExcessParens(node) {
      return ruleApplies(node) && isParenthesised(node);
    }

    function hasDoubleExcessParens(node) {
      return ruleApplies(node) && isParenthesisedTwice(node);
    }

    function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {
      if (ruleApplies(node) && isParenthesised(node)) {
        if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {
          return true;
        }
      }

      return false;
    }

    function isCondAssignException(node) {
      return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
    }

    function isInReturnStatement(node) {
      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
        if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") {
          return true;
        }
      }

      return false;
    }

    function isNewExpressionWithParens(newExpression) {
      const lastToken = sourceCode.getLastToken(newExpression);
      const penultimateToken = sourceCode.getTokenBefore(lastToken);
      return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];
    }

    function containsAssignment(node) {
      if (node.type === "AssignmentExpression") {
        return true;
      }

      if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
        return true;
      }

      if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
        return true;
      }

      return false;
    }

    function isReturnAssignException(node) {
      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
        return false;
      }

      if (node.type === "ReturnStatement") {
        return node.argument && containsAssignment(node.argument);
      }

      if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
        return containsAssignment(node.body);
      }

      return containsAssignment(node);
    }

    function hasExcessParensNoLineTerminator(token, node) {
      if (token.loc.end.line === node.loc.start.line) {
        return hasExcessParens(node);
      }

      return hasDoubleExcessParens(node);
    }

    function requiresLeadingSpace(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, {
        includeComments: true
      });
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, {
        includeComments: true
      });
      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);
    }

    function requiresTrailingSpace(node) {
      const nextTwoTokens = sourceCode.getTokensAfter(node, {
        count: 2
      });
      const rightParenToken = nextTwoTokens[0];
      const tokenAfterRightParen = nextTwoTokens[1];
      const tokenBeforeRightParen = sourceCode.getLastToken(node);
      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
    }

    function isIIFE(node) {
      const maybeCallNode = astUtils.skipChainExpression(node);
      return maybeCallNode.type === "CallExpression" && maybeCallNode.callee.type === "FunctionExpression";
    }

    function canBeAssignmentTarget(node) {
      return node && (node.type === "Identifier" || node.type === "MemberExpression");
    }

    function report(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const rightParenToken = sourceCode.getTokenAfter(node);

      if (!isParenthesisedTwice(node)) {
        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
          return;
        }

        if (isIIFE(node) && !isParenthesised(node.callee)) {
          return;
        }
      }

      function finishReport() {
        context.report({
          node,
          loc: leftParenToken.loc,
          messageId: "unexpected",

          fix(fixer) {
            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
          }

        });
      }

      if (reportsBuffer) {
        reportsBuffer.reports.push({
          node,
          finishReport
        });
        return;
      }

      finishReport();
    }

    function checkArgumentWithPrecedence(node) {
      if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {
        report(node.argument);
      }
    }

    function doesMemberExpressionContainCallExpression(node) {
      let currentNode = node.object;
      let currentNodeType = node.object.type;

      while (currentNodeType === "MemberExpression") {
        currentNode = currentNode.object;
        currentNodeType = currentNode.type;
      }

      return currentNodeType === "CallExpression";
    }

    function checkCallNew(node) {
      const callee = node.callee;

      if (hasExcessParensWithPrecedence(callee, precedence(node))) {
        if (hasDoubleExcessParens(callee) || !(isIIFE(node) || callee.type === "NewExpression" && !isNewExpressionWithParens(callee) && !(node.type === "NewExpression" && !isNewExpressionWithParens(node)) || node.type === "NewExpression" && callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee) || !node.optional && callee.type === "ChainExpression")) {
          report(node.callee);
        }
      }

      node.arguments.filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
    }

    function checkBinaryLogical(node) {
      const prec = precedence(node);
      const leftPrecedence = precedence(node.left);
      const rightPrecedence = precedence(node.right);
      const isExponentiation = node.operator === "**";
      const shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression");
      const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");

      if (!shouldSkipLeft && hasExcessParens(node.left)) {
        if (!(["AwaitExpression", "UnaryExpression"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {
          report(node.left);
        }
      }

      if (!shouldSkipRight && hasExcessParens(node.right)) {
        if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {
          report(node.right);
        }
      }
    }

    function checkClass(node) {
      if (!node.superClass) {
        return;
      }

      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);

      if (hasExtraParens) {
        report(node.superClass);
      }
    }

    function checkSpreadOperator(node) {
      if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
        report(node.argument);
      }
    }

    function checkExpressionOrExportStatement(node) {
      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;

      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
        tokensToIgnore.add(secondToken);
      }

      const hasExtraParens = node.parent.type === "ExportDefaultDeclaration" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);

      if (hasExtraParens) {
        report(node);
      }
    }

    function pathToAncestor(node, ancestor) {
      const path = [node];
      let currentNode = node;

      while (currentNode !== ancestor) {
        currentNode = currentNode.parent;

        if (currentNode === null) {
          throw new Error("Nodes are not in the ancestor-descendant relationship.");
        }

        path.push(currentNode);
      }

      return path;
    }

    function pathToDescendant(node, descendant) {
      return pathToAncestor(descendant, node).reverse();
    }

    function isSafelyEnclosingInExpression(node, child) {
      switch (node.type) {
        case "ArrayExpression":
        case "ArrayPattern":
        case "BlockStatement":
        case "ObjectExpression":
        case "ObjectPattern":
        case "TemplateLiteral":
          return true;

        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return node.params.includes(child);

        case "CallExpression":
        case "NewExpression":
          return node.arguments.includes(child);

        case "MemberExpression":
          return node.computed && node.property === child;

        case "ConditionalExpression":
          return node.consequent === child;

        default:
          return false;
      }
    }

    function startNewReportsBuffering() {
      reportsBuffer = {
        upper: reportsBuffer,
        inExpressionNodes: [],
        reports: []
      };
    }

    function endCurrentReportsBuffering() {
      const {
        upper,
        inExpressionNodes,
        reports
      } = reportsBuffer;

      if (upper) {
        upper.inExpressionNodes.push(...inExpressionNodes);
        upper.reports.push(...reports);
      } else {
        reports.forEach(({
          finishReport
        }) => finishReport());
      }

      reportsBuffer = upper;
    }

    function isInCurrentReportsBuffer(node) {
      return reportsBuffer.reports.some(r => r.node === node);
    }

    function removeFromCurrentReportsBuffer(node) {
      reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);
    }

    function isMemberExpInNewCallee(node) {
      if (node.type === "MemberExpression") {
        return node.parent.type === "NewExpression" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);
      }

      return false;
    }

    return {
      ArrayExpression(node) {
        node.elements.filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
      },

      ArrayPattern(node) {
        node.elements.filter(e => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);
      },

      ArrowFunctionExpression(node) {
        if (isReturnAssignException(node)) {
          return;
        }

        if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS) {
          return;
        }

        if (node.body.type !== "BlockStatement") {
          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);

          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
            tokensToIgnore.add(firstBodyToken);
          }

          if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(node.body);
          }
        }
      },

      AssignmentExpression(node) {
        if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {
          report(node.left);
        }

        if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {
          report(node.right);
        }
      },

      BinaryExpression(node) {
        if (reportsBuffer && node.operator === "in") {
          reportsBuffer.inExpressionNodes.push(node);
        }

        checkBinaryLogical(node);
      },

      CallExpression: checkCallNew,

      ClassBody(node) {
        node.body.filter(member => member.type === "MethodDefinition" && member.computed && member.key).filter(member => hasExcessParensWithPrecedence(member.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(member => report(member.key));
      },

      ConditionalExpression(node) {
        if (isReturnAssignException(node)) {
          return;
        }

        if (!isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({
          type: "LogicalExpression",
          operator: "||"
        }))) {
          report(node.test);
        }

        if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
          report(node.consequent);
        }

        if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
          report(node.alternate);
        }
      },

      DoWhileStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },

      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),
      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),

      ForInStatement(node) {
        if (node.left.type !== "VariableDeclaration") {
          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);

          if (firstLeftToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken))) {
            tokensToIgnore.add(firstLeftToken);
          }
        }

        if (hasExcessParens(node.left)) {
          report(node.left);
        }

        if (hasExcessParens(node.right)) {
          report(node.right);
        }
      },

      ForOfStatement(node) {
        if (node.left.type !== "VariableDeclaration") {
          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);

          if (firstLeftToken.value === "let") {
            tokensToIgnore.add(firstLeftToken);
          }
        }

        if (hasExcessParens(node.left)) {
          report(node.left);
        }

        if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
          report(node.right);
        }
      },

      ForStatement(node) {
        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }

        if (node.update && hasExcessParens(node.update)) {
          report(node.update);
        }

        if (node.init) {
          if (node.init.type !== "VariableDeclaration") {
            const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);

            if (firstToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken))) {
              tokensToIgnore.add(firstToken);
            }
          }

          startNewReportsBuffering();

          if (hasExcessParens(node.init)) {
            report(node.init);
          }
        }
      },

      "ForStatement > *.init:exit"(node) {
        if (reportsBuffer.reports.length) {
          reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {
            const path = pathToDescendant(node, inExpressionNode);
            let nodeToExclude;

            for (let i = 0; i < path.length; i++) {
              const pathNode = path[i];

              if (i < path.length - 1) {
                const nextPathNode = path[i + 1];

                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {
                  return;
                }
              }

              if (isParenthesised(pathNode)) {
                if (isInCurrentReportsBuffer(pathNode)) {
                  if (isParenthesisedTwice(pathNode)) {
                    return;
                  }

                  if (!nodeToExclude) {
                    nodeToExclude = pathNode;
                  }
                } else {
                  return;
                }
              }
            }

            removeFromCurrentReportsBuffer(nodeToExclude);
          });
        }

        endCurrentReportsBuffering();
      },

      IfStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },

      ImportExpression(node) {
        const {
          source
        } = node;

        if (source.type === "SequenceExpression") {
          if (hasDoubleExcessParens(source)) {
            report(source);
          }
        } else if (hasExcessParens(source)) {
          report(source);
        }
      },

      LogicalExpression: checkBinaryLogical,

      MemberExpression(node) {
        const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);
        const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);

        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || node.object.type === "Literal" && node.object.regex))) {
          report(node.object);
        }

        if (nodeObjHasExcessParens && node.object.type === "CallExpression") {
          report(node.object);
        }

        if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === "NewExpression" && isNewExpressionWithParens(node.object)) {
          report(node.object);
        }

        if (nodeObjHasExcessParens && node.optional && node.object.type === "ChainExpression") {
          report(node.object);
        }

        if (node.computed && hasExcessParens(node.property)) {
          report(node.property);
        }
      },

      NewExpression: checkCallNew,

      ObjectExpression(node) {
        node.properties.filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(property => report(property.value));
      },

      ObjectPattern(node) {
        node.properties.filter(property => {
          const value = property.value;
          return canBeAssignmentTarget(value) && hasExcessParens(value);
        }).forEach(property => report(property.value));
      },

      Property(node) {
        if (node.computed) {
          const {
            key
          } = node;

          if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(key);
          }
        }
      },

      RestElement(node) {
        const argument = node.argument;

        if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {
          report(argument);
        }
      },

      ReturnStatement(node) {
        const returnToken = sourceCode.getFirstToken(node);

        if (isReturnAssignException(node)) {
          return;
        }

        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && !(node.argument.type === "Literal" && node.argument.regex)) {
          report(node.argument);
        }
      },

      SequenceExpression(node) {
        const precedenceOfNode = precedence(node);
        node.expressions.filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);
      },

      SwitchCase(node) {
        if (node.test && hasExcessParens(node.test)) {
          report(node.test);
        }
      },

      SwitchStatement(node) {
        if (hasExcessParens(node.discriminant)) {
          report(node.discriminant);
        }
      },

      ThrowStatement(node) {
        const throwToken = sourceCode.getFirstToken(node);

        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
          report(node.argument);
        }
      },

      UnaryExpression: checkArgumentWithPrecedence,

      UpdateExpression(node) {
        if (node.prefix) {
          checkArgumentWithPrecedence(node);
        } else {
          const {
            argument
          } = node;
          const operatorToken = sourceCode.getLastToken(node);

          if (argument.loc.end.line === operatorToken.loc.start.line) {
            checkArgumentWithPrecedence(node);
          } else {
            if (hasDoubleExcessParens(argument)) {
              report(argument);
            }
          }
        }
      },

      AwaitExpression: checkArgumentWithPrecedence,

      VariableDeclarator(node) {
        if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && !(node.init.type === "Literal" && node.init.regex)) {
          report(node.init);
        }
      },

      WhileStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },

      WithStatement(node) {
        if (hasExcessParens(node.object)) {
          report(node.object);
        }
      },

      YieldExpression(node) {
        if (node.argument) {
          const yieldToken = sourceCode.getFirstToken(node);

          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
            report(node.argument);
          }
        }
      },

      ClassDeclaration: checkClass,
      ClassExpression: checkClass,
      SpreadElement: checkSpreadOperator,
      SpreadProperty: checkSpreadOperator,
      ExperimentalSpreadProperty: checkSpreadOperator,

      TemplateLiteral(node) {
        node.expressions.filter(e => e && hasExcessParens(e)).forEach(report);
      },

      AssignmentPattern(node) {
        const {
          left,
          right
        } = node;

        if (canBeAssignmentTarget(left) && hasExcessParens(left)) {
          report(left);
        }

        if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
          report(right);
        }
      }

    };
  }

};
var noExtraSemi = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary semicolons",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-extra-semi"
    },
    fixable: "code",
    schema: [],
    messages: {
      unexpected: "Unnecessary semicolon."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function report(nodeOrToken) {
      context.report({
        node: nodeOrToken,
        messageId: "unexpected",

        fix(fixer) {
          return new fixTracker(fixer, context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);
        }

      });
    }

    function checkForPartOfClassBody(firstToken) {
      for (let token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
        if (astUtils.isSemicolonToken(token)) {
          report(token);
        }
      }
    }

    return {
      EmptyStatement(node) {
        const parent = node.parent;

        if (["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"].indexOf(parent.type) === -1) {
          report(node);
        }
      },

      ClassBody(node) {
        checkForPartOfClassBody(sourceCode.getFirstToken(node, 1));
      },

      MethodDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      }

    };
  }

};
const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;

function hasFallthroughComment(node, context, fallthroughCommentPattern) {
  const sourceCode = context.getSourceCode();
  const comment = lodash__default['default'].last(sourceCode.getCommentsBefore(node));
  return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}

function isReachable(segment) {
  return segment.reachable;
}

function hasBlankLinesBetween(node, token) {
  return token.loc.start.line > node.loc.end.line + 1;
}

var noFallthrough = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow fallthrough of `case` statements",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-fallthrough"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: false
    }],
    messages: {
      case: "Expected a 'break' statement before 'case'.",
      default: "Expected a 'break' statement before 'default'."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    let currentCodePath = null;
    const sourceCode = context.getSourceCode();
    let fallthroughCase = null;
    let fallthroughCommentPattern = null;

    if (options.commentPattern) {
      fallthroughCommentPattern = new RegExp(options.commentPattern, "u");
    } else {
      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
    }

    return {
      onCodePathStart(codePath) {
        currentCodePath = codePath;
      },

      onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },

      SwitchCase(node) {
        if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
          context.report({
            messageId: node.test ? "case" : "default",
            node
          });
        }

        fallthroughCase = null;
      },

      "SwitchCase:exit"(node) {
        const nextToken = sourceCode.getTokenAfter(node);

        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash__default['default'].last(node.parent.cases) !== node) {
          fallthroughCase = node;
        }
      }

    };
  }

};
var noFloatingDecimal = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow leading or trailing decimal points in numeric literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-floating-decimal"
    },
    schema: [],
    fixable: "code",
    messages: {
      leading: "A leading decimal point can be confused with a dot.",
      trailing: "A trailing decimal point can be confused with a dot."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        if (typeof node.value === "number") {
          if (node.raw.startsWith(".")) {
            context.report({
              node,
              messageId: "leading",

              fix(fixer) {
                const tokenBefore = sourceCode.getTokenBefore(node);
                const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
                return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
              }

            });
          }

          if (node.raw.indexOf(".") === node.raw.length - 1) {
            context.report({
              node,
              messageId: "trailing",
              fix: fixer => fixer.insertTextAfter(node, "0")
            });
          }
        }
      }

    };
  }

};
var noFuncAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `function` declarations",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-func-assign"
    },
    schema: [],
    messages: {
      isAFunction: "'{{name}}' is a function."
    }
  },

  create(context) {
    function checkReference(references) {
      astUtils.getModifyingReferences(references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "isAFunction",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }

    function checkVariable(variable) {
      if (variable.defs[0].type === "FunctionName") {
        checkReference(variable.references);
      }
    }

    function checkForFunction(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
      FunctionDeclaration: checkForFunction,
      FunctionExpression: checkForFunction
    };
  }

};
var noGlobalAssign = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-global-assign"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
    }
  },

  create(context) {
    const config = context.options[0];
    const exceptions = config && config.exceptions || [];

    function checkReference(reference, index, references) {
      const identifier = reference.identifier;

      if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {
        context.report({
          node: identifier,
          messageId: "globalShouldNotBeModified",
          data: {
            name: identifier.name
          }
        });
      }
    }

    function checkVariable(variable) {
      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
        variable.references.forEach(checkReference);
      }
    }

    return {
      Program() {
        const globalScope = context.getScope();
        globalScope.variables.forEach(checkVariable);
      }

    };
  }

};
const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
const ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];

function parseOptions$1(options) {
  return {
    boolean: "boolean" in options ? options.boolean : true,
    number: "number" in options ? options.number : true,
    string: "string" in options ? options.string : true,
    allow: options.allow || []
  };
}

function isDoubleLogicalNegating(node) {
  return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
}

function isBinaryNegatingOfIndexOf(node) {
  if (node.operator !== "~") {
    return false;
  }

  const callNode = astUtils.skipChainExpression(node.argument);
  return callNode.type === "CallExpression" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);
}

function isMultiplyByOne(node) {
  return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
}

function isNumeric(node) {
  return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
}

function getNonNumericOperand(node) {
  const left = node.left,
        right = node.right;

  if (right.type !== "BinaryExpression" && !isNumeric(right)) {
    return right;
  }

  if (left.type !== "BinaryExpression" && !isNumeric(left)) {
    return left;
  }

  return null;
}

function isEmptyString(node) {
  return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
}

function isConcatWithEmptyString(node) {
  return node.operator === "+" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));
}

function isAppendEmptyString(node) {
  return node.operator === "+=" && isEmptyString(node.right);
}

function getNonEmptyOperand(node) {
  return isEmptyString(node.left) ? node.right : node.left;
}

var noImplicitCoercion = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow shorthand type conversions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implicit-coercion"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        boolean: {
          type: "boolean",
          default: true
        },
        number: {
          type: "boolean",
          default: true
        },
        string: {
          type: "boolean",
          default: true
        },
        allow: {
          type: "array",
          items: {
            enum: ALLOWABLE_OPERATORS
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      useRecommendation: "use `{{recommendation}}` instead."
    }
  },

  create(context) {
    const options = parseOptions$1(context.options[0] || {});
    const sourceCode = context.getSourceCode();

    function report(node, recommendation, shouldFix) {
      context.report({
        node,
        messageId: "useRecommendation",
        data: {
          recommendation
        },

        fix(fixer) {
          if (!shouldFix) {
            return null;
          }

          const tokenBefore = sourceCode.getTokenBefore(node);

          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
            return fixer.replaceText(node, ` ${recommendation}`);
          }

          return fixer.replaceText(node, recommendation);
        }

      });
    }

    return {
      UnaryExpression(node) {
        let operatorAllowed = options.allow.indexOf("!!") >= 0;

        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
          report(node, recommendation, true);
        }

        operatorAllowed = options.allow.indexOf("~") >= 0;

        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
          const comparison = node.argument.type === "ChainExpression" ? ">= 0" : "!== -1";
          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;
          report(node, recommendation, false);
        }

        operatorAllowed = options.allow.indexOf("+") >= 0;

        if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
          const recommendation = `Number(${sourceCode.getText(node.argument)})`;
          report(node, recommendation, true);
        }
      },

      "BinaryExpression:exit"(node) {
        let operatorAllowed = options.allow.indexOf("*") >= 0;
        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);

        if (nonNumericOperand) {
          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
          report(node, recommendation, true);
        }

        operatorAllowed = options.allow.indexOf("+") >= 0;

        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
          report(node, recommendation, true);
        }
      },

      AssignmentExpression(node) {
        const operatorAllowed = options.allow.indexOf("+") >= 0;

        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
          const code = sourceCode.getText(getNonEmptyOperand(node));
          report(node, `${code} = String(${code})`, true);
        }
      }

    };
  }

};
var noImplicitGlobals = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow declarations in the global scope",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implicit-globals"
    },
    schema: [{
      type: "object",
      properties: {
        lexicalBindings: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
      globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
      globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
      assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
      redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
    }
  },

  create(context) {
    const checkLexicalBindings = context.options[0] && context.options[0].lexicalBindings === true;

    function report(node, messageId, kind) {
      context.report({
        node,
        messageId,
        data: {
          kind
        }
      });
    }

    return {
      Program() {
        const scope = context.getScope();
        scope.variables.forEach(variable => {
          const isReadonlyEslintGlobalVariable = variable.writeable === false;
          const isWritableEslintGlobalVariable = variable.writeable === true;

          if (isWritableEslintGlobalVariable) {
            return;
          }

          variable.defs.forEach(def => {
            const defNode = def.node;

            if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
              if (isReadonlyEslintGlobalVariable) {
                report(defNode, "redeclarationOfReadonlyGlobal");
              } else {
                report(defNode, "globalNonLexicalBinding", def.type === "FunctionName" ? "function" : `'${def.parent.kind}'`);
              }
            }

            if (checkLexicalBindings) {
              if (def.type === "ClassName" || def.type === "Variable" && (def.parent.kind === "let" || def.parent.kind === "const")) {
                if (isReadonlyEslintGlobalVariable) {
                  report(defNode, "redeclarationOfReadonlyGlobal");
                } else {
                  report(defNode, "globalLexicalBinding", def.type === "ClassName" ? "class" : `'${def.parent.kind}'`);
                }
              }
            }
          });
        });
        scope.implicit.variables.forEach(variable => {
          const scopeVariable = scope.set.get(variable.name);
          let messageId;

          if (scopeVariable) {
            if (scopeVariable.writeable) {
              return;
            }

            messageId = "assignmentToReadonlyGlobal";
          } else {
            messageId = "globalVariableLeak";
          }

          variable.defs.forEach(def => {
            report(def.node, messageId);
          });
        });
      }

    };
  }

};
const {
  getStaticValue
} = eslintUtils__default['default'];
var noImpliedEval = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`-like methods",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implied-eval"
    },
    schema: [],
    messages: {
      impliedEval: "Implied eval. Consider passing a function instead of a string."
    }
  },

  create(context) {
    const GLOBAL_CANDIDATES = Object.freeze(["global", "window", "globalThis"]);
    const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;

    function isEvaluatedString(node) {
      if (node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral") {
        return true;
      }

      if (node.type === "BinaryExpression" && node.operator === "+") {
        return isEvaluatedString(node.left) || isEvaluatedString(node.right);
      }

      return false;
    }

    function reportImpliedEvalCallExpression(node) {
      const [firstArgument] = node.arguments;

      if (firstArgument) {
        const staticValue = getStaticValue(firstArgument, context.getScope());
        const isStaticString = staticValue && typeof staticValue.value === "string";
        const isString = isStaticString || isEvaluatedString(firstArgument);

        if (isString) {
          context.report({
            node,
            messageId: "impliedEval"
          });
        }
      }
    }

    function reportImpliedEvalViaGlobal(globalVar) {
      const {
        references,
        name
      } = globalVar;
      references.forEach(ref => {
        const identifier = ref.identifier;
        let node = identifier.parent;

        while (astUtils.isSpecificMemberAccess(node, null, name)) {
          node = node.parent;
        }

        if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {
          const calleeNode = node.parent.type === "ChainExpression" ? node.parent : node;
          const parent = calleeNode.parent;

          if (parent.type === "CallExpression" && parent.callee === calleeNode) {
            reportImpliedEvalCallExpression(parent);
          }
        }
      });
    }

    return {
      CallExpression(node) {
        if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {
          reportImpliedEvalCallExpression(node);
        }
      },

      "Program:exit"() {
        const globalScope = context.getScope();
        GLOBAL_CANDIDATES.map(candidate => astUtils.getVariableByName(globalScope, candidate)).filter(globalVar => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);
      }

    };
  }

};
const {
  findVariable: findVariable$3
} = eslintUtils__default['default'];
const WellKnownMutationFunctions = {
  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
};

function isAssignmentLeft(node) {
  const {
    parent
  } = node;
  return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "RestElement" || parent.type === "AssignmentPattern" && parent.left === node;
}

function isOperandOfMutationUnaryOperator(node) {
  const argumentNode = node.parent.type === "ChainExpression" ? node.parent : node;
  const {
    parent
  } = argumentNode;
  return parent.type === "UpdateExpression" && parent.argument === argumentNode || parent.type === "UnaryExpression" && parent.operator === "delete" && parent.argument === argumentNode;
}

function isIterationVariable(node) {
  const {
    parent
  } = node;
  return parent.type === "ForInStatement" && parent.left === node || parent.type === "ForOfStatement" && parent.left === node;
}

function isArgumentOfWellKnownMutationFunction(node, scope) {
  const {
    parent
  } = node;

  if (parent.type !== "CallExpression" || parent.arguments[0] !== node) {
    return false;
  }

  const callee = astUtils.skipChainExpression(parent.callee);

  if (!astUtils.isSpecificMemberAccess(callee, "Object", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, "Reflect", WellKnownMutationFunctions.Reflect)) {
    return false;
  }

  const variable = findVariable$3(scope, callee.object);
  return variable !== null && variable.scope.type === "global";
}

function isMemberWrite(id, scope) {
  const {
    parent
  } = id;
  return parent.type === "MemberExpression" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);
}

function getWriteNode(id) {
  let node = id.parent;

  while (node && node.type !== "AssignmentExpression" && node.type !== "UpdateExpression" && node.type !== "UnaryExpression" && node.type !== "CallExpression" && node.type !== "ForInStatement" && node.type !== "ForOfStatement") {
    node = node.parent;
  }

  return node || id;
}

var noImportAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assigning to imported bindings",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-import-assign"
    },
    schema: [],
    messages: {
      readonly: "'{{name}}' is read-only.",
      readonlyMember: "The members of '{{name}}' are read-only."
    }
  },

  create(context) {
    return {
      ImportDeclaration(node) {
        const scope = context.getScope();

        for (const variable of context.getDeclaredVariables(node)) {
          const shouldCheckMembers = variable.defs.some(d => d.node.type === "ImportNamespaceSpecifier");
          let prevIdNode = null;

          for (const reference of variable.references) {
            const idNode = reference.identifier;

            if (idNode === prevIdNode) {
              continue;
            }

            prevIdNode = idNode;

            if (reference.isWrite()) {
              context.report({
                node: getWriteNode(idNode),
                messageId: "readonly",
                data: {
                  name: idNode.name
                }
              });
            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {
              context.report({
                node: getWriteNode(idNode),
                messageId: "readonlyMember",
                data: {
                  name: idNode.name
                }
              });
            }
          }
        }
      }

    };
  }

};
var noInlineComments = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow inline comments after code",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-inline-comments"
    },
    schema: [{
      type: "object",
      properties: {
        ignorePattern: {
          type: "string"
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedInlineComment: "Unexpected comment inline with code."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0];
    let customIgnoreRegExp;

    if (options && options.ignorePattern) {
      customIgnoreRegExp = new RegExp(options.ignorePattern, "u");
    }

    function testCodeAroundComment(node) {
      const startLine = String(sourceCode.lines[node.loc.start.line - 1]),
            endLine = String(sourceCode.lines[node.loc.end.line - 1]),
            preamble = startLine.slice(0, node.loc.start.column).trim(),
            postamble = endLine.slice(node.loc.end.column).trim(),
            isPreambleEmpty = !preamble,
            isPostambleEmpty = !postamble;

      if (isPreambleEmpty && isPostambleEmpty) {
        return;
      }

      if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {
        return;
      }

      if ((isPreambleEmpty || preamble === "{") && (isPostambleEmpty || postamble === "}")) {
        const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);

        if (enclosingNode && enclosingNode.type === "JSXEmptyExpression") {
          return;
        }
      }

      if (astUtils.isDirectiveComment(node)) {
        return;
      }

      context.report({
        node,
        messageId: "unexpectedInlineComment"
      });
    }

    return {
      Program() {
        sourceCode.getAllComments().filter(token => token.type !== "Shebang").forEach(testCodeAroundComment);
      }

    };
  }

};
const validParent = new Set(["Program", "ExportNamedDeclaration", "ExportDefaultDeclaration"]);
const validBlockStatementParent = new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);
var noInnerDeclarations = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow variable or `function` declarations in nested blocks",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-inner-declarations"
    },
    schema: [{
      enum: ["functions", "both"]
    }],
    messages: {
      moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
    }
  },

  create(context) {
    function check(node) {
      const parent = node.parent;

      if (parent.type === "BlockStatement" && validBlockStatementParent.has(parent.parent.type)) {
        return;
      }

      if (validParent.has(parent.type)) {
        return;
      }

      const upperFunction = astUtils.getUpperFunction(parent);
      context.report({
        node,
        messageId: "moveDeclToRoot",
        data: {
          type: node.type === "FunctionDeclaration" ? "function" : "variable",
          body: upperFunction === null ? "program" : "function body"
        }
      });
    }

    return {
      FunctionDeclaration: check,

      VariableDeclaration(node) {
        if (context.options[0] === "both" && node.kind === "var") {
          check(node);
        }
      }

    };
  }

};
const RegExpValidator = regexpp__default['default'].RegExpValidator;
const validator = new RegExpValidator();
const validFlags = /[gimuys]/gu;
const undefined1 = void 0;
var noInvalidRegexp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow invalid regular expression strings in `RegExp` constructors",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-invalid-regexp"
    },
    schema: [{
      type: "object",
      properties: {
        allowConstructorFlags: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      regexMessage: "{{message}}."
    }
  },

  create(context) {
    const options = context.options[0];
    let allowedFlags = null;

    if (options && options.allowConstructorFlags) {
      const temp = options.allowConstructorFlags.join("").replace(validFlags, "");

      if (temp) {
        allowedFlags = new RegExp(`[${temp}]`, "giu");
      }
    }

    function isString(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }

    function getFlags(node) {
      if (node.arguments.length < 2) {
        return "";
      }

      if (isString(node.arguments[1])) {
        return node.arguments[1].value;
      }

      return null;
    }

    function validateRegExpPattern(pattern, uFlag) {
      try {
        validator.validatePattern(pattern, undefined1, undefined1, uFlag);
        return null;
      } catch (err) {
        return err.message;
      }
    }

    function validateRegExpFlags(flags) {
      try {
        validator.validateFlags(flags);
        return null;
      } catch {
        return `Invalid flags supplied to RegExp constructor '${flags}'`;
      }
    }

    return {
      "CallExpression, NewExpression"(node) {
        if (node.callee.type !== "Identifier" || node.callee.name !== "RegExp" || !isString(node.arguments[0])) {
          return;
        }

        const pattern = node.arguments[0].value;
        let flags = getFlags(node);

        if (flags && allowedFlags) {
          flags = flags.replace(allowedFlags, "");
        }

        const message = flags && validateRegExpFlags(flags) || (flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes("u")));

        if (message) {
          context.report({
            node,
            messageId: "regexMessage",
            data: {
              message
            }
          });
        }
      }

    };
  }

};
var noInvalidThis = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `this` keywords outside of classes or class-like objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-invalid-this"
    },
    schema: [{
      type: "object",
      properties: {
        capIsConstructor: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedThis: "Unexpected 'this'."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const capIsConstructor = options.capIsConstructor !== false;
    const stack = [],
          sourceCode = context.getSourceCode();

    stack.getCurrent = function () {
      const current = this[this.length - 1];

      if (!current.init) {
        current.init = true;
        current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode, {
          capIsConstructor
        });
      }

      return current;
    };

    function enterFunction(node) {
      stack.push({
        init: !context.getScope().isStrict,
        node,
        valid: true
      });
    }

    function exitFunction() {
      stack.pop();
    }

    return {
      Program(node) {
        const scope = context.getScope(),
              features = context.parserOptions.ecmaFeatures || {};
        stack.push({
          init: true,
          node,
          valid: !(scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
        });
      },

      "Program:exit"() {
        stack.pop();
      },

      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,

      ThisExpression(node) {
        const current = stack.getCurrent();

        if (current && !current.valid) {
          context.report({
            node,
            messageId: "unexpectedThis"
          });
        }
      }

    };
  }

};
const ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;
const IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu;
const IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mgu;
const LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
var noIrregularWhitespace = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow irregular whitespace",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-irregular-whitespace"
    },
    schema: [{
      type: "object",
      properties: {
        skipComments: {
          type: "boolean",
          default: false
        },
        skipStrings: {
          type: "boolean",
          default: true
        },
        skipTemplates: {
          type: "boolean",
          default: false
        },
        skipRegExps: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      noIrregularWhitespace: "Irregular whitespace not allowed."
    }
  },

  create(context) {
    let errors = [];
    const options = context.options[0] || {};
    const skipComments = !!options.skipComments;
    const skipStrings = options.skipStrings !== false;
    const skipRegExps = !!options.skipRegExps;
    const skipTemplates = !!options.skipTemplates;
    const sourceCode = context.getSourceCode();
    const commentNodes = sourceCode.getAllComments();

    function removeWhitespaceError(node) {
      const locStart = node.loc.start;
      const locEnd = node.loc.end;
      errors = errors.filter(({
        loc: {
          start: errorLocStart
        }
      }) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line);
    }

    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
      const shouldCheckStrings = skipStrings && typeof node.value === "string";
      const shouldCheckRegExps = skipRegExps && Boolean(node.regex);

      if (shouldCheckStrings || shouldCheckRegExps) {
        if (ALL_IRREGULARS.test(node.raw)) {
          removeWhitespaceError(node);
        }
      }
    }

    function removeInvalidNodeErrorsInTemplateLiteral(node) {
      if (typeof node.value.raw === "string") {
        if (ALL_IRREGULARS.test(node.value.raw)) {
          removeWhitespaceError(node);
        }
      }
    }

    function removeInvalidNodeErrorsInComment(node) {
      if (ALL_IRREGULARS.test(node.value)) {
        removeWhitespaceError(node);
      }
    }

    function checkForIrregularWhitespace(node) {
      const sourceLines = sourceCode.lines;
      sourceLines.forEach((sourceLine, lineIndex) => {
        const lineNumber = lineIndex + 1;
        let match;

        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
          errors.push({
            node,
            messageId: "noIrregularWhitespace",
            loc: {
              start: {
                line: lineNumber,
                column: match.index
              },
              end: {
                line: lineNumber,
                column: match.index + match[0].length
              }
            }
          });
        }
      });
    }

    function checkForIrregularLineTerminators(node) {
      const source = sourceCode.getText(),
            sourceLines = sourceCode.lines,
            linebreaks = source.match(LINE_BREAK);
      let lastLineIndex = -1,
          match;

      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
        const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
        errors.push({
          node,
          messageId: "noIrregularWhitespace",
          loc: {
            start: {
              line: lineIndex + 1,
              column: sourceLines[lineIndex].length
            },
            end: {
              line: lineIndex + 2,
              column: 0
            }
          }
        });
        lastLineIndex = lineIndex;
      }
    }

    function noop() {}

    const nodes = {};

    if (ALL_IRREGULARS.test(sourceCode.getText())) {
      nodes.Program = function (node) {
        checkForIrregularWhitespace(node);
        checkForIrregularLineTerminators(node);
      };

      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;

      nodes["Program:exit"] = function () {
        if (skipComments) {
          commentNodes.forEach(removeInvalidNodeErrorsInComment);
        }

        errors.forEach(error => context.report(error));
      };
    } else {
      nodes.Program = noop;
    }

    return nodes;
  }

};
const {
  getStaticPropertyName: getStaticPropertyName$1
} = astUtils;
var noIterator = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__iterator__` property",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-iterator"
    },
    schema: [],
    messages: {
      noIterator: "Reserved name '__iterator__'."
    }
  },

  create(context) {
    return {
      MemberExpression(node) {
        if (getStaticPropertyName$1(node) === "__iterator__") {
          context.report({
            node,
            messageId: "noIterator"
          });
        }
      }

    };
  }

};
var noLabelVar = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labels that share a name with a variable",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-label-var"
    },
    schema: [],
    messages: {
      identifierClashWithLabel: "Found identifier with same name as label."
    }
  },

  create(context) {
    function findIdentifier(scope, name) {
      return astUtils.getVariableByName(scope, name) !== null;
    }

    return {
      LabeledStatement(node) {
        const scope = context.getScope();

        if (findIdentifier(scope, node.label.name)) {
          context.report({
            node,
            messageId: "identifierClashWithLabel"
          });
        }
      }

    };
  }

};
var noLabels = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labeled statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-labels"
    },
    schema: [{
      type: "object",
      properties: {
        allowLoop: {
          type: "boolean",
          default: false
        },
        allowSwitch: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedLabel: "Unexpected labeled statement.",
      unexpectedLabelInBreak: "Unexpected label in break statement.",
      unexpectedLabelInContinue: "Unexpected label in continue statement."
    }
  },

  create(context) {
    const options = context.options[0];
    const allowLoop = options && options.allowLoop;
    const allowSwitch = options && options.allowSwitch;
    let scopeInfo = null;

    function getBodyKind(node) {
      if (astUtils.isLoop(node)) {
        return "loop";
      }

      if (node.type === "SwitchStatement") {
        return "switch";
      }

      return "other";
    }

    function isAllowed(kind) {
      switch (kind) {
        case "loop":
          return allowLoop;

        case "switch":
          return allowSwitch;

        default:
          return false;
      }
    }

    function getKind(label) {
      let info = scopeInfo;

      while (info) {
        if (info.label === label) {
          return info.kind;
        }

        info = info.upper;
      }

      return "other";
    }

    return {
      LabeledStatement(node) {
        scopeInfo = {
          label: node.label.name,
          kind: getBodyKind(node.body),
          upper: scopeInfo
        };
      },

      "LabeledStatement:exit"(node) {
        if (!isAllowed(scopeInfo.kind)) {
          context.report({
            node,
            messageId: "unexpectedLabel"
          });
        }

        scopeInfo = scopeInfo.upper;
      },

      BreakStatement(node) {
        if (node.label && !isAllowed(getKind(node.label.name))) {
          context.report({
            node,
            messageId: "unexpectedLabelInBreak"
          });
        }
      },

      ContinueStatement(node) {
        if (node.label && !isAllowed(getKind(node.label.name))) {
          context.report({
            node,
            messageId: "unexpectedLabelInContinue"
          });
        }
      }

    };
  }

};
var noLoneBlocks = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary nested blocks",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-lone-blocks"
    },
    schema: [],
    messages: {
      redundantBlock: "Block is redundant.",
      redundantNestedBlock: "Nested block is redundant."
    }
  },

  create(context) {
    const loneBlocks = [];
    let ruleDef;

    function report(node) {
      const messageId = node.parent.type === "BlockStatement" ? "redundantNestedBlock" : "redundantBlock";
      context.report({
        node,
        messageId
      });
    }

    function isLoneBlock(node) {
      return node.parent.type === "BlockStatement" || node.parent.type === "Program" || node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
    }

    function markLoneBlock() {
      if (loneBlocks.length === 0) {
        return;
      }

      const block = context.getAncestors().pop();

      if (loneBlocks[loneBlocks.length - 1] === block) {
        loneBlocks.pop();
      }
    }

    ruleDef = {
      BlockStatement(node) {
        if (isLoneBlock(node)) {
          report(node);
        }
      }

    };

    if (context.parserOptions.ecmaVersion >= 6) {
      ruleDef = {
        BlockStatement(node) {
          if (isLoneBlock(node)) {
            loneBlocks.push(node);
          }
        },

        "BlockStatement:exit"(node) {
          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
            loneBlocks.pop();
            report(node);
          } else if (node.parent.type === "BlockStatement" && node.parent.body.length === 1) {
            report(node);
          }
        }

      };

      ruleDef.VariableDeclaration = function (node) {
        if (node.kind === "let" || node.kind === "const") {
          markLoneBlock();
        }
      };

      ruleDef.FunctionDeclaration = function () {
        if (context.getScope().isStrict) {
          markLoneBlock();
        }
      };

      ruleDef.ClassDeclaration = markLoneBlock;
    }

    return ruleDef;
  }

};
var noLonelyIf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `if` statements as the only statement in `else` blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-lonely-if"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      IfStatement(node) {
        const ancestors = context.getAncestors(),
              parent = ancestors.pop(),
              grandparent = ancestors.pop();

        if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
          context.report({
            node,
            messageId: "unexpectedLonelyIf",

            fix(fixer) {
              const openingElseCurly = sourceCode.getFirstToken(parent);
              const closingElseCurly = sourceCode.getLastToken(parent);
              const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
              const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
              const lastIfToken = sourceCode.getLastToken(node.consequent);
              const sourceText = sourceCode.getText();

              if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
                return null;
              }

              if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
                return null;
              }

              return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node));
            }

          });
        }
      }

    };
  }

};

function getContainingLoopNode(node) {
  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {
    const parent = currentNode.parent;

    switch (parent.type) {
      case "WhileStatement":
      case "DoWhileStatement":
        return parent;

      case "ForStatement":
        if (parent.init !== currentNode) {
          return parent;
        }

        break;

      case "ForInStatement":
      case "ForOfStatement":
        if (parent.right !== currentNode) {
          return parent;
        }

        break;

      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration":
        return null;
    }
  }

  return null;
}

function getTopLoopNode(node, excludedNode) {
  const border = excludedNode ? excludedNode.range[1] : 0;
  let retv = node;
  let containingLoopNode = node;

  while (containingLoopNode && containingLoopNode.range[0] >= border) {
    retv = containingLoopNode;
    containingLoopNode = getContainingLoopNode(containingLoopNode);
  }

  return retv;
}

function isSafe(loopNode, reference) {
  const variable = reference.resolved;
  const definition = variable && variable.defs[0];
  const declaration = definition && definition.parent;
  const kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";

  if (kind === "const") {
    return true;
  }

  if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
    return true;
  }

  const border = getTopLoopNode(loopNode, kind === "let" ? declaration : null).range[0];
  return Boolean(variable) && variable.references.every(function (upperRef) {
    const id = upperRef.identifier;
    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
  });
}

var noLoopFunc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow function declarations that contain unsafe references inside loop statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-loop-func"
    },
    schema: [],
    messages: {
      unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
    }
  },

  create(context) {
    function checkForLoops(node) {
      const loopNode = getContainingLoopNode(node);

      if (!loopNode) {
        return;
      }

      const references = context.getScope().through;
      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);

      if (unsafeRefs.length > 0) {
        context.report({
          node,
          messageId: "unsafeRefs",
          data: {
            varNames: `'${unsafeRefs.join("', '")}'`
          }
        });
      }
    }

    return {
      ArrowFunctionExpression: checkForLoops,
      FunctionExpression: checkForLoops,
      FunctionDeclaration: checkForLoops
    };
  }

};
var noLossOfPrecision = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow literal numbers that lose precision",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-loss-of-precision"
    },
    schema: [],
    messages: {
      noLossOfPrecision: "This number literal will lose precision at runtime."
    }
  },

  create(context) {
    function isNumber(node) {
      return typeof node.value === "number";
    }

    function getRaw(node) {
      return node.raw.replace(/_/gu, "");
    }

    function isBaseTen(node) {
      return ["0x", "0X", "0b", "0B", "0o", "0O"].every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);
    }

    function notBaseTenLosesPrecision(node) {
      const rawString = getRaw(node).toUpperCase();
      let base = 0;

      if (rawString.startsWith("0B")) {
        base = 2;
      } else if (rawString.startsWith("0X")) {
        base = 16;
      } else {
        base = 8;
      }

      return !rawString.endsWith(node.value.toString(base).toUpperCase());
    }

    function addDecimalPointToNumber(stringNumber) {
      return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;
    }

    function removeLeadingZeros(numberAsString) {
      return numberAsString.replace(/^0*/u, "");
    }

    function removeTrailingZeros(numberAsString) {
      return numberAsString.replace(/0*$/u, "");
    }

    function normalizeInteger(stringInteger) {
      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));
      return {
        magnitude: stringInteger.startsWith("0") ? stringInteger.length - 2 : stringInteger.length - 1,
        coefficient: addDecimalPointToNumber(significantDigits)
      };
    }

    function normalizeFloat(stringFloat) {
      const trimmedFloat = removeLeadingZeros(stringFloat);

      if (trimmedFloat.startsWith(".")) {
        const decimalDigits = trimmedFloat.split(".").pop();
        const significantDigits = removeLeadingZeros(decimalDigits);
        return {
          magnitude: significantDigits.length - decimalDigits.length - 1,
          coefficient: addDecimalPointToNumber(significantDigits)
        };
      }

      return {
        magnitude: trimmedFloat.indexOf(".") - 1,
        coefficient: addDecimalPointToNumber(trimmedFloat.replace(".", ""))
      };
    }

    function convertNumberToScientificNotation(stringNumber) {
      const splitNumber = stringNumber.replace("E", "e").split("e");
      const originalCoefficient = splitNumber[0];
      const normalizedNumber = stringNumber.includes(".") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);
      const normalizedCoefficient = normalizedNumber.coefficient;
      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;
      return `${normalizedCoefficient}e${magnitude}`;
    }

    function baseTenLosesPrecision(node) {
      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));
      const requestedPrecision = normalizedRawNumber.split("e")[0].replace(".", "").length;

      if (requestedPrecision > 100) {
        return true;
      }

      const storedNumber = node.value.toPrecision(requestedPrecision);
      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);
      return normalizedRawNumber !== normalizedStoredNumber;
    }

    function losesPrecision(node) {
      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);
    }

    return {
      Literal(node) {
        if (node.value && isNumber(node) && losesPrecision(node)) {
          context.report({
            messageId: "noLossOfPrecision",
            node
          });
        }
      }

    };
  }

};
const MAX_ARRAY_LENGTH = 4294967295;

function normalizeIgnoreValue(x) {
  if (typeof x === "string") {
    return BigInt(x.slice(0, -1));
  }

  return x;
}

var noMagicNumbers = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow magic numbers",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-magic-numbers"
    },
    schema: [{
      type: "object",
      properties: {
        detectObjects: {
          type: "boolean",
          default: false
        },
        enforceConst: {
          type: "boolean",
          default: false
        },
        ignore: {
          type: "array",
          items: {
            anyOf: [{
              type: "number"
            }, {
              type: "string",
              pattern: "^[+-]?(?:0|[1-9][0-9]*)n$"
            }]
          },
          uniqueItems: true
        },
        ignoreArrayIndexes: {
          type: "boolean",
          default: false
        },
        ignoreDefaultValues: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      useConst: "Number constants declarations must use 'const'.",
      noMagic: "No magic number: {{raw}}."
    }
  },

  create(context) {
    const config = context.options[0] || {},
          detectObjects = !!config.detectObjects,
          enforceConst = !!config.enforceConst,
          ignore = (config.ignore || []).map(normalizeIgnoreValue),
          ignoreArrayIndexes = !!config.ignoreArrayIndexes,
          ignoreDefaultValues = !!config.ignoreDefaultValues;
    const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

    function isIgnoredValue(value) {
      return ignore.indexOf(value) !== -1;
    }

    function isDefaultValue(fullNumberNode) {
      const parent = fullNumberNode.parent;
      return parent.type === "AssignmentPattern" && parent.right === fullNumberNode;
    }

    function isParseIntRadix(fullNumberNode) {
      const parent = fullNumberNode.parent;
      return parent.type === "CallExpression" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, "parseInt") || astUtils.isSpecificMemberAccess(parent.callee, "Number", "parseInt"));
    }

    function isJSXNumber(fullNumberNode) {
      return fullNumberNode.parent.type.indexOf("JSX") === 0;
    }

    function isArrayIndex(fullNumberNode, value) {
      const parent = fullNumberNode.parent;
      return parent.type === "MemberExpression" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === "bigint") && value >= 0 && value < MAX_ARRAY_LENGTH;
    }

    return {
      Literal(node) {
        if (!astUtils.isNumericLiteral(node)) {
          return;
        }

        let fullNumberNode;
        let value;
        let raw;

        if (node.parent.type === "UnaryExpression" && node.parent.operator === "-") {
          fullNumberNode = node.parent;
          value = -node.value;
          raw = `-${node.raw}`;
        } else {
          fullNumberNode = node;
          value = node.value;
          raw = node.raw;
        }

        const parent = fullNumberNode.parent;

        if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {
          return;
        }

        if (parent.type === "VariableDeclarator") {
          if (enforceConst && parent.parent.kind !== "const") {
            context.report({
              node: fullNumberNode,
              messageId: "useConst"
            });
          }
        } else if (okTypes.indexOf(parent.type) === -1 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
          context.report({
            node: fullNumberNode,
            messageId: "noMagic",
            data: {
              raw
            }
          });
        }
      }

    };
  }

};

var isCombiningCharacter$1 = function (codePoint) {
  return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));
};

var isEmojiModifier$1 = function (code) {
  return code >= 0x1F3FB && code <= 0x1F3FF;
};

var isRegionalIndicatorSymbol$1 = function (code) {
  return code >= 0x1F1E6 && code <= 0x1F1FF;
};

var isSurrogatePair$1 = function (lead, tail) {
  return lead >= 0xD800 && lead < 0xDC00 && tail >= 0xDC00 && tail < 0xE000;
};

var unicode = {
  isCombiningCharacter: isCombiningCharacter$1,
  isEmojiModifier: isEmojiModifier$1,
  isRegionalIndicatorSymbol: isRegionalIndicatorSymbol$1,
  isSurrogatePair: isSurrogatePair$1
};
const {
  CALL: CALL$7,
  CONSTRUCT: CONSTRUCT$5,
  ReferenceTracker: ReferenceTracker$7,
  getStringIfConstant: getStringIfConstant$3
} = eslintUtils__default['default'];
const {
  RegExpParser: RegExpParser$1,
  visitRegExpAST: visitRegExpAST$1
} = regexpp__default['default'];
const {
  isCombiningCharacter,
  isEmojiModifier,
  isRegionalIndicatorSymbol,
  isSurrogatePair
} = unicode;

function* iterateCharacterSequence(nodes) {
  let seq = [];

  for (const node of nodes) {
    switch (node.type) {
      case "Character":
        seq.push(node.value);
        break;

      case "CharacterClassRange":
        seq.push(node.min.value);
        yield seq;
        seq = [node.max.value];
        break;

      case "CharacterSet":
        if (seq.length > 0) {
          yield seq;
          seq = [];
        }

        break;
    }
  }

  if (seq.length > 0) {
    yield seq;
  }
}

const hasCharacterSequence = {
  surrogatePairWithoutUFlag(chars) {
    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));
  },

  combiningClass(chars) {
    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));
  },

  emojiModifier(chars) {
    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));
  },

  regionalIndicatorSymbol(chars) {
    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));
  },

  zwj(chars) {
    const lastIndex = chars.length - 1;
    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);
  }

};
const kinds = Object.keys(hasCharacterSequence);
var noMisleadingCharacterClass = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow characters which are made with multiple code points in character class syntax",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-misleading-character-class"
    },
    schema: [],
    messages: {
      surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
      combiningClass: "Unexpected combined character in character class.",
      emojiModifier: "Unexpected modified Emoji in character class.",
      regionalIndicatorSymbol: "Unexpected national flag in character class.",
      zwj: "Unexpected joined character sequence in character class."
    }
  },

  create(context) {
    const parser = new RegExpParser$1();

    function verify(node, pattern, flags) {
      const has = {
        surrogatePairWithoutUFlag: false,
        combiningClass: false,
        variationSelector: false,
        emojiModifier: false,
        regionalIndicatorSymbol: false,
        zwj: false
      };
      let patternNode;

      try {
        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      } catch {
        return;
      }

      visitRegExpAST$1(patternNode, {
        onCharacterClassEnter(ccNode) {
          for (const chars of iterateCharacterSequence(ccNode.elements)) {
            for (const kind of kinds) {
              has[kind] = has[kind] || hasCharacterSequence[kind](chars);
            }
          }
        }

      });

      for (const kind of kinds) {
        if (has[kind]) {
          context.report({
            node,
            messageId: kind
          });
        }
      }
    }

    return {
      "Literal[regex]"(node) {
        verify(node, node.regex.pattern, node.regex.flags);
      },

      "Program"() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$7(scope);

        for (const {
          node
        } of tracker.iterateGlobalReferences({
          RegExp: {
            [CALL$7]: true,
            [CONSTRUCT$5]: true
          }
        })) {
          const [patternNode, flagsNode] = node.arguments;
          const pattern = getStringIfConstant$3(patternNode, scope);
          const flags = getStringIfConstant$3(flagsNode, scope);

          if (typeof pattern === "string") {
            verify(node, pattern, flags || "");
          }
        }
      }

    };
  }

};
const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
const LOGICAL_OPERATORS = ["&&", "||"];
const RELATIONAL_OPERATORS = ["in", "instanceof"];
const TERNARY_OPERATOR = ["?:"];
const COALESCE_OPERATOR = ["??"];
const ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);
const DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];
const TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;

function normalizeOptions$1(options = {}) {
  const hasGroups = options.groups && options.groups.length > 0;
  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
  const allowSamePrecedence = options.allowSamePrecedence !== false;
  return {
    groups,
    allowSamePrecedence
  };
}

function includesBothInAGroup(groups, left, right) {
  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);
}

function getChildNode(node) {
  return node.type === "ConditionalExpression" ? node.test : node.left;
}

var noMixedOperators = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow mixed binary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-mixed-operators"
    },
    schema: [{
      type: "object",
      properties: {
        groups: {
          type: "array",
          items: {
            type: "array",
            items: {
              enum: ALL_OPERATORS
            },
            minItems: 2,
            uniqueItems: true
          },
          uniqueItems: true
        },
        allowSamePrecedence: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = normalizeOptions$1(context.options[0]);

    function shouldIgnore(node) {
      const a = node;
      const b = node.parent;
      return !includesBothInAGroup(options.groups, a.operator, b.type === "ConditionalExpression" ? "?:" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
    }

    function isMixedWithParent(node) {
      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
    }

    function getOperatorToken(node) {
      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);
    }

    function reportBothOperators(node) {
      const parent = node.parent;
      const left = getChildNode(parent) === node ? node : parent;
      const right = getChildNode(parent) !== node ? node : parent;
      const data = {
        leftOperator: left.operator || "?:",
        rightOperator: right.operator || "?:"
      };
      context.report({
        node: left,
        loc: getOperatorToken(left).loc,
        messageId: "unexpectedMixedOperator",
        data
      });
      context.report({
        node: right,
        loc: getOperatorToken(right).loc,
        messageId: "unexpectedMixedOperator",
        data
      });
    }

    function check(node) {
      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
        reportBothOperators(node);
      }
    }

    return {
      BinaryExpression: check,
      LogicalExpression: check
    };
  }

};
var noMixedRequires = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow `require` calls to be mixed with regular variable declarations",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-mixed-requires"
    },
    schema: [{
      oneOf: [{
        type: "boolean"
      }, {
        type: "object",
        properties: {
          grouping: {
            type: "boolean"
          },
          allowCall: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      noMixRequire: "Do not mix 'require' and other declarations.",
      noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
    }
  },

  create(context) {
    const options = context.options[0];
    let grouping = false,
        allowCall = false;

    if (typeof options === "object") {
      grouping = options.grouping;
      allowCall = options.allowCall;
    } else {
      grouping = !!options;
    }

    const BUILTIN_MODULES = function () {
      return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
    }();

    const DECL_REQUIRE = "require",
          DECL_UNINITIALIZED = "uninitialized",
          DECL_OTHER = "other";
    const REQ_COMPUTED = "computed";

    function getDeclarationType(initExpression) {
      if (!initExpression) {
        return DECL_UNINITIALIZED;
      }

      if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
        return DECL_REQUIRE;
      }

      if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
        return getDeclarationType(initExpression.callee);
      }

      if (initExpression.type === "MemberExpression") {
        return getDeclarationType(initExpression.object);
      }

      return DECL_OTHER;
    }

    function inferModuleType(initExpression) {
      if (initExpression.type === "MemberExpression") {
        return inferModuleType(initExpression.object);
      }

      if (initExpression.arguments.length === 0) {
        return REQ_COMPUTED;
      }

      const arg = initExpression.arguments[0];

      if (arg.type !== "Literal" || typeof arg.value !== "string") {
        return REQ_COMPUTED;
      }

      if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
        return "core";
      }

      if (/^\.{0,2}\//u.test(arg.value)) {
        return "file";
      }

      return "module";
    }

    function isMixed(declarations) {
      const contains = {};
      declarations.forEach(declaration => {
        const type = getDeclarationType(declaration.init);
        contains[type] = true;
      });
      return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
    }

    function isGrouped(declarations) {
      const found = {};
      declarations.forEach(declaration => {
        if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
          found[inferModuleType(declaration.init)] = true;
        }
      });
      return Object.keys(found).length <= 1;
    }

    return {
      VariableDeclaration(node) {
        if (isMixed(node.declarations)) {
          context.report({
            node,
            messageId: "noMixRequire"
          });
        } else if (grouping && !isGrouped(node.declarations)) {
          context.report({
            node,
            messageId: "noMixCoreModuleFileComputed"
          });
        }
      }

    };
  }

};
var noMixedSpacesAndTabs = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow mixed spaces and tabs for indentation",
      category: "Stylistic Issues",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"
    },
    schema: [{
      enum: ["smart-tabs", true, false]
    }],
    messages: {
      mixedSpacesAndTabs: "Mixed spaces and tabs."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let smartTabs;

    switch (context.options[0]) {
      case true:
      case "smart-tabs":
        smartTabs = true;
        break;

      default:
        smartTabs = false;
    }

    return {
      "Program:exit"(node) {
        const lines = sourceCode.lines,
              comments = sourceCode.getAllComments(),
              ignoredCommentLines = new Set();
        comments.forEach(comment => {
          for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {
            ignoredCommentLines.add(i);
          }
        });
        let regex = /^(?=( +|\t+))\1(?:\t| )/u;

        if (smartTabs) {
          regex = /^(?=(\t*))\1(?=( +))\2\t/u;
        }

        lines.forEach((line, i) => {
          const match = regex.exec(line);

          if (match) {
            const lineNumber = i + 1;
            const loc = {
              start: {
                line: lineNumber,
                column: match[0].length - 2
              },
              end: {
                line: lineNumber,
                column: match[0].length
              }
            };

            if (!ignoredCommentLines.has(lineNumber)) {
              const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));

              if (!(containingNode && ["Literal", "TemplateElement"].includes(containingNode.type))) {
                context.report({
                  node,
                  loc,
                  messageId: "mixedSpacesAndTabs"
                });
              }
            }
          }
        });
      }

    };
  }

};
var noMultiAssign = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow use of chained assignment expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-assign"
    },
    schema: [],
    messages: {
      unexpectedChain: "Unexpected chained assignment."
    }
  },

  create(context) {
    return {
      AssignmentExpression(node) {
        if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
          context.report({
            node,
            messageId: "unexpectedChain"
          });
        }
      }

    };
  }

};
var noMultiSpaces = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple spaces",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          patternProperties: {
            "^([A-Z][a-z]*)+$": {
              type: "boolean"
            }
          },
          additionalProperties: false
        },
        ignoreEOLComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {};
    const ignoreEOLComments = options.ignoreEOLComments;
    const exceptions = Object.assign({
      Property: true
    }, options.exceptions);
    const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;

    function formatReportedCommentValue(token) {
      const valueLines = token.value.split("\n");
      const value = valueLines[0];
      const formattedValue = `${value.slice(0, 12)}...`;
      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
    }

    return {
      Program() {
        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
          if (leftIndex === tokensAndComments.length - 1) {
            return;
          }

          const rightToken = tokensAndComments[leftIndex + 1];

          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
            return;
          }

          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
            return;
          }

          if (hasExceptions) {
            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);

            if (parentNode && exceptions[parentNode.type]) {
              return;
            }
          }

          let displayValue;

          if (rightToken.type === "Block") {
            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
          } else if (rightToken.type === "Line") {
            displayValue = `//${formatReportedCommentValue(rightToken)}`;
          } else {
            displayValue = rightToken.value;
          }

          context.report({
            node: rightToken,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId: "multipleSpaces",
            data: {
              displayValue
            },
            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
          });
        });
      }

    };
  }

};
var noMultiStr = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiline strings",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-str"
    },
    schema: [],
    messages: {
      multilineString: "Multiline support is limited to browsers supporting ES5 only."
    }
  },

  create(context) {
    function isJSXElement(node) {
      return node.type.indexOf("JSX") === 0;
    }

    return {
      Literal(node) {
        if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
          context.report({
            node,
            messageId: "multilineString"
          });
        }
      }

    };
  }

};
var noMultipleEmptyLines = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple empty lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multiple-empty-lines"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 0
        },
        maxEOF: {
          type: "integer",
          minimum: 0
        },
        maxBOF: {
          type: "integer",
          minimum: 0
        }
      },
      required: ["max"],
      additionalProperties: false
    }],
    messages: {
      blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
      blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
      consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
    }
  },

  create(context) {
    let max = 2,
        maxEOF = max,
        maxBOF = max;

    if (context.options.length) {
      max = context.options[0].max;
      maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
      maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
    }

    const sourceCode = context.getSourceCode();
    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
    const templateLiteralLines = new Set();
    return {
      TemplateLiteral(node) {
        node.quasis.forEach(literalPart => {
          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
            templateLiteralLines.add(ignoredLine);
          }
        });
      },

      "Program:exit"(node) {
        return allLines.reduce((nonEmptyLineNumbers, line, index) => {
          if (line.trim() || templateLiteralLines.has(index + 1)) {
            nonEmptyLineNumbers.push(index + 1);
          }

          return nonEmptyLineNumbers;
        }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {
          let messageId, maxAllowed;

          if (lastLineNumber === 0) {
            messageId = "blankBeginningOfFile";
            maxAllowed = maxBOF;
          } else if (lineNumber === allLines.length + 1) {
            messageId = "blankEndOfFile";
            maxAllowed = maxEOF;
          } else {
            messageId = "consecutiveBlank";
            maxAllowed = max;
          }

          if (lineNumber - lastLineNumber - 1 > maxAllowed) {
            context.report({
              node,
              loc: {
                start: {
                  line: lastLineNumber + maxAllowed + 1,
                  column: 0
                },
                end: {
                  line: lineNumber,
                  column: 0
                }
              },
              messageId,
              data: {
                max: maxAllowed,
                pluralizedLines: maxAllowed === 1 ? "line" : "lines"
              },

              fix(fixer) {
                const rangeStart = sourceCode.getIndexFromLoc({
                  line: lastLineNumber + 1,
                  column: 0
                });
                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({
                  line: lineNumberAfterRemovedLines,
                  column: 0
                }) : sourceCode.text.length;
                return fixer.removeRange([rangeStart, rangeEnd]);
              }

            });
          }

          return lineNumber;
        }, 0);
      }

    };
  }

};
var noNativeReassign = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-native-reassign"
    },
    deprecated: true,
    replacedBy: ["no-global-assign"],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      nativeReassign: "Read-only global '{{name}}' should not be modified."
    }
  },

  create(context) {
    const config = context.options[0];
    const exceptions = config && config.exceptions || [];

    function checkReference(reference, index, references) {
      const identifier = reference.identifier;

      if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {
        context.report({
          node: identifier,
          messageId: "nativeReassign",
          data: identifier
        });
      }
    }

    function checkVariable(variable) {
      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
        variable.references.forEach(checkReference);
      }
    }

    return {
      Program() {
        const globalScope = context.getScope();
        globalScope.variables.forEach(checkVariable);
      }

    };
  }

};
var noNegatedCondition = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow negated conditions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-negated-condition"
    },
    schema: [],
    messages: {
      unexpectedNegated: "Unexpected negated condition."
    }
  },

  create(context) {
    function hasElseWithoutCondition(node) {
      return node.alternate && node.alternate.type !== "IfStatement";
    }

    function isNegatedUnaryExpression(test) {
      return test.type === "UnaryExpression" && test.operator === "!";
    }

    function isNegatedBinaryExpression(test) {
      return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
    }

    function isNegatedIf(node) {
      return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
    }

    return {
      IfStatement(node) {
        if (!hasElseWithoutCondition(node)) {
          return;
        }

        if (isNegatedIf(node)) {
          context.report({
            node,
            messageId: "unexpectedNegated"
          });
        }
      },

      ConditionalExpression(node) {
        if (isNegatedIf(node)) {
          context.report({
            node,
            messageId: "unexpectedNegated"
          });
        }
      }

    };
  }

};
var noNegatedInLhs = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand in `in` expressions",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-negated-in-lhs"
    },
    replacedBy: ["no-unsafe-negation"],
    deprecated: true,
    schema: [],
    messages: {
      negatedLHS: "The 'in' expression's left operand is negated."
    }
  },

  create(context) {
    return {
      BinaryExpression(node) {
        if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
          context.report({
            node,
            messageId: "negatedLHS"
          });
        }
      }

    };
  }

};
var noNestedTernary = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow nested ternary expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-nested-ternary"
    },
    schema: [],
    messages: {
      noNestedTernary: "Do not nest ternary expressions."
    }
  },

  create(context) {
    return {
      ConditionalExpression(node) {
        if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
          context.report({
            node,
            messageId: "noNestedTernary"
          });
        }
      }

    };
  }

};
var noNewFunc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `Function` object",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-func"
    },
    schema: [],
    messages: {
      noFunctionConstructor: "The Function constructor is eval."
    }
  },

  create(context) {
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const variable = globalScope.set.get("Function");

        if (variable && variable.defs.length === 0) {
          variable.references.forEach(ref => {
            const node = ref.identifier;
            const {
              parent
            } = node;

            if (parent && (parent.type === "NewExpression" || parent.type === "CallExpression") && node === parent.callee) {
              context.report({
                node: parent,
                messageId: "noFunctionConstructor"
              });
            }
          });
        }
      }

    };
  }

};
var noNewObject = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Object` constructors",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-object"
    },
    schema: [],
    messages: {
      preferLiteral: "The object literal notation {} is preferrable."
    }
  },

  create(context) {
    return {
      NewExpression(node) {
        const variable = astUtils.getVariableByName(context.getScope(), node.callee.name);

        if (variable && variable.identifiers.length > 0) {
          return;
        }

        if (node.callee.name === "Object") {
          context.report({
            node,
            messageId: "preferLiteral"
          });
        }
      }

    };
  }

};
var noNewRequire = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with calls to `require`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-require"
    },
    schema: [],
    messages: {
      noNewRequire: "Unexpected use of new with require."
    }
  },

  create(context) {
    return {
      NewExpression(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "require") {
          context.report({
            node,
            messageId: "noNewRequire"
          });
        }
      }

    };
  }

};
var noNewSymbol = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `new` operators with the `Symbol` object",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-new-symbol"
    },
    schema: [],
    messages: {
      noNewSymbol: "`Symbol` cannot be called as a constructor."
    }
  },

  create(context) {
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const variable = globalScope.set.get("Symbol");

        if (variable && variable.defs.length === 0) {
          variable.references.forEach(ref => {
            const node = ref.identifier;
            const parent = node.parent;

            if (parent && parent.type === "NewExpression" && parent.callee === node) {
              context.report({
                node,
                messageId: "noNewSymbol"
              });
            }
          });
        }
      }

    };
  }

};
var noNewWrappers = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-wrappers"
    },
    schema: [],
    messages: {
      noConstructor: "Do not use {{fn}} as a constructor."
    }
  },

  create(context) {
    return {
      NewExpression(node) {
        if (["String", "Number", "Boolean"].indexOf(node.callee.name) > -1) {
          context.report({
            node,
            messageId: "noConstructor",
            data: {
              fn: node.callee.name
            }
          });
        }
      }

    };
  }

};
var noNew = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators outside of assignments or comparisons",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new"
    },
    schema: [],
    messages: {
      noNewStatement: "Do not use 'new' for side effects."
    }
  },

  create(context) {
    return {
      "ExpressionStatement > NewExpression"(node) {
        context.report({
          node: node.parent,
          messageId: "noNewStatement"
        });
      }

    };
  }

};
const QUICK_TEST_REGEX = /\\[89]/u;

function getUnicodeEscape(character) {
  return `\\u${character.charCodeAt(0).toString(16).padStart(4, "0")}`;
}

var noNonoctalDecimalEscape = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `\\8` and `\\9` escape sequences in string literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-nonoctal-decimal-escape",
      suggestion: true
    },
    schema: [],
    messages: {
      decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
      refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
      escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function createSuggestion(messageId, range, replacement) {
      return {
        messageId,
        data: {
          original: sourceCode.getText().slice(...range),
          replacement
        },

        fix(fixer) {
          return fixer.replaceTextRange(range, replacement);
        }

      };
    }

    return {
      Literal(node) {
        if (typeof node.value !== "string") {
          return;
        }

        if (!QUICK_TEST_REGEX.test(node.raw)) {
          return;
        }

        let match;

        while (match = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy.exec(node.raw)) {
          const {
            previousEscape,
            decimalEscape
          } = match.groups;
          const decimalEscapeRangeEnd = node.range[0] + match.index + match[0].length;
          const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;
          const decimalEscapeRange = [decimalEscapeRangeStart, decimalEscapeRangeEnd];
          const suggest = [];

          if (previousEscape === "\\0") {
            suggest.push(createSuggestion("refactor", [decimalEscapeRangeStart - previousEscape.length, decimalEscapeRangeEnd], `${getUnicodeEscape("\0")}${decimalEscape[1]}`), createSuggestion("refactor", decimalEscapeRange, getUnicodeEscape(decimalEscape[1])));
          } else {
            suggest.push(createSuggestion("refactor", decimalEscapeRange, decimalEscape[1]));
          }

          suggest.push(createSuggestion("escapeBackslash", decimalEscapeRange, `\\${decimalEscape}`));
          context.report({
            node,
            loc: {
              start: sourceCode.getLocFromIndex(decimalEscapeRangeStart),
              end: sourceCode.getLocFromIndex(decimalEscapeRangeEnd)
            },
            messageId: "decimalEscape",
            data: {
              decimalEscape
            },
            suggest
          });
        }
      }

    };
  }

};
const {
  CALL: CALL$6,
  CONSTRUCT: CONSTRUCT$4,
  ReferenceTracker: ReferenceTracker$6
} = eslintUtils__default['default'];
const getPropertyName$1 = astUtils.getStaticPropertyName;
const nonCallableGlobals = ["Atomics", "JSON", "Math", "Reflect"];

function getReportNodeName(node) {
  if (node.type === "ChainExpression") {
    return getReportNodeName(node.expression);
  }

  if (node.type === "MemberExpression") {
    return getPropertyName$1(node);
  }

  return node.name;
}

var noObjCalls = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling global object properties as functions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-obj-calls"
    },
    schema: [],
    messages: {
      unexpectedCall: "'{{name}}' is not a function.",
      unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
    }
  },

  create(context) {
    return {
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$6(scope);
        const traceMap = {};

        for (const g of nonCallableGlobals) {
          traceMap[g] = {
            [CALL$6]: true,
            [CONSTRUCT$4]: true
          };
        }

        for (const {
          node,
          path
        } of tracker.iterateGlobalReferences(traceMap)) {
          const name = getReportNodeName(node.callee);
          const ref = path[0];
          const messageId = name === ref ? "unexpectedCall" : "unexpectedRefCall";
          context.report({
            node,
            messageId,
            data: {
              name,
              ref
            }
          });
        }
      }

    };
  }

};
var noOctalEscape = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal escape sequences in string literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-octal-escape"
    },
    schema: [],
    messages: {
      octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
    }
  },

  create(context) {
    return {
      Literal(node) {
        if (typeof node.value !== "string") {
          return;
        }

        const match = node.raw.match(/^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su);

        if (match) {
          context.report({
            node,
            messageId: "octalEscapeSequence",
            data: {
              sequence: match[1]
            }
          });
        }
      }

    };
  }

};
var noOctal = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal literals",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-octal"
    },
    schema: [],
    messages: {
      noOcatal: "Octal literals should not be used."
    }
  },

  create(context) {
    return {
      Literal(node) {
        if (typeof node.value === "number" && /^0[0-9]/u.test(node.raw)) {
          context.report({
            node,
            messageId: "noOcatal"
          });
        }
      }

    };
  }

};
const stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
var noParamReassign = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow reassigning `function` parameters",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-param-reassign"
    },
    schema: [{
      oneOf: [{
        type: "object",
        properties: {
          props: {
            enum: [false]
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          props: {
            enum: [true]
          },
          ignorePropertyModificationsFor: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          },
          ignorePropertyModificationsForRegex: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
      assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
    }
  },

  create(context) {
    const props = context.options[0] && context.options[0].props;
    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];

    function isModifyingProp(reference) {
      let node = reference.identifier;
      let parent = node.parent;

      while (parent && (!stopNodePattern.test(parent.type) || parent.type === "ForInStatement" || parent.type === "ForOfStatement")) {
        switch (parent.type) {
          case "AssignmentExpression":
            return parent.left === node;

          case "UpdateExpression":
            return true;

          case "UnaryExpression":
            if (parent.operator === "delete") {
              return true;
            }

            break;

          case "ForInStatement":
          case "ForOfStatement":
            if (parent.left === node) {
              return true;
            }

            return false;

          case "CallExpression":
            if (parent.callee !== node) {
              return false;
            }

            break;

          case "MemberExpression":
            if (parent.property === node) {
              return false;
            }

            break;

          case "Property":
            if (parent.key === node) {
              return false;
            }

            break;

          case "ConditionalExpression":
            if (parent.test === node) {
              return false;
            }

            break;
        }

        node = parent;
        parent = node.parent;
      }

      return false;
    }

    function isIgnoredPropertyAssignment(identifierName) {
      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, "u").test(identifierName));
    }

    function checkReference(reference, index, references) {
      const identifier = reference.identifier;

      if (identifier && !reference.init && (index === 0 || references[index - 1].identifier !== identifier)) {
        if (reference.isWrite()) {
          context.report({
            node: identifier,
            messageId: "assignmentToFunctionParam",
            data: {
              name: identifier.name
            }
          });
        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {
          context.report({
            node: identifier,
            messageId: "assignmentToFunctionParamProp",
            data: {
              name: identifier.name
            }
          });
        }
      }
    }

    function checkVariable(variable) {
      if (variable.defs[0].type === "Parameter") {
        variable.references.forEach(checkReference);
      }
    }

    function checkForFunction(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
      "FunctionDeclaration:exit": checkForFunction,
      "FunctionExpression:exit": checkForFunction,
      "ArrowFunctionExpression:exit": checkForFunction
    };
  }

};
var noPathConcat = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow string concatenation with `__dirname` and `__filename`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-path-concat"
    },
    schema: [],
    messages: {
      usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
    }
  },

  create(context) {
    const MATCHER = /^__(?:dir|file)name$/u;
    return {
      BinaryExpression(node) {
        const left = node.left,
              right = node.right;

        if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {
          context.report({
            node,
            messageId: "usePathFunctions"
          });
        }
      }

    };
  }

};

function isForStatementUpdate(node) {
  const parent = node.parent;
  return parent.type === "ForStatement" && parent.update === node;
}

function isForLoopAfterthought(node) {
  const parent = node.parent;

  if (parent.type === "SequenceExpression") {
    return isForLoopAfterthought(parent);
  }

  return isForStatementUpdate(node);
}

var noPlusplus = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the unary operators `++` and `--`",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-plusplus"
    },
    schema: [{
      type: "object",
      properties: {
        allowForLoopAfterthoughts: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedUnaryOp: "Unary operator '{{operator}}' used."
    }
  },

  create(context) {
    const config = context.options[0];
    let allowForLoopAfterthoughts = false;

    if (typeof config === "object") {
      allowForLoopAfterthoughts = config.allowForLoopAfterthoughts === true;
    }

    return {
      UpdateExpression(node) {
        if (allowForLoopAfterthoughts && isForLoopAfterthought(node)) {
          return;
        }

        context.report({
          node,
          messageId: "unexpectedUnaryOp",
          data: {
            operator: node.operator
          }
        });
      }

    };
  }

};
var noProcessEnv = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.env`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-process-env"
    },
    schema: [],
    messages: {
      unexpectedProcessEnv: "Unexpected use of process.env."
    }
  },

  create(context) {
    return {
      MemberExpression(node) {
        const objectName = node.object.name,
              propertyName = node.property.name;

        if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
          context.report({
            node,
            messageId: "unexpectedProcessEnv"
          });
        }
      }

    };
  }

};
var noProcessExit = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.exit()`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-process-exit"
    },
    schema: [],
    messages: {
      noProcessExit: "Don't use process.exit(); throw an error instead."
    }
  },

  create(context) {
    return {
      "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node) {
        context.report({
          node: node.parent,
          messageId: "noProcessExit"
        });
      }

    };
  }

};
const {
  findVariable: findVariable$2
} = eslintUtils__default['default'];
const functionTypesToCheck = new Set(["ArrowFunctionExpression", "FunctionExpression"]);

function isGlobalReference$1(node, scope) {
  const variable = findVariable$2(scope, node);
  return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
}

function getOuterScope$1(scope) {
  const upper = scope.upper;

  if (upper.type === "function-expression-name") {
    return upper.upper;
  }

  return upper;
}

function isPromiseExecutor(node, scope) {
  const parent = node.parent;
  return parent.type === "NewExpression" && parent.arguments[0] === node && parent.callee.type === "Identifier" && parent.callee.name === "Promise" && isGlobalReference$1(parent.callee, getOuterScope$1(scope));
}

var noPromiseExecutorReturn = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning values from Promise executor functions",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-promise-executor-return"
    },
    schema: [],
    messages: {
      returnsValue: "Return values from promise executor functions cannot be read."
    }
  },

  create(context) {
    let funcInfo = null;

    function report(node) {
      context.report({
        node,
        messageId: "returnsValue"
      });
    }

    return {
      onCodePathStart(_, node) {
        funcInfo = {
          upper: funcInfo,
          shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, context.getScope())
        };

        if (funcInfo.shouldCheck && node.type === "ArrowFunctionExpression" && node.expression) {
          report(node.body);
        }
      },

      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },

      ReturnStatement(node) {
        if (funcInfo.shouldCheck && node.argument) {
          report(node);
        }
      }

    };
  }

};
const {
  getStaticPropertyName
} = astUtils;
var noProto = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__proto__` property",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-proto"
    },
    schema: [],
    messages: {
      unexpectedProto: "The '__proto__' property is deprecated."
    }
  },

  create(context) {
    return {
      MemberExpression(node) {
        if (getStaticPropertyName(node) === "__proto__") {
          context.report({
            node,
            messageId: "unexpectedProto"
          });
        }
      }

    };
  }

};
var noPrototypeBuiltins = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling some `Object.prototype` methods directly on objects",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-prototype-builtins"
    },
    schema: [],
    messages: {
      prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object."
    }
  },

  create(context) {
    const DISALLOWED_PROPS = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];
    return {
      CallExpression: function (node) {
        const callee = astUtils.skipChainExpression(node.callee);

        if (callee.type !== "MemberExpression") {
          return;
        }

        const propName = astUtils.getStaticPropertyName(callee);

        if (propName !== null && DISALLOWED_PROPS.indexOf(propName) > -1) {
          context.report({
            messageId: "prototypeBuildIn",
            loc: callee.property.loc,
            data: {
              prop: propName
            },
            node
          });
        }
      }
    };
  }

};
var noRedeclare = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable redeclaration",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-redeclare"
    },
    messages: {
      redeclared: "'{{id}}' is already defined.",
      redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
      redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }]
  },

  create(context) {
    const options = {
      builtinGlobals: Boolean(context.options.length === 0 || context.options[0].builtinGlobals)
    };
    const sourceCode = context.getSourceCode();

    function* iterateDeclarations(variable) {
      if (options.builtinGlobals && (variable.eslintImplicitGlobalSetting === "readonly" || variable.eslintImplicitGlobalSetting === "writable")) {
        yield {
          type: "builtin"
        };
      }

      for (const id of variable.identifiers) {
        yield {
          type: "syntax",
          node: id,
          loc: id.loc
        };
      }

      if (variable.eslintExplicitGlobalComments) {
        for (const comment of variable.eslintExplicitGlobalComments) {
          yield {
            type: "comment",
            node: comment,
            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, comment, variable.name)
          };
        }
      }
    }

    function findVariablesInScope(scope) {
      for (const variable of scope.variables) {
        const [declaration, ...extraDeclarations] = iterateDeclarations(variable);

        if (extraDeclarations.length === 0) {
          continue;
        }

        const detailMessageId = declaration.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax";
        const data = {
          id: variable.name
        };

        for (const {
          type,
          node,
          loc
        } of extraDeclarations) {
          const messageId = type === declaration.type ? "redeclared" : detailMessageId;
          context.report({
            node,
            loc,
            messageId,
            data
          });
        }
      }
    }

    function checkForBlock(node) {
      const scope = context.getScope();

      if (scope.block === node) {
        findVariablesInScope(scope);
      }
    }

    return {
      Program() {
        const scope = context.getScope();
        findVariablesInScope(scope);

        if (scope.type === "global" && scope.childScopes[0] && scope.block === scope.childScopes[0].block) {
          findVariablesInScope(scope.childScopes[0]);
        }
      },

      FunctionDeclaration: checkForBlock,
      FunctionExpression: checkForBlock,
      ArrowFunctionExpression: checkForBlock,
      BlockStatement: checkForBlock,
      ForStatement: checkForBlock,
      ForInStatement: checkForBlock,
      ForOfStatement: checkForBlock,
      SwitchStatement: checkForBlock
    };
  }

};
const regExpParser = new regexpp__default['default'].RegExpParser();
const DOUBLE_SPACE = / {2}/u;

function isString(node) {
  return node && node.type === "Literal" && typeof node.value === "string";
}

var noRegexSpaces = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiple spaces in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-regex-spaces"
    },
    schema: [],
    fixable: "code",
    messages: {
      multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
    }
  },

  create(context) {
    function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {
      if (!DOUBLE_SPACE.test(rawPattern)) {
        return;
      }

      const characterClassNodes = [];
      let regExpAST;

      try {
        regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      } catch {
        return;
      }

      regexpp__default['default'].visitRegExpAST(regExpAST, {
        onCharacterClassEnter(ccNode) {
          characterClassNodes.push(ccNode);
        }

      });
      let match;

      while (match = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu.exec(pattern)) {
        const {
          1: {
            length
          },
          index
        } = match;

        if (characterClassNodes.every(({
          start,
          end
        }) => index < start || end <= index)) {
          context.report({
            node: nodeToReport,
            messageId: "multipleSpaces",
            data: {
              length
            },

            fix(fixer) {
              if (pattern !== rawPattern) {
                return null;
              }

              return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], ` {${length}}`);
            }

          });
          return;
        }
      }
    }

    function checkFunction(node) {
      const scope = context.getScope();
      const regExpVar = astUtils.getVariableByName(scope, "RegExp");
      const shadowed = regExpVar && regExpVar.defs.length > 0;
      const patternNode = node.arguments[0];
      const flagsNode = node.arguments[1];

      if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
        const pattern = patternNode.value;
        const rawPattern = patternNode.raw.slice(1, -1);
        const rawPatternStartRange = patternNode.range[0] + 1;
        const flags = isString(flagsNode) ? flagsNode.value : "";
        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
      }
    }

    return {
      Literal: function (node) {
        if (node.regex) {
          const pattern = node.regex.pattern;
          const rawPattern = node.raw.slice(1, node.raw.lastIndexOf("/"));
          const rawPatternStartRange = node.range[0] + 1;
          const flags = node.regex.flags;
          checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
        }
      },
      CallExpression: checkFunction,
      NewExpression: checkFunction
    };
  }

};
var noRestrictedExports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified names in exports",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-exports"
    },
    schema: [{
      type: "object",
      properties: {
        restrictedNamedExports: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      restrictedNamed: "'{{name}}' is restricted from being used as an exported name."
    }
  },

  create(context) {
    const restrictedNames = new Set(context.options[0] && context.options[0].restrictedNamedExports);

    function checkExportedName(node) {
      const name = node.name;

      if (restrictedNames.has(name)) {
        context.report({
          node,
          messageId: "restrictedNamed",
          data: {
            name
          }
        });
      }
    }

    return {
      ExportAllDeclaration(node) {
        if (node.exported) {
          checkExportedName(node.exported);
        }
      },

      ExportNamedDeclaration(node) {
        const declaration = node.declaration;

        if (declaration) {
          if (declaration.type === "FunctionDeclaration" || declaration.type === "ClassDeclaration") {
            checkExportedName(declaration.id);
          } else if (declaration.type === "VariableDeclaration") {
            context.getDeclaredVariables(declaration).map(v => v.defs.find(d => d.parent === declaration)).map(d => d.name).forEach(checkExportedName);
          }
        } else {
          node.specifiers.map(s => s.exported).forEach(checkExportedName);
        }
      }

    };
  }

};
var noRestrictedGlobals = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified global variables",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-globals"
    },
    schema: {
      type: "array",
      items: {
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["name"],
          additionalProperties: false
        }]
      },
      uniqueItems: true,
      minItems: 0
    },
    messages: {
      defaultMessage: "Unexpected use of '{{name}}'.",
      customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
    }
  },

  create(context) {
    if (context.options.length === 0) {
      return {};
    }

    const restrictedGlobalMessages = context.options.reduce((memo, option) => {
      if (typeof option === "string") {
        memo[option] = null;
      } else {
        memo[option.name] = option.message;
      }

      return memo;
    }, {});

    function reportReference(reference) {
      const name = reference.identifier.name,
            customMessage = restrictedGlobalMessages[name],
            messageId = customMessage ? "customMessage" : "defaultMessage";
      context.report({
        node: reference.identifier,
        messageId,
        data: {
          name,
          customMessage
        }
      });
    }

    function isRestricted(name) {
      return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);
    }

    return {
      Program() {
        const scope = context.getScope();
        scope.variables.forEach(variable => {
          if (!variable.defs.length && isRestricted(variable.name)) {
            variable.references.forEach(reportReference);
          }
        });
        scope.through.forEach(reference => {
          if (isRestricted(reference.identifier.name)) {
            reportReference(reference);
          }
        });
      }

    };
  }

};
const arrayOfStrings$1 = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: true
};
const arrayOfStringsOrObjects$1 = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        },
        importNames: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false,
      required: ["name"]
    }]
  },
  uniqueItems: true
};
var noRestrictedImports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `import`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-imports"
    },
    messages: {
      path: "'{{importSource}}' import is restricted from being used.",
      pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
      patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
      everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
      everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",
      importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
      importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
    },
    schema: {
      anyOf: [arrayOfStringsOrObjects$1, {
        type: "array",
        items: [{
          type: "object",
          properties: {
            paths: arrayOfStringsOrObjects$1,
            patterns: arrayOfStrings$1
          },
          additionalProperties: false
        }],
        additionalItems: false
      }]
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = Array.isArray(context.options) ? context.options : [];
    const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
      return {};
    }

    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {
      if (typeof importSource === "string") {
        memo[importSource] = {
          message: null
        };
      } else {
        memo[importSource.name] = {
          message: importSource.message,
          importNames: importSource.importNames
        };
      }

      return memo;
    }, {});
    const restrictedPatternsMatcher = ignore__default['default']().add(restrictedPatterns);

    function checkRestrictedPathAndReport(importSource, importNames, node) {
      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
        return;
      }

      const customMessage = restrictedPathMessages[importSource].message;
      const restrictedImportNames = restrictedPathMessages[importSource].importNames;

      if (restrictedImportNames) {
        if (importNames.has("*")) {
          const specifierData = importNames.get("*")[0];
          context.report({
            node,
            messageId: customMessage ? "everythingWithCustomMessage" : "everything",
            loc: specifierData.loc,
            data: {
              importSource,
              importNames: restrictedImportNames,
              customMessage
            }
          });
        }

        restrictedImportNames.forEach(importName => {
          if (importNames.has(importName)) {
            const specifiers = importNames.get(importName);
            specifiers.forEach(specifier => {
              context.report({
                node,
                messageId: customMessage ? "importNameWithCustomMessage" : "importName",
                loc: specifier.loc,
                data: {
                  importSource,
                  customMessage,
                  importName
                }
              });
            });
          }
        });
      } else {
        context.report({
          node,
          messageId: customMessage ? "pathWithCustomMessage" : "path",
          data: {
            importSource,
            customMessage
          }
        });
      }
    }

    function reportPathForPatterns(node) {
      const importSource = node.source.value.trim();
      context.report({
        node,
        messageId: "patterns",
        data: {
          importSource
        }
      });
    }

    function isRestrictedPattern(importSource) {
      return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
    }

    function checkNode(node) {
      const importSource = node.source.value.trim();
      const importNames = new Map();

      if (node.type === "ExportAllDeclaration") {
        const starToken = sourceCode.getFirstToken(node, 1);
        importNames.set("*", [{
          loc: starToken.loc
        }]);
      } else if (node.specifiers) {
        for (const specifier of node.specifiers) {
          let name;
          const specifierData = {
            loc: specifier.loc
          };

          if (specifier.type === "ImportDefaultSpecifier") {
            name = "default";
          } else if (specifier.type === "ImportNamespaceSpecifier") {
            name = "*";
          } else if (specifier.imported) {
            name = specifier.imported.name;
          } else if (specifier.local) {
            name = specifier.local.name;
          }

          if (name) {
            if (importNames.has(name)) {
              importNames.get(name).push(specifierData);
            } else {
              importNames.set(name, [specifierData]);
            }
          }
        }
      }

      checkRestrictedPathAndReport(importSource, importNames, node);

      if (isRestrictedPattern(importSource)) {
        reportPathForPatterns(node);
      }
    }

    return {
      ImportDeclaration: checkNode,

      ExportNamedDeclaration(node) {
        if (node.source) {
          checkNode(node);
        }
      },

      ExportAllDeclaration: checkNode
    };
  }

};
const arrayOfStrings = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: true
};
const arrayOfStringsOrObjects = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        }
      },
      additionalProperties: false,
      required: ["name"]
    }]
  },
  uniqueItems: true
};
var noRestrictedModules = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `require`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-modules"
    },
    schema: {
      anyOf: [arrayOfStringsOrObjects, {
        type: "array",
        items: {
          type: "object",
          properties: {
            paths: arrayOfStringsOrObjects,
            patterns: arrayOfStrings
          },
          additionalProperties: false
        },
        additionalItems: false
      }]
    },
    messages: {
      defaultMessage: "'{{name}}' module is restricted from being used.",
      customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}",
      patternMessage: "'{{name}}' module is restricted from being used by a pattern."
    }
  },

  create(context) {
    const options = Array.isArray(context.options) ? context.options : [];
    const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
    const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {
      if (typeof importName === "string") {
        memo[importName] = null;
      } else {
        memo[importName.name] = importName.message;
      }

      return memo;
    }, {});

    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
      return {};
    }

    const ig = ignore__default['default']().add(restrictedPatterns);

    function isStringLiteral(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }

    function isStaticTemplateLiteral(node) {
      return node && node.type === "TemplateLiteral" && node.expressions.length === 0;
    }

    function isRequireCall(node) {
      return node.callee.type === "Identifier" && node.callee.name === "require";
    }

    function getFirstArgumentString(node) {
      if (isStringLiteral(node)) {
        return node.value.trim();
      }

      if (isStaticTemplateLiteral(node)) {
        return node.quasis[0].value.cooked.trim();
      }

      return null;
    }

    function reportPath(node, name) {
      const customMessage = restrictedPathMessages[name];
      const messageId = customMessage ? "customMessage" : "defaultMessage";
      context.report({
        node,
        messageId,
        data: {
          name,
          customMessage
        }
      });
    }

    function isRestrictedPath(name) {
      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
    }

    return {
      CallExpression(node) {
        if (isRequireCall(node)) {
          if (node.arguments.length) {
            const name = getFirstArgumentString(node.arguments[0]);

            if (name) {
              if (isRestrictedPath(name)) {
                reportPath(node, name);
              }

              if (restrictedPatterns.length > 0 && ig.ignores(name)) {
                context.report({
                  node,
                  messageId: "patternMessage",
                  data: {
                    name
                  }
                });
              }
            }
          }
        }
      }

    };
  }

};
var noRestrictedProperties = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow certain properties on certain objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-properties"
    },
    schema: {
      type: "array",
      items: {
        anyOf: [{
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["object"]
        }, {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["property"]
        }]
      },
      uniqueItems: true
    },
    messages: {
      restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
      restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}"
    }
  },

  create(context) {
    const restrictedCalls = context.options;

    if (restrictedCalls.length === 0) {
      return {};
    }

    const restrictedProperties = new Map();
    const globallyRestrictedObjects = new Map();
    const globallyRestrictedProperties = new Map();
    restrictedCalls.forEach(option => {
      const objectName = option.object;
      const propertyName = option.property;

      if (typeof objectName === "undefined") {
        globallyRestrictedProperties.set(propertyName, {
          message: option.message
        });
      } else if (typeof propertyName === "undefined") {
        globallyRestrictedObjects.set(objectName, {
          message: option.message
        });
      } else {
        if (!restrictedProperties.has(objectName)) {
          restrictedProperties.set(objectName, new Map());
        }

        restrictedProperties.get(objectName).set(propertyName, {
          message: option.message
        });
      }
    });

    function checkPropertyAccess(node, objectName, propertyName) {
      if (propertyName === null) {
        return;
      }

      const matchedObject = restrictedProperties.get(objectName);
      const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
      const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);

      if (matchedObjectProperty) {
        const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
        context.report({
          node,
          messageId: "restrictedObjectProperty",
          data: {
            objectName,
            propertyName,
            message
          }
        });
      } else if (globalMatchedProperty) {
        const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
        context.report({
          node,
          messageId: "restrictedProperty",
          data: {
            propertyName,
            message
          }
        });
      }
    }

    function checkDestructuringAssignment(node) {
      if (node.right.type === "Identifier") {
        const objectName = node.right.name;

        if (node.left.type === "ObjectPattern") {
          node.left.properties.forEach(property => {
            checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
          });
        }
      }
    }

    return {
      MemberExpression(node) {
        checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
      },

      VariableDeclarator(node) {
        if (node.init && node.init.type === "Identifier") {
          const objectName = node.init.name;

          if (node.id.type === "ObjectPattern") {
            node.id.properties.forEach(property => {
              checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
            });
          }
        }
      },

      AssignmentExpression: checkDestructuringAssignment,
      AssignmentPattern: checkDestructuringAssignment
    };
  }

};
var noRestrictedSyntax = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified syntax",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-syntax"
    },
    schema: {
      type: "array",
      items: {
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            selector: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["selector"],
          additionalProperties: false
        }]
      },
      uniqueItems: true,
      minItems: 0
    },
    messages: {
      restrictedSyntax: "{{message}}"
    }
  },

  create(context) {
    return context.options.reduce((result, selectorOrObject) => {
      const isStringFormat = typeof selectorOrObject === "string";
      const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
      const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
      const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;
      return Object.assign(result, {
        [selector](node) {
          context.report({
            node,
            messageId: "restrictedSyntax",
            data: {
              message
            }
          });
        }

      });
    }, {});
  }

};
const SENTINEL_TYPE$1 = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
var noReturnAssign = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignment operators in `return` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-return-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }],
    messages: {
      returnAssignment: "Return statement should not contain assignment.",
      arrowAssignment: "Arrow function should not return assignment."
    }
  },

  create(context) {
    const always = (context.options[0] || "except-parens") !== "except-parens";
    const sourceCode = context.getSourceCode();
    return {
      AssignmentExpression(node) {
        if (!always && astUtils.isParenthesised(sourceCode, node)) {
          return;
        }

        let currentChild = node;
        let parent = currentChild.parent;

        while (parent && !SENTINEL_TYPE$1.test(parent.type)) {
          currentChild = parent;
          parent = parent.parent;
        }

        if (parent && parent.type === "ReturnStatement") {
          context.report({
            node: parent,
            messageId: "returnAssignment"
          });
        } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === currentChild) {
          context.report({
            node: parent,
            messageId: "arrowAssignment"
          });
        }
      }

    };
  }

};
var noReturnAwait = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `return await`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-return-await"
    },
    fixable: null,
    schema: [],
    messages: {
      redundantUseOfAwait: "Redundant use of `await` on a return value."
    }
  },

  create(context) {
    function reportUnnecessaryAwait(node) {
      context.report({
        node: context.getSourceCode().getFirstToken(node),
        loc: node.loc,
        messageId: "redundantUseOfAwait"
      });
    }

    function hasErrorHandler(node) {
      let ancestor = node;

      while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
        if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
          return true;
        }

        ancestor = ancestor.parent;
      }

      return false;
    }

    function isInTailCallPosition(node) {
      if (node.parent.type === "ArrowFunctionExpression") {
        return true;
      }

      if (node.parent.type === "ReturnStatement") {
        return !hasErrorHandler(node.parent);
      }

      if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
        return isInTailCallPosition(node.parent);
      }

      if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
        return isInTailCallPosition(node.parent);
      }

      if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
        return isInTailCallPosition(node.parent);
      }

      return false;
    }

    return {
      AwaitExpression(node) {
        if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
          reportUnnecessaryAwait(node);
        }
      }

    };
  }

};
var noScriptUrl = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `javascript:` urls",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-script-url"
    },
    schema: [],
    messages: {
      unexpectedScriptURL: "Script URL is a form of eval."
    }
  },

  create(context) {
    function check(node) {
      const value = astUtils.getStaticStringValue(node);

      if (typeof value === "string" && value.toLowerCase().indexOf("javascript:") === 0) {
        context.report({
          node,
          messageId: "unexpectedScriptURL"
        });
      }
    }

    return {
      Literal(node) {
        if (node.value && typeof node.value === "string") {
          check(node);
        }
      },

      TemplateLiteral(node) {
        if (!(node.parent && node.parent.type === "TaggedTemplateExpression")) {
          check(node);
        }
      }

    };
  }

};
const SPACES = /\s+/gu;

function eachSelfAssignment(left, right, props, report) {
  if (!left || !right) ;else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
    report(right);
  } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
    const end = Math.min(left.elements.length, right.elements.length);

    for (let i = 0; i < end; ++i) {
      const leftElement = left.elements[i];
      const rightElement = right.elements[i];

      if (leftElement && leftElement.type === "RestElement" && i < right.elements.length - 1) {
        break;
      }

      eachSelfAssignment(leftElement, rightElement, props, report);

      if (rightElement && rightElement.type === "SpreadElement") {
        break;
      }
    }
  } else if (left.type === "RestElement" && right.type === "SpreadElement") {
    eachSelfAssignment(left.argument, right.argument, props, report);
  } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
    let startJ = 0;

    for (let i = right.properties.length - 1; i >= 0; --i) {
      const propType = right.properties[i].type;

      if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
        startJ = i + 1;
        break;
      }
    }

    for (let i = 0; i < left.properties.length; ++i) {
      for (let j = startJ; j < right.properties.length; ++j) {
        eachSelfAssignment(left.properties[i], right.properties[j], props, report);
      }
    }
  } else if (left.type === "Property" && right.type === "Property" && right.kind === "init" && !right.method) {
    const leftName = astUtils.getStaticPropertyName(left);

    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {
      eachSelfAssignment(left.value, right.value, props, report);
    }
  } else if (props && astUtils.skipChainExpression(left).type === "MemberExpression" && astUtils.skipChainExpression(right).type === "MemberExpression" && astUtils.isSameReference(left, right)) {
    report(right);
  }
}

var noSelfAssign = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments where both sides are exactly the same",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-self-assign"
    },
    schema: [{
      type: "object",
      properties: {
        props: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      selfAssignment: "'{{name}}' is assigned to itself."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const [{
      props = true
    } = {}] = context.options;

    function report(node) {
      context.report({
        node,
        messageId: "selfAssignment",
        data: {
          name: sourceCode.getText(node).replace(SPACES, "")
        }
      });
    }

    return {
      AssignmentExpression(node) {
        if (node.operator === "=") {
          eachSelfAssignment(node.left, node.right, props, report);
        }
      }

    };
  }

};
var noSelfCompare = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparisons where both sides are exactly the same",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-self-compare"
    },
    schema: [],
    messages: {
      comparingToSelf: "Comparing to itself is potentially pointless."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function hasSameTokens(nodeA, nodeB) {
      const tokensA = sourceCode.getTokens(nodeA);
      const tokensB = sourceCode.getTokens(nodeB);
      return tokensA.length === tokensB.length && tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);
    }

    return {
      BinaryExpression(node) {
        const operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);

        if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
          context.report({
            node,
            messageId: "comparingToSelf"
          });
        }
      }

    };
  }

};
const DEFAULT_OPTIONS = {
  allowInParentheses: true
};
var noSequences = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow comma operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-sequences"
    },
    schema: [{
      properties: {
        allowInParentheses: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedCommaExpression: "Unexpected use of comma operator."
    }
  },

  create(context) {
    const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);
    const sourceCode = context.getSourceCode();
    const parenthesized = {
      DoWhileStatement: "test",
      IfStatement: "test",
      SwitchStatement: "discriminant",
      WhileStatement: "test",
      WithStatement: "object",
      ArrowFunctionExpression: "body"
    };

    function requiresExtraParens(node) {
      return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
    }

    function isParenthesised(node) {
      return astUtils.isParenthesised(sourceCode, node);
    }

    function isParenthesisedTwice(node) {
      const previousToken = sourceCode.getTokenBefore(node, 1),
            nextToken = sourceCode.getTokenAfter(node, 1);
      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
    }

    return {
      SequenceExpression(node) {
        if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
          return;
        }

        if (options.allowInParentheses) {
          if (requiresExtraParens(node)) {
            if (isParenthesisedTwice(node)) {
              return;
            }
          } else {
            if (isParenthesised(node)) {
              return;
            }
          }
        }

        const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);
        context.report({
          node,
          loc: firstCommaToken.loc,
          messageId: "unexpectedCommaExpression"
        });
      }

    };
  }

};
const {
  findVariable: findVariable$1
} = eslintUtils__default['default'];

function isGlobalReference(node, scope) {
  const variable = findVariable$1(scope, node);
  return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
}

function isArgumentOfGlobalMethodCall(node, scope, objectName, methodName, index) {
  const callNode = node.parent;
  return callNode.type === "CallExpression" && callNode.arguments[index] === node && astUtils.isSpecificMemberAccess(callNode.callee, objectName, methodName) && isGlobalReference(astUtils.skipChainExpression(callNode.callee).object, scope);
}

function isPropertyDescriptor(node, scope) {
  if (isArgumentOfGlobalMethodCall(node, scope, "Object", "defineProperty", 2) || isArgumentOfGlobalMethodCall(node, scope, "Reflect", "defineProperty", 2)) {
    return true;
  }

  const parent = node.parent;

  if (parent.type === "Property" && parent.value === node) {
    const grandparent = parent.parent;

    if (grandparent.type === "ObjectExpression" && (isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "create", 1) || isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "defineProperties", 1))) {
      return true;
    }
  }

  return false;
}

function isSetter(node, scope) {
  const parent = node.parent;

  if (parent.kind === "set" && parent.value === node) {
    return true;
  }

  if (parent.type === "Property" && parent.value === node && astUtils.getStaticPropertyName(parent) === "set" && parent.parent.type === "ObjectExpression" && isPropertyDescriptor(parent.parent, scope)) {
    return true;
  }

  return false;
}

function getOuterScope(scope) {
  const upper = scope.upper;

  if (upper.type === "function-expression-name") {
    return upper.upper;
  }

  return upper;
}

var noSetterReturn = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning values from setters",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-setter-return"
    },
    schema: [],
    messages: {
      returnsValue: "Setter cannot return a value."
    }
  },

  create(context) {
    let funcInfo = null;

    function enterFunction(node) {
      const outerScope = getOuterScope(context.getScope());
      funcInfo = {
        upper: funcInfo,
        isSetter: isSetter(node, outerScope)
      };
    }

    function exitFunction() {
      funcInfo = funcInfo.upper;
    }

    function report(node) {
      context.report({
        node,
        messageId: "returnsValue"
      });
    }

    return {
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,

      ArrowFunctionExpression(node) {
        enterFunction(node);

        if (funcInfo.isSetter && node.expression) {
          report(node.body);
        }
      },

      "FunctionDeclaration:exit": exitFunction,
      "FunctionExpression:exit": exitFunction,
      "ArrowFunctionExpression:exit": exitFunction,

      ReturnStatement(node) {
        if (funcInfo && funcInfo.isSetter && node.argument) {
          report(node);
        }
      }

    };
  }

};

function safelyShadowsUndefined(variable) {
  return variable.name === "undefined" && variable.references.every(ref => !ref.isWrite()) && variable.defs.every(def => def.node.type === "VariableDeclarator" && def.node.init === null);
}

var noShadowRestrictedNames = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow identifiers from shadowing restricted names",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-shadow-restricted-names"
    },
    schema: [],
    messages: {
      shadowingRestrictedName: "Shadowing of global property '{{name}}'."
    }
  },

  create(context) {
    const RESTRICTED = new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
    return {
      "VariableDeclaration, :function, CatchClause"(node) {
        for (const variable of context.getDeclaredVariables(node)) {
          if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {
            context.report({
              node: variable.defs[0].name,
              messageId: "shadowingRestrictedName",
              data: {
                name: variable.name
              }
            });
          }
        }
      }

    };
  }

};
var noShadow = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable declarations from shadowing variables declared in the outer scope",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-shadow"
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: false
        },
        hoist: {
          enum: ["all", "functions", "never"],
          default: "functions"
        },
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
      noShadowGlobal: "'{{name}}' is already a global variable."
    }
  },

  create(context) {
    const options = {
      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,
      hoist: context.options[0] && context.options[0].hoist || "functions",
      allow: context.options[0] && context.options[0].allow || []
    };

    function isAllowed(variable) {
      return options.allow.indexOf(variable.name) !== -1;
    }

    function isDuplicatedClassNameVariable(variable) {
      const block = variable.scope.block;
      return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
    }

    function isOnInitializer(variable, scopeVar) {
      const outerScope = scopeVar.scope;
      const outerDef = scopeVar.defs[0];
      const outer = outerDef && outerDef.parent && outerDef.parent.range;
      const innerScope = variable.scope;
      const innerDef = variable.defs[0];
      const inner = innerDef && innerDef.name.range;
      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
    }

    function getNameRange(variable) {
      const def = variable.defs[0];
      return def && def.name.range;
    }

    function getDeclaredLocation(variable) {
      const identifier = variable.identifiers[0];
      let obj;

      if (identifier) {
        obj = {
          global: false,
          line: identifier.loc.start.line,
          column: identifier.loc.start.column + 1
        };
      } else {
        obj = {
          global: true
        };
      }

      return obj;
    }

    function isInTdz(variable, scopeVar) {
      const outerDef = scopeVar.defs[0];
      const inner = getNameRange(variable);
      const outer = getNameRange(scopeVar);
      return inner && outer && inner[1] < outer[0] && (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
    }

    function checkForShadows(scope) {
      const variables = scope.variables;

      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];

        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
          continue;
        }

        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);

        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
          const location = getDeclaredLocation(shadowed);
          const messageId = location.global ? "noShadowGlobal" : "noShadow";
          const data = {
            name: variable.name
          };

          if (!location.global) {
            data.shadowedLine = location.line;
            data.shadowedColumn = location.column;
          }

          context.report({
            node: variable.identifiers[0],
            messageId,
            data
          });
        }
      }
    }

    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const stack = globalScope.childScopes.slice();

        while (stack.length) {
          const scope = stack.pop();
          stack.push(...scope.childScopes);
          checkForShadows(scope);
        }
      }

    };
  }

};
var noSpacedFunc = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow spacing between function identifiers and their applications (deprecated)",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-spaced-func"
    },
    deprecated: true,
    replacedBy: ["func-call-spacing"],
    fixable: "whitespace",
    schema: [],
    messages: {
      noSpacedFunction: "Unexpected space between function name and paren."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function detectOpenSpaces(node) {
      const lastCalleeToken = sourceCode.getLastToken(node.callee);
      let prevToken = lastCalleeToken,
          parenToken = sourceCode.getTokenAfter(lastCalleeToken);

      while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
        prevToken = parenToken;
        parenToken = sourceCode.getTokenAfter(parenToken);
      }

      if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
        context.report({
          node,
          loc: lastCalleeToken.loc.start,
          messageId: "noSpacedFunction",

          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
          }

        });
      }
    }

    return {
      CallExpression: detectOpenSpaces,
      NewExpression: detectOpenSpaces
    };
  }

};
var noSparseArrays = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow sparse arrays",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-sparse-arrays"
    },
    schema: [],
    messages: {
      unexpectedSparseArray: "Unexpected comma in middle of array."
    }
  },

  create(context) {
    return {
      ArrayExpression(node) {
        const emptySpot = node.elements.indexOf(null) > -1;

        if (emptySpot) {
          context.report({
            node,
            messageId: "unexpectedSparseArray"
          });
        }
      }

    };
  }

};
var noSync = {
  meta: {
    deprecated: true,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow synchronous methods",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-sync"
    },
    schema: [{
      type: "object",
      properties: {
        allowAtRootLevel: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      noSync: "Unexpected sync method: '{{propertyName}}'."
    }
  },

  create(context) {
    const selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
    return {
      [selector](node) {
        context.report({
          node,
          messageId: "noSync",
          data: {
            propertyName: node.property.name
          }
        });
      }

    };
  }

};
const tabRegex = /\t+/gu;
const anyNonWhitespaceRegex = /\S/u;
var noTabs = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow all tabs",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-tabs"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndentationTabs: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedTab: "Unexpected tab character."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;
    return {
      Program(node) {
        sourceCode.getLines().forEach((line, index) => {
          let match;

          while ((match = tabRegex.exec(line)) !== null) {
            if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {
              continue;
            }

            context.report({
              node,
              loc: {
                start: {
                  line: index + 1,
                  column: match.index
                },
                end: {
                  line: index + 1,
                  column: match.index + match[0].length
                }
              },
              messageId: "unexpectedTab"
            });
          }
        });
      }

    };
  }

};
var noTemplateCurlyInString = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow template literal placeholder syntax in regular strings",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-template-curly-in-string"
    },
    schema: [],
    messages: {
      unexpectedTemplateExpression: "Unexpected template string expression."
    }
  },

  create(context) {
    return {
      Literal(node) {
        if (typeof node.value === "string" && /\$\{[^}]+\}/u.test(node.value)) {
          context.report({
            node,
            messageId: "unexpectedTemplateExpression"
          });
        }
      }

    };
  }

};
var noTernary = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-ternary"
    },
    schema: [],
    messages: {
      noTernaryOperator: "Ternary operator used."
    }
  },

  create(context) {
    return {
      ConditionalExpression(node) {
        context.report({
          node,
          messageId: "noTernaryOperator"
        });
      }

    };
  }

};

function isConstructorFunction(node) {
  return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

var noThisBeforeSuper = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `this`/`super` before calling `super()` in constructors",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-this-before-super"
    },
    schema: [],
    messages: {
      noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
    }
  },

  create(context) {
    let funcInfo = null;
    let segInfoMap = Object.create(null);

    function isCalled(segment) {
      return !segment.reachable || segInfoMap[segment.id].superCalled;
    }

    function isInConstructorOfDerivedClass() {
      return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
    }

    function isBeforeCallOfSuper() {
      return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
    }

    function setInvalid(node) {
      const segments = funcInfo.codePath.currentSegments;

      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (segment.reachable) {
          segInfoMap[segment.id].invalidNodes.push(node);
        }
      }
    }

    function setSuperCalled() {
      const segments = funcInfo.codePath.currentSegments;

      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (segment.reachable) {
          segInfoMap[segment.id].superCalled = true;
        }
      }
    }

    return {
      onCodePathStart(codePath, node) {
        if (isConstructorFunction(node)) {
          const classNode = node.parent.parent.parent;
          funcInfo = {
            upper: funcInfo,
            isConstructor: true,
            hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
            codePath
          };
        } else {
          funcInfo = {
            upper: funcInfo,
            isConstructor: false,
            hasExtends: false,
            codePath
          };
        }
      },

      onCodePathEnd(codePath) {
        const isDerivedClass = funcInfo.hasExtends;
        funcInfo = funcInfo.upper;

        if (!isDerivedClass) {
          return;
        }

        codePath.traverseSegments((segment, controller) => {
          const info = segInfoMap[segment.id];

          for (let i = 0; i < info.invalidNodes.length; ++i) {
            const invalidNode = info.invalidNodes[i];
            context.report({
              messageId: "noBeforeSuper",
              node: invalidNode,
              data: {
                kind: invalidNode.type === "Super" ? "super" : "this"
              }
            });
          }

          if (info.superCalled) {
            controller.skip();
          }
        });
      },

      onCodePathSegmentStart(segment) {
        if (!isInConstructorOfDerivedClass()) {
          return;
        }

        segInfoMap[segment.id] = {
          superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
          invalidNodes: []
        };
      },

      onCodePathSegmentLoop(fromSegment, toSegment) {
        if (!isInConstructorOfDerivedClass()) {
          return;
        }

        funcInfo.codePath.traverseSegments({
          first: toSegment,
          last: fromSegment
        }, (segment, controller) => {
          const info = segInfoMap[segment.id];

          if (info.superCalled) {
            info.invalidNodes = [];
            controller.skip();
          } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
            info.superCalled = true;
            info.invalidNodes = [];
          }
        });
      },

      ThisExpression(node) {
        if (isBeforeCallOfSuper()) {
          setInvalid(node);
        }
      },

      Super(node) {
        if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
          setInvalid(node);
        }
      },

      "CallExpression:exit"(node) {
        if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
          setSuperCalled();
        }
      },

      "Program:exit"() {
        segInfoMap = Object.create(null);
      }

    };
  }

};
var noThrowLiteral = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow throwing literals as exceptions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-throw-literal"
    },
    schema: [],
    messages: {
      object: "Expected an error object to be thrown.",
      undef: "Do not throw undefined."
    }
  },

  create(context) {
    return {
      ThrowStatement(node) {
        if (!astUtils.couldBeError(node.argument)) {
          context.report({
            node,
            messageId: "object"
          });
        } else if (node.argument.type === "Identifier") {
          if (node.argument.name === "undefined") {
            context.report({
              node,
              messageId: "undef"
            });
          }
        }
      }

    };
  }

};
var noTrailingSpaces = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow trailing whitespace at the end of lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-trailing-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        skipBlankLines: {
          type: "boolean",
          default: false
        },
        ignoreComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      trailingSpace: "Trailing spaces not allowed."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {},
          skipBlankLines = options.skipBlankLines || false,
          ignoreComments = options.ignoreComments || false;

    function report(node, location, fixRange) {
      context.report({
        node,
        loc: location,
        messageId: "trailingSpace",

        fix(fixer) {
          return fixer.removeRange(fixRange);
        }

      });
    }

    function getCommentLineNumbers(comments) {
      const lines = new Set();
      comments.forEach(comment => {
        const endLine = comment.type === "Block" ? comment.loc.end.line - 1 : comment.loc.end.line;

        for (let i = comment.loc.start.line; i <= endLine; i++) {
          lines.add(i);
        }
      });
      return lines;
    }

    return {
      Program: function (node) {
        const re = new RegExp(`${"[ \t\xA0\u2000-\u200B\u3000]"}+$`, "u"),
              skipMatch = new RegExp(`^${"[ \t\xA0\u2000-\u200B\u3000]"}*$`, "u"),
              lines = sourceCode.lines,
              linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
              comments = sourceCode.getAllComments(),
              commentLineNumbers = getCommentLineNumbers(comments);
        let totalLength = 0,
            fixRange = [];

        for (let i = 0, ii = lines.length; i < ii; i++) {
          const lineNumber = i + 1;
          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
          const lineLength = lines[i].length + linebreakLength;
          const matches = re.exec(lines[i]);

          if (matches) {
            const location = {
              start: {
                line: lineNumber,
                column: matches.index
              },
              end: {
                line: lineNumber,
                column: lineLength - linebreakLength
              }
            };
            const rangeStart = totalLength + location.start.column;
            const rangeEnd = totalLength + location.end.column;
            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);

            if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
              totalLength += lineLength;
              continue;
            }

            if (skipBlankLines && skipMatch.test(lines[i])) {
              totalLength += lineLength;
              continue;
            }

            fixRange = [rangeStart, rangeEnd];

            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {
              report(node, location, fixRange);
            }
          }

          totalLength += lineLength;
        }
      }
    };
  }

};
var noUndefInit = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow initializing variables to `undefined`",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-undef-init"
    },
    schema: [],
    fixable: "code",
    messages: {
      unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      VariableDeclarator(node) {
        const name = sourceCode.getText(node.id),
              init = node.init && node.init.name,
              scope = context.getScope(),
              undefinedVar = astUtils.getVariableByName(scope, "undefined"),
              shadowed = undefinedVar && undefinedVar.defs.length > 0,
              lastToken = sourceCode.getLastToken(node);

        if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
          context.report({
            node,
            messageId: "unnecessaryUndefinedInit",
            data: {
              name
            },

            fix(fixer) {
              if (node.parent.kind === "var") {
                return null;
              }

              if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
                return null;
              }

              if (sourceCode.commentsExistBetween(node.id, lastToken)) {
                return null;
              }

              return fixer.removeRange([node.id.range[1], node.range[1]]);
            }

          });
        }
      }

    };
  }

};

function hasTypeOfOperator(node) {
  const parent = node.parent;
  return parent.type === "UnaryExpression" && parent.operator === "typeof";
}

var noUndef = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-undef"
    },
    schema: [{
      type: "object",
      properties: {
        typeof: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      undef: "'{{name}}' is not defined."
    }
  },

  create(context) {
    const options = context.options[0];
    const considerTypeOf = options && options.typeof === true || false;
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        globalScope.through.forEach(ref => {
          const identifier = ref.identifier;

          if (!considerTypeOf && hasTypeOfOperator(identifier)) {
            return;
          }

          context.report({
            node: identifier,
            messageId: "undef",
            data: identifier
          });
        });
      }

    };
  }

};
var noUndefined = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `undefined` as an identifier",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-undefined"
    },
    schema: [],
    messages: {
      unexpectedUndefined: "Unexpected use of undefined."
    }
  },

  create(context) {
    function report(node) {
      context.report({
        node,
        messageId: "unexpectedUndefined"
      });
    }

    function checkScope(scope) {
      const undefinedVar = scope.set.get("undefined");

      if (!undefinedVar) {
        return;
      }

      const references = undefinedVar.references;
      const defs = undefinedVar.defs;
      references.filter(ref => !ref.init).forEach(ref => report(ref.identifier));
      defs.forEach(def => report(def.name));
    }

    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const stack = [globalScope];

        while (stack.length) {
          const scope = stack.pop();
          stack.push(...scope.childScopes);
          checkScope(scope);
        }
      }

    };
  }

};
var noUnderscoreDangle = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow dangling underscores in identifiers",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-underscore-dangle"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        },
        allowAfterThis: {
          type: "boolean",
          default: false
        },
        allowAfterSuper: {
          type: "boolean",
          default: false
        },
        allowAfterThisConstructor: {
          type: "boolean",
          default: false
        },
        enforceInMethodNames: {
          type: "boolean",
          default: false
        },
        allowFunctionParams: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const ALLOWED_VARIABLES = options.allow ? options.allow : [];
    const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
    const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
    const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== "undefined" ? options.allowAfterThisConstructor : false;
    const enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
    const allowFunctionParams = typeof options.allowFunctionParams !== "undefined" ? options.allowFunctionParams : true;

    function isAllowed(identifier) {
      return ALLOWED_VARIABLES.some(ident => ident === identifier);
    }

    function hasDanglingUnderscore(identifier) {
      const len = identifier.length;
      return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
    }

    function isSpecialCaseIdentifierForMemberExpression(identifier) {
      return identifier === "__proto__";
    }

    function isSpecialCaseIdentifierInVariableExpression(identifier) {
      return identifier === "_";
    }

    function isThisConstructorReference(node) {
      return node.object.type === "MemberExpression" && node.object.property.name === "constructor" && node.object.object.type === "ThisExpression";
    }

    function checkForDanglingUnderscoreInFunctionParameters(node) {
      if (!allowFunctionParams) {
        node.params.forEach(param => {
          const {
            type
          } = param;
          let nodeToCheck;

          if (type === "RestElement") {
            nodeToCheck = param.argument;
          } else if (type === "AssignmentPattern") {
            nodeToCheck = param.left;
          } else {
            nodeToCheck = param;
          }

          if (nodeToCheck.type === "Identifier") {
            const identifier = nodeToCheck.name;

            if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
              context.report({
                node: param,
                messageId: "unexpectedUnderscore",
                data: {
                  identifier
                }
              });
            }
          }
        });
      }
    }

    function checkForDanglingUnderscoreInFunction(node) {
      if (node.type === "FunctionDeclaration" && node.id) {
        const identifier = node.id.name;

        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
          context.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      }

      checkForDanglingUnderscoreInFunctionParameters(node);
    }

    function checkForDanglingUnderscoreInMethod(node) {
      const identifier = node.key.name;
      const isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;

      if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
        context.report({
          node,
          messageId: "unexpectedUnderscore",
          data: {
            identifier
          }
        });
      }
    }

    return {
      FunctionDeclaration: checkForDanglingUnderscoreInFunction,
      VariableDeclarator: function (node) {
        const identifier = node.id.name;

        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
          context.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      },
      MemberExpression: function (node) {
        const identifier = node.property.name,
              isMemberOfThis = node.object.type === "ThisExpression",
              isMemberOfSuper = node.object.type === "Super",
              isMemberOfThisConstructor = isThisConstructorReference(node);

        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
          context.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      },
      MethodDefinition: checkForDanglingUnderscoreInMethod,
      Property: checkForDanglingUnderscoreInMethod,
      FunctionExpression: checkForDanglingUnderscoreInFunction,
      ArrowFunctionExpression: checkForDanglingUnderscoreInFunction
    };
  }

};
var noUnexpectedMultiline = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow confusing multiline expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unexpected-multiline"
    },
    schema: [],
    messages: {
      function: "Unexpected newline between function and ( of function call.",
      property: "Unexpected newline between object and [ of property access.",
      taggedTemplate: "Unexpected newline between template tag and template literal.",
      division: "Unexpected newline between numerator and division operator."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function checkForBreakAfter(node, messageId) {
      const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
      const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);

      if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
        context.report({
          node,
          loc: openParen.loc,
          messageId
        });
      }
    }

    return {
      MemberExpression(node) {
        if (!node.computed || node.optional) {
          return;
        }

        checkForBreakAfter(node.object, "property");
      },

      TaggedTemplateExpression(node) {
        const {
          quasi
        } = node;
        const tokenBefore = sourceCode.getTokenBefore(quasi);

        if (tokenBefore.loc.end.line !== quasi.loc.start.line) {
          context.report({
            node,
            loc: {
              start: quasi.loc.start,
              end: {
                line: quasi.loc.start.line,
                column: quasi.loc.start.column + 1
              }
            },
            messageId: "taggedTemplate"
          });
        }
      },

      CallExpression(node) {
        if (node.arguments.length === 0 || node.optional) {
          return;
        }

        checkForBreakAfter(node.callee, "function");
      },

      "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node) {
        const secondSlash = sourceCode.getTokenAfter(node, token => token.value === "/");
        const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);

        if (tokenAfterOperator.type === "Identifier" && /^[gimsuy]+$/u.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
          checkForBreakAfter(node.left, "division");
        }
      }

    };
  }

};
const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u;
const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;

function isWriteReference(reference) {
  if (reference.init) {
    const def = reference.resolved && reference.resolved.defs[0];

    if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
      return false;
    }
  }

  return reference.isWrite();
}

function isUnmodified(condition) {
  return !condition.modified;
}

function isUnmodifiedAndNotBelongToGroup(condition) {
  return !(condition.modified || condition.group);
}

function isInRange$1(node, reference) {
  const or = node.range;
  const ir = reference.identifier.range;
  return or[0] <= ir[0] && ir[1] <= or[1];
}

const isInLoop = {
  WhileStatement: isInRange$1,
  DoWhileStatement: isInRange$1,

  ForStatement(node, reference) {
    return isInRange$1(node, reference) && !(node.init && isInRange$1(node.init, reference));
  }

};

function getEncloseFunctionDeclaration(reference) {
  let node = reference.identifier;

  while (node) {
    if (node.type === "FunctionDeclaration") {
      return node.id ? node : null;
    }

    node = node.parent;
  }

  return null;
}

function updateModifiedFlag(conditions, modifiers) {
  for (let i = 0; i < conditions.length; ++i) {
    const condition = conditions[i];

    for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
      const modifier = modifiers[j];
      let funcNode, funcVar;
      const inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));
      condition.modified = inLoop;
    }
  }
}

var noUnmodifiedLoopCondition = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unmodified loop conditions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unmodified-loop-condition"
    },
    schema: [],
    messages: {
      loopConditionNotModified: "'{{name}}' is not modified in this loop."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let groupMap = null;

    function report(condition) {
      const node = condition.reference.identifier;
      context.report({
        node,
        messageId: "loopConditionNotModified",
        data: node
      });
    }

    function registerConditionsToGroup(conditions) {
      for (let i = 0; i < conditions.length; ++i) {
        const condition = conditions[i];

        if (condition.group) {
          let group = groupMap.get(condition.group);

          if (!group) {
            group = [];
            groupMap.set(condition.group, group);
          }

          group.push(condition);
        }
      }
    }

    function checkConditionsInGroup(conditions) {
      if (conditions.every(isUnmodified)) {
        conditions.forEach(report);
      }
    }

    function hasDynamicExpressions(root) {
      let retv = false;

      _commonjsHelpers.traverser.traverse(root, {
        visitorKeys: sourceCode.visitorKeys,

        enter(node) {
          if (DYNAMIC_PATTERN.test(node.type)) {
            retv = true;
            this.break();
          } else if (SKIP_PATTERN.test(node.type)) {
            this.skip();
          }
        }

      });

      return retv;
    }

    function toLoopCondition(reference) {
      if (reference.init) {
        return null;
      }

      let group = null;
      let child = reference.identifier;
      let node = child.parent;

      while (node) {
        if (SENTINEL_PATTERN.test(node.type)) {
          if (LOOP_PATTERN.test(node.type) && node.test === child) {
            return {
              reference,
              group,
              isInLoop: isInLoop[node.type].bind(null, node),
              modified: false
            };
          }

          break;
        }

        if (GROUP_PATTERN.test(node.type)) {
          if (hasDynamicExpressions(node)) {
            break;
          } else {
            group = node;
          }
        }

        child = node;
        node = node.parent;
      }

      return null;
    }

    function checkReferences(variable) {
      const conditions = variable.references.map(toLoopCondition).filter(Boolean);

      if (conditions.length === 0) {
        return;
      }

      registerConditionsToGroup(conditions);
      const modifiers = variable.references.filter(isWriteReference);

      if (modifiers.length > 0) {
        updateModifiedFlag(conditions, modifiers);
      }

      conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
    }

    return {
      "Program:exit"() {
        const queue = [context.getScope()];
        groupMap = new Map();
        let scope;

        while (scope = queue.pop()) {
          queue.push(...scope.childScopes);
          scope.variables.forEach(checkReferences);
        }

        groupMap.forEach(checkConditionsInGroup);
        groupMap = null;
      }

    };
  }

};
const BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
const OPERATOR_INVERSES = {
  "==": "!=",
  "!=": "==",
  "===": "!==",
  "!==": "==="
};
const OR_PRECEDENCE = astUtils.getPrecedence({
  type: "LogicalExpression",
  operator: "||"
});
var noUnneededTernary = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators when simpler alternatives exist",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unneeded-ternary"
    },
    schema: [{
      type: "object",
      properties: {
        defaultAssignment: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
      unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const defaultAssignment = options.defaultAssignment !== false;
    const sourceCode = context.getSourceCode();

    function isBooleanLiteral(node) {
      return node.type === "Literal" && typeof node.value === "boolean";
    }

    function invertExpression(node) {
      if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        const text = sourceCode.getText();
        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
      }

      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({
        type: "UnaryExpression"
      })) {
        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
      }

      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
    }

    function isBooleanExpression(node) {
      return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
    }

    function matchesDefaultAssignment(node) {
      return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
    }

    return {
      ConditionalExpression(node) {
        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
          context.report({
            node,
            messageId: "unnecessaryConditionalExpression",

            fix(fixer) {
              if (node.consequent.value === node.alternate.value) {
                return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
              }

              if (node.alternate.value) {
                return fixer.replaceText(node, invertExpression(node.test));
              }

              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
            }

          });
        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
          context.report({
            node,
            messageId: "unnecessaryConditionalAssignment",
            fix: fixer => {
              const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);
              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);
              const testText = astUtils.getParenthesisedText(sourceCode, node.test);
              return fixer.replaceText(node, `${testText} || ${alternateText}`);
            }
          });
        }
      }

    };
  }

};
const allLoopTypes = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];

function isLoopingTarget(node) {
  const parent = node.parent;

  if (parent) {
    switch (parent.type) {
      case "WhileStatement":
        return node === parent.test;

      case "DoWhileStatement":
        return node === parent.body;

      case "ForStatement":
        return node === (parent.update || parent.test || parent.body);

      case "ForInStatement":
      case "ForOfStatement":
        return node === parent.left;
    }
  }

  return false;
}

function getDifference(arrA, arrB) {
  return arrA.filter(a => !arrB.includes(a));
}

var noUnreachableLoop = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow loops with a body that allows only one iteration",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unreachable-loop"
    },
    schema: [{
      type: "object",
      properties: {
        ignore: {
          type: "array",
          items: {
            enum: allLoopTypes
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      invalid: "Invalid loop. Its body allows only one iteration."
    }
  },

  create(context) {
    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],
          loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),
          loopSelector = loopTypesToCheck.join(","),
          loopsByTargetSegments = new Map(),
          loopsToReport = new Set();
    let currentCodePath = null;
    return {
      onCodePathStart(codePath) {
        currentCodePath = codePath;
      },

      onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },

      [loopSelector](node) {
        if (currentCodePath.currentSegments.some(segment => segment.reachable)) {
          loopsToReport.add(node);
        }
      },

      onCodePathSegmentStart(segment, node) {
        if (isLoopingTarget(node)) {
          const loop = node.parent;
          loopsByTargetSegments.set(segment, loop);
        }
      },

      onCodePathSegmentLoop(_, toSegment, node) {
        const loop = loopsByTargetSegments.get(toSegment);

        if (node === loop || node.type === "ContinueStatement") {
          loopsToReport.delete(loop);
        }
      },

      "Program:exit"() {
        loopsToReport.forEach(node => context.report({
          node,
          messageId: "invalid"
        }));
      }

    };
  }

};

function isInitialized(node) {
  return Boolean(node.init);
}

function isUnreachable(segment) {
  return !segment.reachable;
}

class ConsecutiveRange {
  constructor(sourceCode) {
    this.sourceCode = sourceCode;
    this.startNode = null;
    this.endNode = null;
  }

  get location() {
    return {
      start: this.startNode.loc.start,
      end: this.endNode.loc.end
    };
  }

  get isEmpty() {
    return !(this.startNode && this.endNode);
  }

  contains(node) {
    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
  }

  isConsecutive(node) {
    return this.contains(this.sourceCode.getTokenBefore(node));
  }

  merge(node) {
    this.endNode = node;
  }

  reset(node) {
    this.startNode = this.endNode = node;
  }

}

var noUnreachable = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unreachable"
    },
    schema: [],
    messages: {
      unreachableCode: "Unreachable code."
    }
  },

  create(context) {
    let currentCodePath = null;
    const range = new ConsecutiveRange(context.getSourceCode());

    function reportIfUnreachable(node) {
      let nextNode = null;

      if (node && currentCodePath.currentSegments.every(isUnreachable)) {
        if (range.isEmpty) {
          range.reset(node);
          return;
        }

        if (range.contains(node)) {
          return;
        }

        if (range.isConsecutive(node)) {
          range.merge(node);
          return;
        }

        nextNode = node;
      }

      if (!range.isEmpty) {
        context.report({
          messageId: "unreachableCode",
          loc: range.location,
          node: range.startNode
        });
      }

      range.reset(nextNode);
    }

    return {
      onCodePathStart(codePath) {
        currentCodePath = codePath;
      },

      onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },

      BlockStatement: reportIfUnreachable,
      BreakStatement: reportIfUnreachable,
      ClassDeclaration: reportIfUnreachable,
      ContinueStatement: reportIfUnreachable,
      DebuggerStatement: reportIfUnreachable,
      DoWhileStatement: reportIfUnreachable,
      ExpressionStatement: reportIfUnreachable,
      ForInStatement: reportIfUnreachable,
      ForOfStatement: reportIfUnreachable,
      ForStatement: reportIfUnreachable,
      IfStatement: reportIfUnreachable,
      ImportDeclaration: reportIfUnreachable,
      LabeledStatement: reportIfUnreachable,
      ReturnStatement: reportIfUnreachable,
      SwitchStatement: reportIfUnreachable,
      ThrowStatement: reportIfUnreachable,
      TryStatement: reportIfUnreachable,

      VariableDeclaration(node) {
        if (node.kind !== "var" || node.declarations.some(isInitialized)) {
          reportIfUnreachable(node);
        }
      },

      WhileStatement: reportIfUnreachable,
      WithStatement: reportIfUnreachable,
      ExportNamedDeclaration: reportIfUnreachable,
      ExportDefaultDeclaration: reportIfUnreachable,
      ExportAllDeclaration: reportIfUnreachable,

      "Program:exit"() {
        reportIfUnreachable();
      }

    };
  }

};
const SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
const SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;
const SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
var noUnsafeFinally = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control flow statements in `finally` blocks",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unsafe-finally"
    },
    schema: [],
    messages: {
      unsafeUsage: "Unsafe usage of {{nodeType}}."
    }
  },

  create(context) {
    function isFinallyBlock(node) {
      return node.parent.type === "TryStatement" && node.parent.finalizer === node;
    }

    function isInFinallyBlock(node, label) {
      let labelInside = false;
      let sentinelNodeType;

      if (node.type === "BreakStatement" && !node.label) {
        sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
      } else if (node.type === "ContinueStatement") {
        sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
      } else {
        sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
      }

      for (let currentNode = node; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {
        if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {
          labelInside = true;
        }

        if (isFinallyBlock(currentNode)) {
          if (label && labelInside) {
            return false;
          }

          return true;
        }
      }

      return false;
    }

    function check(node) {
      if (isInFinallyBlock(node, node.label)) {
        context.report({
          messageId: "unsafeUsage",
          data: {
            nodeType: node.type
          },
          node,
          line: node.loc.line,
          column: node.loc.column
        });
      }
    }

    return {
      ReturnStatement: check,
      ThrowStatement: check,
      BreakStatement: check,
      ContinueStatement: check
    };
  }

};

function isInOrInstanceOfOperator(op) {
  return op === "in" || op === "instanceof";
}

function isOrderingRelationalOperator(op) {
  return op === "<" || op === ">" || op === ">=" || op === "<=";
}

function isNegation(node) {
  return node.type === "UnaryExpression" && node.operator === "!";
}

var noUnsafeNegation = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand of relational operators",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unsafe-negation",
      suggestion: true
    },
    schema: [{
      type: "object",
      properties: {
        enforceForOrderingRelations: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: null,
    messages: {
      unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
      suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
      suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {};
    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;
    return {
      BinaryExpression(node) {
        const operator = node.operator;
        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);

        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
          context.report({
            node,
            loc: node.left.loc,
            messageId: "unexpected",
            data: {
              operator
            },
            suggest: [{
              messageId: "suggestNegatedExpression",
              data: {
                operator
              },

              fix(fixer) {
                const negationToken = sourceCode.getFirstToken(node.left);
                const fixRange = [negationToken.range[1], node.range[1]];
                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
                return fixer.replaceTextRange(fixRange, `(${text})`);
              }

            }, {
              messageId: "suggestParenthesisedNegation",

              fix(fixer) {
                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);
              }

            }]
          });
        }
      }

    };
  }

};
const UNSAFE_ARITHMETIC_OPERATORS = new Set(["+", "-", "/", "*", "%", "**"]);
const UNSAFE_ASSIGNMENT_OPERATORS = new Set(["+=", "-=", "/=", "*=", "%=", "**="]);
const UNSAFE_RELATIONAL_OPERATORS = new Set(["in", "instanceof"]);

function isDestructuringPattern(node) {
  return node.type === "ObjectPattern" || node.type === "ArrayPattern";
}

var noUnsafeOptionalChaining = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow use of optional chaining in contexts where the `undefined` value is not allowed",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unsafe-optional-chaining"
    },
    schema: [{
      type: "object",
      properties: {
        disallowArithmeticOperators: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: null,
    messages: {
      unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
      unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const disallowArithmeticOperators = options.disallowArithmeticOperators || false;

    function reportUnsafeUsage(node) {
      context.report({
        messageId: "unsafeOptionalChain",
        node
      });
    }

    function reportUnsafeArithmetic(node) {
      context.report({
        messageId: "unsafeArithmetic",
        node
      });
    }

    function checkUndefinedShortCircuit(node, reportFunc) {
      if (!node) {
        return;
      }

      switch (node.type) {
        case "LogicalExpression":
          if (node.operator === "||" || node.operator === "??") {
            checkUndefinedShortCircuit(node.right, reportFunc);
          } else if (node.operator === "&&") {
            checkUndefinedShortCircuit(node.left, reportFunc);
            checkUndefinedShortCircuit(node.right, reportFunc);
          }

          break;

        case "SequenceExpression":
          checkUndefinedShortCircuit(node.expressions[node.expressions.length - 1], reportFunc);
          break;

        case "ConditionalExpression":
          checkUndefinedShortCircuit(node.consequent, reportFunc);
          checkUndefinedShortCircuit(node.alternate, reportFunc);
          break;

        case "AwaitExpression":
          checkUndefinedShortCircuit(node.argument, reportFunc);
          break;

        case "ChainExpression":
          reportFunc(node);
          break;
      }
    }

    function checkUnsafeUsage(node) {
      checkUndefinedShortCircuit(node, reportUnsafeUsage);
    }

    function checkUnsafeArithmetic(node) {
      checkUndefinedShortCircuit(node, reportUnsafeArithmetic);
    }

    return {
      "AssignmentExpression, AssignmentPattern"(node) {
        if (isDestructuringPattern(node.left)) {
          checkUnsafeUsage(node.right);
        }
      },

      "ClassDeclaration, ClassExpression"(node) {
        checkUnsafeUsage(node.superClass);
      },

      CallExpression(node) {
        if (!node.optional) {
          checkUnsafeUsage(node.callee);
        }
      },

      NewExpression(node) {
        checkUnsafeUsage(node.callee);
      },

      VariableDeclarator(node) {
        if (isDestructuringPattern(node.id)) {
          checkUnsafeUsage(node.init);
        }
      },

      MemberExpression(node) {
        if (!node.optional) {
          checkUnsafeUsage(node.object);
        }
      },

      TaggedTemplateExpression(node) {
        checkUnsafeUsage(node.tag);
      },

      ForOfStatement(node) {
        checkUnsafeUsage(node.right);
      },

      SpreadElement(node) {
        if (node.parent && node.parent.type !== "ObjectExpression") {
          checkUnsafeUsage(node.argument);
        }
      },

      BinaryExpression(node) {
        if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {
          checkUnsafeUsage(node.right);
        }

        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
          checkUnsafeArithmetic(node.right);
          checkUnsafeArithmetic(node.left);
        }
      },

      WithStatement(node) {
        checkUnsafeUsage(node.object);
      },

      UnaryExpression(node) {
        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
          checkUnsafeArithmetic(node.argument);
        }
      },

      AssignmentExpression(node) {
        if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {
          checkUnsafeArithmetic(node.right);
        }
      }

    };
  }

};

function alwaysTrue() {
  return true;
}

function alwaysFalse() {
  return false;
}

var noUnusedExpressions = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused expressions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unused-expressions"
    },
    schema: [{
      type: "object",
      properties: {
        allowShortCircuit: {
          type: "boolean",
          default: false
        },
        allowTernary: {
          type: "boolean",
          default: false
        },
        allowTaggedTemplates: {
          type: "boolean",
          default: false
        },
        enforceForJSX: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unusedExpression: "Expected an assignment or function call and instead saw an expression."
    }
  },

  create(context) {
    const config = context.options[0] || {},
          allowShortCircuit = config.allowShortCircuit || false,
          allowTernary = config.allowTernary || false,
          allowTaggedTemplates = config.allowTaggedTemplates || false,
          enforceForJSX = config.enforceForJSX || false;

    function looksLikeDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function takeWhile(predicate, list) {
      for (let i = 0; i < list.length; ++i) {
        if (!predicate(list[i])) {
          return list.slice(0, i);
        }
      }

      return list.slice();
    }

    function directives(node) {
      return takeWhile(looksLikeDirective, node.body);
    }

    function isDirective(node, ancestors) {
      const parent = ancestors[ancestors.length - 1],
            grandparent = ancestors[ancestors.length - 2];
      return (parent.type === "Program" || parent.type === "BlockStatement" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;
    }

    const Checker = Object.assign(Object.create(null), {
      isDisallowed(node) {
        return (Checker[node.type] || alwaysFalse)(node);
      },

      ArrayExpression: alwaysTrue,
      ArrowFunctionExpression: alwaysTrue,
      BinaryExpression: alwaysTrue,

      ChainExpression(node) {
        return Checker.isDisallowed(node.expression);
      },

      ClassExpression: alwaysTrue,

      ConditionalExpression(node) {
        if (allowTernary) {
          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);
        }

        return true;
      },

      FunctionExpression: alwaysTrue,
      Identifier: alwaysTrue,

      JSXElement() {
        return enforceForJSX;
      },

      JSXFragment() {
        return enforceForJSX;
      },

      Literal: alwaysTrue,

      LogicalExpression(node) {
        if (allowShortCircuit) {
          return Checker.isDisallowed(node.right);
        }

        return true;
      },

      MemberExpression: alwaysTrue,
      MetaProperty: alwaysTrue,
      ObjectExpression: alwaysTrue,
      SequenceExpression: alwaysTrue,

      TaggedTemplateExpression() {
        return !allowTaggedTemplates;
      },

      TemplateLiteral: alwaysTrue,
      ThisExpression: alwaysTrue,

      UnaryExpression(node) {
        return node.operator !== "void" && node.operator !== "delete";
      }

    });
    return {
      ExpressionStatement(node) {
        if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {
          context.report({
            node,
            messageId: "unusedExpression"
          });
        }
      }

    };
  }

};
var noUnusedLabels = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused labels",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unused-labels"
    },
    schema: [],
    fixable: "code",
    messages: {
      unused: "'{{name}}:' is defined but never used."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    function enterLabeledScope(node) {
      scopeInfo = {
        label: node.label.name,
        used: false,
        upper: scopeInfo
      };
    }

    function exitLabeledScope(node) {
      if (!scopeInfo.used) {
        context.report({
          node: node.label,
          messageId: "unused",
          data: node.label,

          fix(fixer) {
            if (sourceCode.getTokenAfter(node.label, {
              includeComments: true
            }) === sourceCode.getTokenBefore(node.body, {
              includeComments: true
            })) {
              return fixer.removeRange([node.range[0], node.body.range[0]]);
            }

            return null;
          }

        });
      }

      scopeInfo = scopeInfo.upper;
    }

    function markAsUsed(node) {
      if (!node.label) {
        return;
      }

      const label = node.label.name;
      let info = scopeInfo;

      while (info) {
        if (info.label === label) {
          info.used = true;
          break;
        }

        info = info.upper;
      }
    }

    return {
      LabeledStatement: enterLabeledScope,
      "LabeledStatement:exit": exitLabeledScope,
      BreakStatement: markAsUsed,
      ContinueStatement: markAsUsed
    };
  }

};
var noUnusedVars = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused variables",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unused-vars"
    },
    schema: [{
      oneOf: [{
        enum: ["all", "local"]
      }, {
        type: "object",
        properties: {
          vars: {
            enum: ["all", "local"]
          },
          varsIgnorePattern: {
            type: "string"
          },
          args: {
            enum: ["all", "after-used", "none"]
          },
          ignoreRestSiblings: {
            type: "boolean"
          },
          argsIgnorePattern: {
            type: "string"
          },
          caughtErrors: {
            enum: ["all", "none"]
          },
          caughtErrorsIgnorePattern: {
            type: "string"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const config = {
      vars: "all",
      args: "after-used",
      ignoreRestSiblings: false,
      caughtErrors: "none"
    };
    const firstOption = context.options[0];

    if (firstOption) {
      if (typeof firstOption === "string") {
        config.vars = firstOption;
      } else {
        config.vars = firstOption.vars || config.vars;
        config.args = firstOption.args || config.args;
        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;

        if (firstOption.varsIgnorePattern) {
          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, "u");
        }

        if (firstOption.argsIgnorePattern) {
          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, "u");
        }

        if (firstOption.caughtErrorsIgnorePattern) {
          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, "u");
        }
      }
    }

    function getDefinedMessageData(unusedVar) {
      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;
      let type;
      let pattern;

      if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
        type = "args";
        pattern = config.caughtErrorsIgnorePattern.toString();
      } else if (defType === "Parameter" && config.argsIgnorePattern) {
        type = "args";
        pattern = config.argsIgnorePattern.toString();
      } else if (defType !== "Parameter" && config.varsIgnorePattern) {
        type = "vars";
        pattern = config.varsIgnorePattern.toString();
      }

      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : "";
      return {
        varName: unusedVar.name,
        action: "defined",
        additional
      };
    }

    function getAssignedMessageData(unusedVar) {
      const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : "";
      return {
        varName: unusedVar.name,
        action: "assigned a value",
        additional
      };
    }

    function isExported(variable) {
      const definition = variable.defs[0];

      if (definition) {
        let node = definition.node;

        if (node.type === "VariableDeclarator") {
          node = node.parent;
        } else if (definition.type === "Parameter") {
          return false;
        }

        return node.parent.type.indexOf("Export") === 0;
      }

      return false;
    }

    function hasRestSpreadSibling(variable) {
      if (config.ignoreRestSiblings) {
        return variable.defs.some(def => {
          const propertyNode = def.name.parent;
          const patternNode = propertyNode.parent;
          return propertyNode.type === "Property" && patternNode.type === "ObjectPattern" && /^(?:RestElement|(?:Experimental)?RestProperty)$/u.test(patternNode.properties[patternNode.properties.length - 1].type);
        });
      }

      return false;
    }

    function isReadRef(ref) {
      return ref.isRead();
    }

    function isSelfReference(ref, nodes) {
      let scope = ref.from;

      while (scope) {
        if (nodes.indexOf(scope.block) >= 0) {
          return true;
        }

        scope = scope.upper;
      }

      return false;
    }

    function getFunctionDefinitions(variable) {
      const functionDefinitions = [];
      variable.defs.forEach(def => {
        const {
          type,
          node
        } = def;

        if (type === "FunctionName") {
          functionDefinitions.push(node);
        }

        if (type === "Variable" && node.init && (node.init.type === "FunctionExpression" || node.init.type === "ArrowFunctionExpression")) {
          functionDefinitions.push(node.init);
        }
      });
      return functionDefinitions;
    }

    function isInside(inner, outer) {
      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
    }

    function getRhsNode(ref, prevRhsNode) {
      const id = ref.identifier;
      const parent = id.parent;
      const grandparent = parent.parent;
      const refScope = ref.from.variableScope;
      const varScope = ref.resolved.scope.variableScope;
      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);

      if (prevRhsNode && isInside(id, prevRhsNode)) {
        return prevRhsNode;
      }

      if (parent.type === "AssignmentExpression" && grandparent.type === "ExpressionStatement" && id === parent.left && !canBeUsedLater) {
        return parent.right;
      }

      return null;
    }

    function isStorableFunction(funcNode, rhsNode) {
      let node = funcNode;
      let parent = funcNode.parent;

      while (parent && isInside(parent, rhsNode)) {
        switch (parent.type) {
          case "SequenceExpression":
            if (parent.expressions[parent.expressions.length - 1] !== node) {
              return false;
            }

            break;

          case "CallExpression":
          case "NewExpression":
            return parent.callee !== node;

          case "AssignmentExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
            return true;

          default:
            if (/(?:Statement|Declaration)$/u.test(parent.type)) {
              return true;
            }

        }

        node = parent;
        parent = parent.parent;
      }

      return false;
    }

    function isInsideOfStorableFunction(id, rhsNode) {
      const funcNode = astUtils.getUpperFunction(id);
      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
    }

    function isReadForItself(ref, rhsNode) {
      const id = ref.identifier;
      const parent = id.parent;
      const grandparent = parent.parent;
      return ref.isRead() && (parent.type === "AssignmentExpression" && grandparent.type === "ExpressionStatement" && parent.left === id || parent.type === "UpdateExpression" && grandparent.type === "ExpressionStatement" || rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
    }

    function isForInRef(ref) {
      let target = ref.identifier.parent;

      if (target.type === "VariableDeclarator") {
        target = target.parent.parent;
      }

      if (target.type !== "ForInStatement") {
        return false;
      }

      if (target.body.type === "BlockStatement") {
        target = target.body.body[0];
      } else {
        target = target.body;
      }

      if (!target) {
        return false;
      }

      return target.type === "ReturnStatement";
    }

    function isUsedVariable(variable) {
      const functionNodes = getFunctionDefinitions(variable),
            isFunctionDefinition = functionNodes.length > 0;
      let rhsNode = null;
      return variable.references.some(ref => {
        if (isForInRef(ref)) {
          return true;
        }

        const forItself = isReadForItself(ref, rhsNode);
        rhsNode = getRhsNode(ref, rhsNode);
        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
      });
    }

    function isAfterLastUsedArg(variable) {
      const def = variable.defs[0];
      const params = context.getDeclaredVariables(def.node);
      const posteriorParams = params.slice(params.indexOf(variable) + 1);
      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);
    }

    function collectUnusedVariables(scope, unusedVars) {
      const variables = scope.variables;
      const childScopes = scope.childScopes;
      let i, l;

      if (scope.type !== "global" || config.vars === "all") {
        for (i = 0, l = variables.length; i < l; ++i) {
          const variable = variables[i];

          if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
            continue;
          }

          if (scope.functionExpressionScope || variable.eslintUsed) {
            continue;
          }

          if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
            continue;
          }

          const def = variable.defs[0];

          if (def) {
            const type = def.type;

            if (type === "CatchClause") {
              if (config.caughtErrors === "none") {
                continue;
              }

              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
                continue;
              }
            }

            if (type === "Parameter") {
              if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
                continue;
              }

              if (config.args === "none") {
                continue;
              }

              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                continue;
              }

              if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                continue;
              }
            } else {
              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                continue;
              }
            }
          }

          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
            unusedVars.push(variable);
          }
        }
      }

      for (i = 0, l = childScopes.length; i < l; ++i) {
        collectUnusedVariables(childScopes[i], unusedVars);
      }

      return unusedVars;
    }

    return {
      "Program:exit"(programNode) {
        const unusedVars = collectUnusedVariables(context.getScope(), []);

        for (let i = 0, l = unusedVars.length; i < l; ++i) {
          const unusedVar = unusedVars[i];

          if (unusedVar.defs.length > 0) {
            context.report({
              node: unusedVar.references.length ? unusedVar.references[unusedVar.references.length - 1].identifier : unusedVar.identifiers[0],
              messageId: "unusedVar",
              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)
            });
          } else if (unusedVar.eslintExplicitGlobalComments) {
            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
            context.report({
              node: programNode,
              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),
              messageId: "unusedVar",
              data: getDefinedMessageData(unusedVar)
            });
          }
        }
      }

    };
  }

};
const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;

function parseOptions(options) {
  let functions = true;
  let classes = true;
  let variables = true;

  if (typeof options === "string") {
    functions = options !== "nofunc";
  } else if (typeof options === "object" && options !== null) {
    functions = options.functions !== false;
    classes = options.classes !== false;
    variables = options.variables !== false;
  }

  return {
    functions,
    classes,
    variables
  };
}

function isFunction(variable) {
  return variable.defs[0].type === "FunctionName";
}

function isOuterClass(variable, reference) {
  return variable.defs[0].type === "ClassName" && variable.scope.variableScope !== reference.from.variableScope;
}

function isOuterVariable(variable, reference) {
  return variable.defs[0].type === "Variable" && variable.scope.variableScope !== reference.from.variableScope;
}

function isInRange(node, location) {
  return node && node.range[0] <= location && location <= node.range[1];
}

function isInInitializer(variable, reference) {
  if (variable.scope !== reference.from) {
    return false;
  }

  let node = variable.identifiers[0].parent;
  const location = reference.identifier.range[1];

  while (node) {
    if (node.type === "VariableDeclarator") {
      if (isInRange(node.init, location)) {
        return true;
      }

      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
        return true;
      }

      break;
    } else if (node.type === "AssignmentPattern") {
      if (isInRange(node.right, location)) {
        return true;
      }
    } else if (SENTINEL_TYPE.test(node.type)) {
      break;
    }

    node = node.parent;
  }

  return false;
}

var noUseBeforeDefine = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of variables before they are defined",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-use-before-define"
    },
    schema: [{
      oneOf: [{
        enum: ["nofunc"]
      }, {
        type: "object",
        properties: {
          functions: {
            type: "boolean"
          },
          classes: {
            type: "boolean"
          },
          variables: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      usedBeforeDefined: "'{{name}}' was used before it was defined."
    }
  },

  create(context) {
    const options = parseOptions(context.options[0]);

    function isForbidden(variable, reference) {
      if (isFunction(variable)) {
        return options.functions;
      }

      if (isOuterClass(variable, reference)) {
        return options.classes;
      }

      if (isOuterVariable(variable, reference)) {
        return options.variables;
      }

      return true;
    }

    function findVariablesInScope(scope) {
      scope.references.forEach(reference => {
        const variable = reference.resolved;

        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {
          return;
        }

        context.report({
          node: reference.identifier,
          messageId: "usedBeforeDefined",
          data: reference.identifier
        });
      });
      scope.childScopes.forEach(findVariablesInScope);
    }

    return {
      Program() {
        findVariablesInScope(context.getScope());
      }

    };
  }

};
const {
  CALL: CALL$5,
  CONSTRUCT: CONSTRUCT$3,
  ReferenceTracker: ReferenceTracker$5,
  getStringIfConstant: getStringIfConstant$2
} = eslintUtils__default['default'];
const {
  RegExpParser,
  visitRegExpAST
} = regexpp__default['default'];
const parser$1 = new RegExpParser();

function getPathToRoot(node) {
  const path = [];
  let current = node;

  do {
    path.push(current);
    current = current.parent;
  } while (current);

  return path;
}

function isLookaround(node) {
  return node.type === "Assertion" && (node.kind === "lookahead" || node.kind === "lookbehind");
}

function isNegativeLookaround(node) {
  return isLookaround(node) && node.negate;
}

var noUselessBackreference = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow useless backreferences in regular expressions",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-backreference"
    },
    schema: [],
    messages: {
      nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
      forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
      backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
      disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
      intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."
    }
  },

  create(context) {
    function checkRegex(node, pattern, flags) {
      let regExpAST;

      try {
        regExpAST = parser$1.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      } catch {
        return;
      }

      visitRegExpAST(regExpAST, {
        onBackreferenceEnter(bref) {
          const group = bref.resolved,
                brefPath = getPathToRoot(bref),
                groupPath = getPathToRoot(group);
          let messageId = null;

          if (brefPath.includes(group)) {
            messageId = "nested";
          } else {
            let i = brefPath.length - 1,
                j = groupPath.length - 1;

            do {
              i--;
              j--;
            } while (brefPath[i] === groupPath[j]);

            const indexOfLowestCommonAncestor = j + 1,
                  groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),
                  commonPath = groupPath.slice(indexOfLowestCommonAncestor),
                  lowestCommonLookaround = commonPath.find(isLookaround),
                  isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === "lookbehind";

            if (!isMatchingBackward && bref.end <= group.start) {
              messageId = "forward";
            } else if (isMatchingBackward && group.end <= bref.start) {
              messageId = "backward";
            } else if (lodash__default['default'].last(groupCut).type === "Alternative") {
              messageId = "disjunctive";
            } else if (groupCut.some(isNegativeLookaround)) {
              messageId = "intoNegativeLookaround";
            }
          }

          if (messageId) {
            context.report({
              node,
              messageId,
              data: {
                bref: bref.raw,
                group: group.raw
              }
            });
          }
        }

      });
    }

    return {
      "Literal[regex]"(node) {
        const {
          pattern,
          flags
        } = node.regex;
        checkRegex(node, pattern, flags);
      },

      Program() {
        const scope = context.getScope(),
              tracker = new ReferenceTracker$5(scope),
              traceMap = {
          RegExp: {
            [CALL$5]: true,
            [CONSTRUCT$3]: true
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(traceMap)) {
          const [patternNode, flagsNode] = node.arguments,
                pattern = getStringIfConstant$2(patternNode, scope),
                flags = getStringIfConstant$2(flagsNode, scope);

          if (typeof pattern === "string") {
            checkRegex(node, pattern, flags || "");
          }
        }
      }

    };
  }

};

function isCallOrNonVariadicApply(node) {
  const callee = astUtils.skipChainExpression(node.callee);
  return callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.computed === false && (callee.property.name === "call" && node.arguments.length >= 1 || callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
}

function isValidThisArg$1(expectedThis, thisArg, sourceCode) {
  if (!expectedThis) {
    return astUtils.isNullOrUndefined(thisArg);
  }

  return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
}

var noUselessCall = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.call()` and `.apply()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-call"
    },
    schema: [],
    messages: {
      unnecessaryCall: "Unnecessary '.{{name}}()'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      CallExpression(node) {
        if (!isCallOrNonVariadicApply(node)) {
          return;
        }

        const callee = astUtils.skipChainExpression(node.callee);
        const applied = astUtils.skipChainExpression(callee.object);
        const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
        const thisArg = node.arguments[0];

        if (isValidThisArg$1(expectedThis, thisArg, sourceCode)) {
          context.report({
            node,
            messageId: "unnecessaryCall",
            data: {
              name: callee.property.name
            }
          });
        }
      }

    };
  }

};
var noUselessCatch = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `catch` clauses",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-useless-catch"
    },
    schema: [],
    messages: {
      unnecessaryCatchClause: "Unnecessary catch clause.",
      unnecessaryCatch: "Unnecessary try/catch wrapper."
    }
  },

  create(context) {
    return {
      CatchClause(node) {
        if (node.param && node.param.type === "Identifier" && node.body.body.length && node.body.body[0].type === "ThrowStatement" && node.body.body[0].argument.type === "Identifier" && node.body.body[0].argument.name === node.param.name) {
          if (node.parent.finalizer) {
            context.report({
              node,
              messageId: "unnecessaryCatchClause"
            });
          } else {
            context.report({
              node: node.parent,
              messageId: "unnecessaryCatch"
            });
          }
        }
      }

    };
  }

};
var noUselessComputedKey = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary computed property keys in objects and classes",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-computed-key"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForClassMembers: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;

    function check(node) {
      if (!node.computed) {
        return;
      }

      const key = node.key,
            nodeType = typeof key.value;
      let allowedKey;

      if (node.type === "MethodDefinition") {
        allowedKey = node.static ? "prototype" : "constructor";
      } else {
        allowedKey = "__proto__";
      }

      if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== allowedKey) {
        context.report({
          node,
          messageId: "unnecessarilyComputedProperty",
          data: {
            property: sourceCode.getText(key)
          },

          fix(fixer) {
            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);
            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);

            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {
              return null;
            }

            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
            const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
          }

        });
      }
    }

    return {
      Property: check,
      MethodDefinition: enforceForClassMembers ? check : lodash__default['default'].noop
    };
  }

};

function isConcatenation$1(node) {
  return node.type === "BinaryExpression" && node.operator === "+";
}

function isConcatOperatorToken(token) {
  return token.value === "+" && token.type === "Punctuator";
}

function getLeft(node) {
  let left = node.left;

  while (isConcatenation$1(left)) {
    left = left.right;
  }

  return left;
}

function getRight(node) {
  let right = node.right;

  while (isConcatenation$1(right)) {
    right = right.left;
  }

  return right;
}

var noUselessConcat = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary concatenation of literals or template literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-concat"
    },
    schema: [],
    messages: {
      unexpectedConcat: "Unexpected string concatenation of literals."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      BinaryExpression(node) {
        if (node.operator !== "+") {
          return;
        }

        const left = getLeft(node);
        const right = getRight(node);

        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);
          context.report({
            node,
            loc: operatorToken.loc,
            messageId: "unexpectedConcat"
          });
        }
      }

    };
  }

};

function isSingleSuperCall(body) {
  return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
}

function isSimple(node) {
  return node.type === "Identifier" || node.type === "RestElement";
}

function isSpreadArguments(superArgs) {
  return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
}

function isValidIdentifierPair(ctorParam, superArg) {
  return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
}

function isValidRestSpreadPair(ctorParam, superArg) {
  return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
}

function isValidPair(ctorParam, superArg) {
  return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
}

function isPassingThrough(ctorParams, superArgs) {
  if (ctorParams.length !== superArgs.length) {
    return false;
  }

  for (let i = 0; i < ctorParams.length; ++i) {
    if (!isValidPair(ctorParams[i], superArgs[i])) {
      return false;
    }
  }

  return true;
}

function isRedundantSuperCall(body, ctorParams) {
  return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
}

var noUselessConstructor = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary constructors",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-constructor"
    },
    schema: [],
    messages: {
      noUselessConstructor: "Useless constructor."
    }
  },

  create(context) {
    return {
      MethodDefinition: function (node) {
        if (node.kind !== "constructor") {
          return;
        }

        if (!node.value.body) {
          return;
        }

        const body = node.value.body.body;
        const ctorParams = node.value.params;
        const superClass = node.parent.parent.superClass;

        if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
          context.report({
            node,
            messageId: "noUselessConstructor"
          });
        }
      }
    };
  }

};

function union(setA, setB) {
  return new Set(function* () {
    yield* setA;
    yield* setB;
  }());
}

const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()Bk"));

function parseRegExp(regExpText) {
  const charList = [];
  regExpText.split("").reduce((state, char, index) => {
    if (!state.escapeNextChar) {
      if (char === "\\") {
        return Object.assign(state, {
          escapeNextChar: true
        });
      }

      if (char === "[" && !state.inCharClass) {
        return Object.assign(state, {
          inCharClass: true,
          startingCharClass: true
        });
      }

      if (char === "]" && state.inCharClass) {
        if (charList.length && charList[charList.length - 1].inCharClass) {
          charList[charList.length - 1].endsCharClass = true;
        }

        return Object.assign(state, {
          inCharClass: false,
          startingCharClass: false
        });
      }
    }

    charList.push({
      text: char,
      index,
      escaped: state.escapeNextChar,
      inCharClass: state.inCharClass,
      startsCharClass: state.startingCharClass,
      endsCharClass: false
    });
    return Object.assign(state, {
      escapeNextChar: false,
      startingCharClass: false
    });
  }, {
    escapeNextChar: false,
    inCharClass: false,
    startingCharClass: false
  });
  return charList;
}

var noUselessEscape = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary escape characters",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-useless-escape",
      suggestion: true
    },
    messages: {
      unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
      removeEscape: "Remove the `\\`. This maintains the current functionality.",
      escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
    },
    schema: []
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function report(node, startOffset, character) {
      const rangeStart = node.range[0] + startOffset;
      const range = [rangeStart, rangeStart + 1];
      const start = sourceCode.getLocFromIndex(rangeStart);
      context.report({
        node,
        loc: {
          start,
          end: {
            line: start.line,
            column: start.column + 1
          }
        },
        messageId: "unnecessaryEscape",
        data: {
          character
        },
        suggest: [{
          messageId: "removeEscape",

          fix(fixer) {
            return fixer.removeRange(range);
          }

        }, {
          messageId: "escapeBackslash",

          fix(fixer) {
            return fixer.insertTextBeforeRange(range, "\\");
          }

        }]
      });
    }

    function validateString(node, match) {
      const isTemplateElement = node.type === "TemplateElement";
      const escapedChar = match[0][1];
      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
      let isQuoteEscape;

      if (isTemplateElement) {
        isQuoteEscape = escapedChar === "`";

        if (escapedChar === "$") {
          isUnnecessaryEscape = match.input[match.index + 2] !== "{";
        } else if (escapedChar === "{") {
          isUnnecessaryEscape = match.input[match.index - 1] !== "$";
        }
      } else {
        isQuoteEscape = escapedChar === node.raw[0];
      }

      if (isUnnecessaryEscape && !isQuoteEscape) {
        report(node, match.index, match[0].slice(1));
      }
    }

    function check(node) {
      const isTemplateElement = node.type === "TemplateElement";

      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
        return;
      }

      if (typeof node.value === "string" || isTemplateElement) {
        if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") {
          return;
        }

        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;
        let match;

        while (match = /\\[^\d]/gu.exec(value)) {
          validateString(node, match);
        }
      } else if (node.regex) {
        parseRegExp(node.regex.pattern).filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass)).filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass)).filter(charInfo => charInfo.escaped).filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)).forEach(charInfo => report(node, charInfo.index, charInfo.text));
      }
    }

    return {
      Literal: check,
      TemplateElement: check
    };
  }

};
var noUselessRename = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow renaming import, export, and destructured assignments to the same name",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-rename"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: false
        },
        ignoreImport: {
          type: "boolean",
          default: false
        },
        ignoreExport: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode(),
          options = context.options[0] || {},
          ignoreDestructuring = options.ignoreDestructuring === true,
          ignoreImport = options.ignoreImport === true,
          ignoreExport = options.ignoreExport === true;

    function reportError(node, initial, type) {
      const name = initial.type === "Identifier" ? initial.name : initial.value;
      return context.report({
        node,
        messageId: "unnecessarilyRenamed",
        data: {
          name,
          type
        },

        fix(fixer) {
          const replacementNode = node.type === "Property" ? node.value : node.local;

          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {
            return null;
          }

          if (replacementNode.type === "AssignmentPattern" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {
            return null;
          }

          return fixer.replaceText(node, sourceCode.getText(replacementNode));
        }

      });
    }

    return {
      ObjectPattern: function (node) {
        if (ignoreDestructuring) {
          return;
        }

        for (const property of node.properties) {
          if (property.type !== "Property" || property.shorthand || property.computed) {
            continue;
          }

          const key = property.key.type === "Identifier" && property.key.name || property.key.type === "Literal" && property.key.value;
          const renamedKey = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;

          if (key === renamedKey) {
            reportError(property, property.key, "Destructuring assignment");
          }
        }
      },
      ImportSpecifier: function (node) {
        if (ignoreImport) {
          return;
        }

        if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {
          reportError(node, node.imported, "Import");
        }
      },
      ExportSpecifier: function (node) {
        if (ignoreExport) {
          return;
        }

        if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {
          reportError(node, node.local, "Export");
        }
      }
    };
  }

};

function remove(array, element) {
  const index = array.indexOf(element);

  if (index !== -1) {
    array.splice(index, 1);
  }
}

function isRemovable(node) {
  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

function isInFinally(node) {
  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {
    if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
      return true;
    }
  }

  return false;
}

var noUselessReturn = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow redundant return statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-return"
    },
    fixable: "code",
    schema: [],
    messages: {
      unnecessaryReturn: "Unnecessary return statement."
    }
  },

  create(context) {
    const segmentInfoMap = new WeakMap();
    const usedUnreachableSegments = new WeakSet();
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    function isReturned(segment) {
      const info = segmentInfoMap.get(segment);
      return !info || info.returned;
    }

    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
      const traversedSegments = providedTraversedSegments || new WeakSet();

      for (const segment of prevSegments) {
        if (!segment.reachable) {
          if (!traversedSegments.has(segment)) {
            traversedSegments.add(segment);
            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
          }

          continue;
        }

        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);
      }

      return uselessReturns;
    }

    function markReturnStatementsOnSegmentAsUsed(segment) {
      if (!segment.reachable) {
        usedUnreachableSegments.add(segment);
        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);
        return;
      }

      const info = segmentInfoMap.get(segment);

      for (const node of info.uselessReturns) {
        remove(scopeInfo.uselessReturns, node);
      }

      info.uselessReturns = [];
    }

    function markReturnStatementsOnCurrentSegmentsAsUsed() {
      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
    }

    return {
      onCodePathStart(codePath) {
        scopeInfo = {
          upper: scopeInfo,
          uselessReturns: [],
          codePath
        };
      },

      onCodePathEnd() {
        for (const node of scopeInfo.uselessReturns) {
          context.report({
            node,
            loc: node.loc,
            messageId: "unnecessaryReturn",

            fix(fixer) {
              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {
                return new fixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);
              }

              return null;
            }

          });
        }

        scopeInfo = scopeInfo.upper;
      },

      onCodePathSegmentStart(segment) {
        const info = {
          uselessReturns: getUselessReturns([], segment.allPrevSegments),
          returned: false
        };
        segmentInfoMap.set(segment, info);
      },

      ReturnStatement(node) {
        if (node.argument) {
          markReturnStatementsOnCurrentSegmentsAsUsed();
        }

        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {
          return;
        }

        for (const segment of scopeInfo.codePath.currentSegments) {
          const info = segmentInfoMap.get(segment);

          if (info) {
            info.uselessReturns.push(node);
            info.returned = true;
          }
        }

        scopeInfo.uselessReturns.push(node);
      },

      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
    };
  }

};

function isGlobal(variable) {
  return Boolean(variable.scope) && variable.scope.type === "global";
}

function getEnclosingFunctionScope(scope) {
  let currentScope = scope;

  while (currentScope.type !== "function" && currentScope.type !== "global") {
    currentScope = currentScope.upper;
  }

  return currentScope;
}

function isReferencedInClosure(variable) {
  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);
}

function isLoopAssignee(node) {
  return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
}

function isDeclarationInitialized(node) {
  return node.declarations.every(declarator => declarator.init !== null);
}

const SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;

function getScopeNode(node) {
  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
    if (SCOPE_NODE_TYPE.test(currentNode.type)) {
      return currentNode;
    }
  }

  return null;
}

function isRedeclared(variable) {
  return variable.defs.length >= 2;
}

function isUsedFromOutsideOf(scopeNode) {
  function isOutsideOfScope(reference) {
    const scope = scopeNode.range;
    const id = reference.identifier.range;
    return id[0] < scope[0] || id[1] > scope[1];
  }

  return function (variable) {
    return variable.references.some(isOutsideOfScope);
  };
}

function hasReferenceInTDZ(node) {
  const initStart = node.range[0];
  const initEnd = node.range[1];
  return variable => {
    const id = variable.defs[0].name;
    const idStart = id.range[0];
    const defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
    const defaultStart = defaultValue && defaultValue.range[0];
    const defaultEnd = defaultValue && defaultValue.range[1];
    return variable.references.some(reference => {
      const start = reference.identifier.range[0];
      const end = reference.identifier.range[1];
      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);
    });
  };
}

function hasNameDisallowedForLetDeclarations(variable) {
  return variable.name === "let";
}

var noVar = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `let` or `const` instead of `var`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-var"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedVar: "Unexpected var, use let or const instead."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function hasSelfReferenceInTDZ(declarator) {
      if (!declarator.init) {
        return false;
      }

      const variables = context.getDeclaredVariables(declarator);
      return variables.some(hasReferenceInTDZ(declarator.init));
    }

    function canFix(node) {
      const variables = context.getDeclaredVariables(node);
      const scopeNode = getScopeNode(node);

      if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {
        return false;
      }

      if (astUtils.isInLoop(node)) {
        if (variables.some(isReferencedInClosure)) {
          return false;
        }

        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
          return false;
        }
      }

      if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
        return false;
      }

      return true;
    }

    function report(node) {
      context.report({
        node,
        messageId: "unexpectedVar",

        fix(fixer) {
          const varToken = sourceCode.getFirstToken(node, {
            filter: t => t.value === "var"
          });
          return canFix(node) ? fixer.replaceText(varToken, "let") : null;
        }

      });
    }

    return {
      "VariableDeclaration:exit"(node) {
        if (node.kind === "var") {
          report(node);
        }
      }

    };
  }

};
var noVoid = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `void` operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-void"
    },
    messages: {
      noVoid: "Expected 'undefined' and instead saw 'void'."
    },
    schema: [{
      type: "object",
      properties: {
        allowAsStatement: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },

  create(context) {
    const allowAsStatement = context.options[0] && context.options[0].allowAsStatement;
    return {
      'UnaryExpression[operator="void"]'(node) {
        if (allowAsStatement && node.parent && node.parent.type === "ExpressionStatement") {
          return;
        }

        context.report({
          node,
          messageId: "noVoid"
        });
      }

    };
  }

};
const {
  escapeRegExp
} = lodash__default['default'];
const CHAR_LIMIT = 40;
var noWarningComments = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified warning terms in comments",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-warning-comments"
    },
    schema: [{
      type: "object",
      properties: {
        terms: {
          type: "array",
          items: {
            type: "string"
          }
        },
        location: {
          enum: ["start", "anywhere"]
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode(),
          configuration = context.options[0] || {},
          warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
          location = configuration.location || "start";
    const warningRegExps = warningTerms.map(function (term) {
      const escaped = escapeRegExp(term);
      let prefix;
      const suffix = /\w$/u.test(term) ? "\\b" : "";

      if (location === "start") {
        prefix = "^\\s*";
      } else if (/^\w/u.test(term)) {
        prefix = "\\b";
      } else {
        prefix = "";
      }

      if (location === "start") {
        return new RegExp(prefix + escaped + suffix, "iu");
      }

      return new RegExp(prefix + escaped + suffix + "|\\b" + term + "\\b", "iu");
    });

    function commentContainsWarningTerm(comment) {
      const matches = [];
      warningRegExps.forEach((regex, index) => {
        if (regex.test(comment)) {
          matches.push(warningTerms[index]);
        }
      });
      return matches;
    }

    function checkComment(node) {
      const comment = node.value;

      if (astUtils.isDirectiveComment(node) && /\bno-warning-comments\b/u.test(comment)) {
        return;
      }

      const matches = commentContainsWarningTerm(comment);
      matches.forEach(matchedTerm => {
        let commentToDisplay = "";
        let truncated = false;

        for (const c of comment.trim().split(/\s+/u)) {
          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;

          if (tmp.length <= CHAR_LIMIT) {
            commentToDisplay = tmp;
          } else {
            truncated = true;
            break;
          }
        }

        context.report({
          node,
          messageId: "unexpectedComment",
          data: {
            matchedTerm,
            comment: `${commentToDisplay}${truncated ? "..." : ""}`
          }
        });
      });
    }

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(checkComment);
      }

    };
  }

};
var noWhitespaceBeforeProperty = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow whitespace before properties",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-whitespace-before-property"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function reportError(node, leftToken, rightToken) {
      context.report({
        node,
        messageId: "unexpectedWhitespace",
        data: {
          propName: sourceCode.getText(node.property)
        },

        fix(fixer) {
          let replacementText = "";

          if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
            return null;
          }

          if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
            return null;
          }

          if (node.optional) {
            replacementText = "?.";
          } else if (!node.computed) {
            replacementText = ".";
          }

          return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
        }

      });
    }

    return {
      MemberExpression(node) {
        let rightToken;
        let leftToken;

        if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
          return;
        }

        if (node.computed) {
          rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
          leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
        } else {
          rightToken = sourceCode.getFirstToken(node.property);
          leftToken = sourceCode.getTokenBefore(rightToken, 1);
        }

        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
          reportError(node, leftToken, rightToken);
        }
      }

    };
  }

};
var noWith = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `with` statements",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-with"
    },
    schema: [],
    messages: {
      unexpectedWith: "Unexpected use of 'with' statement."
    }
  },

  create(context) {
    return {
      WithStatement(node) {
        context.report({
          node,
          messageId: "unexpectedWith"
        });
      }

    };
  }

};
const POSITION_SCHEMA = {
  enum: ["beside", "below", "any"]
};
var nonblockStatementBodyPosition = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of single-line statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
    },
    fixable: "whitespace",
    schema: [POSITION_SCHEMA, {
      properties: {
        overrides: {
          properties: {
            if: POSITION_SCHEMA,
            else: POSITION_SCHEMA,
            while: POSITION_SCHEMA,
            do: POSITION_SCHEMA,
            for: POSITION_SCHEMA
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectNoLinebreak: "Expected no linebreak before this statement.",
      expectLinebreak: "Expected a linebreak before this statement."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function getOption(keywordName) {
      return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
    }

    function validateStatement(node, keywordName) {
      const option = getOption(keywordName);

      if (node.type === "BlockStatement" || option === "any") {
        return;
      }

      const tokenBefore = sourceCode.getTokenBefore(node);

      if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
        context.report({
          node,
          messageId: "expectLinebreak",
          fix: fixer => fixer.insertTextBefore(node, "\n")
        });
      } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
        context.report({
          node,
          messageId: "expectNoLinebreak",

          fix(fixer) {
            if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
              return null;
            }

            return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
          }

        });
      }
    }

    return {
      IfStatement(node) {
        validateStatement(node.consequent, "if");

        if (node.alternate && node.alternate.type !== "IfStatement") {
          validateStatement(node.alternate, "else");
        }
      },

      WhileStatement: node => validateStatement(node.body, "while"),
      DoWhileStatement: node => validateStatement(node.body, "do"),
      ForStatement: node => validateStatement(node.body, "for"),
      ForInStatement: node => validateStatement(node.body, "for"),
      ForOfStatement: node => validateStatement(node.body, "for")
    };
  }

};
const OPTION_VALUE = {
  oneOf: [{
    enum: ["always", "never"]
  }, {
    type: "object",
    properties: {
      multiline: {
        type: "boolean"
      },
      minProperties: {
        type: "integer",
        minimum: 0
      },
      consistent: {
        type: "boolean"
      }
    },
    additionalProperties: false,
    minProperties: 1
  }]
};

function normalizeOptionValue(value) {
  let multiline = false;
  let minProperties = Number.POSITIVE_INFINITY;
  let consistent = false;

  if (value) {
    if (value === "always") {
      minProperties = 0;
    } else if (value === "never") {
      minProperties = Number.POSITIVE_INFINITY;
    } else {
      multiline = Boolean(value.multiline);
      minProperties = value.minProperties || Number.POSITIVE_INFINITY;
      consistent = Boolean(value.consistent);
    }
  } else {
    consistent = true;
  }

  return {
    multiline,
    minProperties,
    consistent
  };
}

function normalizeOptions(options) {
  const isNodeSpecificOption = lodash__default['default'].overSome([lodash__default['default'].isPlainObject, lodash__default['default'].isString]);

  if (lodash__default['default'].isPlainObject(options) && Object.values(options).some(isNodeSpecificOption)) {
    return {
      ObjectExpression: normalizeOptionValue(options.ObjectExpression),
      ObjectPattern: normalizeOptionValue(options.ObjectPattern),
      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
    };
  }

  const value = normalizeOptionValue(options);
  return {
    ObjectExpression: value,
    ObjectPattern: value,
    ImportDeclaration: value,
    ExportNamedDeclaration: value
  };
}

function areLineBreaksRequired(node, options, first, last) {
  let objectProperties;

  if (node.type === "ObjectExpression" || node.type === "ObjectPattern") {
    objectProperties = node.properties;
  } else {
    objectProperties = node.specifiers.filter(s => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
  }

  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;
}

var objectCurlyNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks after opening and before closing braces",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-curly-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [OPTION_VALUE, {
        type: "object",
        properties: {
          ObjectExpression: OPTION_VALUE,
          ObjectPattern: OPTION_VALUE,
          ImportDeclaration: OPTION_VALUE,
          ExportDeclaration: OPTION_VALUE
        },
        additionalProperties: false,
        minProperties: 1
      }]
    }],
    messages: {
      unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
      unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
      expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
      expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const normalizedOptions = normalizeOptions(context.options[0]);

    function check(node) {
      const options = normalizedOptions[node.type];

      if (node.type === "ImportDeclaration" && !node.specifiers.some(specifier => specifier.type === "ImportSpecifier") || node.type === "ExportNamedDeclaration" && !node.specifiers.some(specifier => specifier.type === "ExportSpecifier")) {
        return;
      }

      const openBrace = sourceCode.getFirstToken(node, token => token.value === "{");
      let closeBrace;

      if (node.typeAnnotation) {
        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
      } else {
        closeBrace = sourceCode.getLastToken(node, token => token.value === "}");
      }

      let first = sourceCode.getTokenAfter(openBrace, {
        includeComments: true
      });
      let last = sourceCode.getTokenBefore(closeBrace, {
        includeComments: true
      });
      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);
      const hasCommentsFirstToken = astUtils.isCommentToken(first);
      const hasCommentsLastToken = astUtils.isCommentToken(last);
      first = sourceCode.getTokenAfter(openBrace);
      last = sourceCode.getTokenBefore(closeBrace);

      if (needsLineBreaks) {
        if (astUtils.isTokenOnSameLine(openBrace, first)) {
          context.report({
            messageId: "expectedLinebreakAfterOpeningBrace",
            node,
            loc: openBrace.loc,

            fix(fixer) {
              if (hasCommentsFirstToken) {
                return null;
              }

              return fixer.insertTextAfter(openBrace, "\n");
            }

          });
        }

        if (astUtils.isTokenOnSameLine(last, closeBrace)) {
          context.report({
            messageId: "expectedLinebreakBeforeClosingBrace",
            node,
            loc: closeBrace.loc,

            fix(fixer) {
              if (hasCommentsLastToken) {
                return null;
              }

              return fixer.insertTextBefore(closeBrace, "\n");
            }

          });
        }
      } else {
        const consistent = options.consistent;
        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);

        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
          context.report({
            messageId: "unexpectedLinebreakAfterOpeningBrace",
            node,
            loc: openBrace.loc,

            fix(fixer) {
              if (hasCommentsFirstToken) {
                return null;
              }

              return fixer.removeRange([openBrace.range[1], first.range[0]]);
            }

          });
        }

        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
          context.report({
            messageId: "unexpectedLinebreakBeforeClosingBrace",
            node,
            loc: closeBrace.loc,

            fix(fixer) {
              if (hasCommentsLastToken) {
                return null;
              }

              return fixer.removeRange([last.range[1], closeBrace.range[0]]);
            }

          });
        }
      }
    }

    return {
      ObjectExpression: check,
      ObjectPattern: check,
      ImportDeclaration: check,
      ExportNamedDeclaration: check
    };
  }

};
var objectCurlySpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside braces",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        arraysInObjects: {
          type: "boolean"
        },
        objectsInObjects: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      requireSpaceBefore: "A space is required before '{{token}}'.",
      requireSpaceAfter: "A space is required after '{{token}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{token}}'."
    }
  },

  create(context) {
    const spaced = context.options[0] === "always",
          sourceCode = context.getSourceCode();

    function isOptionSet(option) {
      return context.options[1] ? context.options[1][option] === !spaced : false;
    }

    const options = {
      spaced,
      arraysInObjectsException: isOptionSet("arraysInObjects"),
      objectsInObjectsException: isOptionSet("objectsInObjects")
    };

    function reportNoBeginningSpace(node, token) {
      const nextToken = context.getSourceCode().getTokenAfter(token, {
        includeComments: true
      });
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          token: token.value
        },

        fix(fixer) {
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }

      });
    }

    function reportNoEndingSpace(node, token) {
      const previousToken = context.getSourceCode().getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        node,
        loc: {
          start: previousToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          token: token.value
        },

        fix(fixer) {
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }

      });
    }

    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "requireSpaceAfter",
        data: {
          token: token.value
        },

        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }

      });
    }

    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "requireSpaceBefore",
        data: {
          token: token.value
        },

        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }

      });
    }

    function validateBraceSpacing(node, first, second, penultimate, last) {
      if (astUtils.isTokenOnSameLine(first, second)) {
        const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);

        if (options.spaced && !firstSpaced) {
          reportRequiredBeginningSpace(node, first);
        }

        if (!options.spaced && firstSpaced && second.type !== "Line") {
          reportNoBeginningSpace(node, first);
        }
      }

      if (astUtils.isTokenOnSameLine(penultimate, last)) {
        const shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
        const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
        const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;
        const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);

        if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
          reportRequiredEndingSpace(node, last);
        }

        if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
          reportNoEndingSpace(node, last);
        }
      }
    }

    function getClosingBraceOfObject(node) {
      const lastProperty = node.properties[node.properties.length - 1];
      return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
    }

    function checkForObject(node) {
      if (node.properties.length === 0) {
        return;
      }

      const first = sourceCode.getFirstToken(node),
            last = getClosingBraceOfObject(node),
            second = sourceCode.getTokenAfter(first, {
        includeComments: true
      }),
            penultimate = sourceCode.getTokenBefore(last, {
        includeComments: true
      });
      validateBraceSpacing(node, first, second, penultimate, last);
    }

    return {
      ObjectPattern: checkForObject,
      ObjectExpression: checkForObject,
      ImportDeclaration: function (node) {
        if (node.specifiers.length === 0) {
          return;
        }

        let firstSpecifier = node.specifiers[0];
        const lastSpecifier = node.specifiers[node.specifiers.length - 1];

        if (lastSpecifier.type !== "ImportSpecifier") {
          return;
        }

        if (firstSpecifier.type !== "ImportSpecifier") {
          firstSpecifier = node.specifiers[1];
        }

        const first = sourceCode.getTokenBefore(firstSpecifier),
              last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
              second = sourceCode.getTokenAfter(first, {
          includeComments: true
        }),
              penultimate = sourceCode.getTokenBefore(last, {
          includeComments: true
        });
        validateBraceSpacing(node, first, second, penultimate, last);
      },
      ExportNamedDeclaration: function (node) {
        if (node.specifiers.length === 0) {
          return;
        }

        const firstSpecifier = node.specifiers[0],
              lastSpecifier = node.specifiers[node.specifiers.length - 1],
              first = sourceCode.getTokenBefore(firstSpecifier),
              last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
              second = sourceCode.getTokenAfter(first, {
          includeComments: true
        }),
              penultimate = sourceCode.getTokenBefore(last, {
          includeComments: true
        });
        validateBraceSpacing(node, first, second, penultimate, last);
      }
    };
  }

};
var objectPropertyNewline = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce placing object properties on separate lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-property-newline"
    },
    schema: [{
      type: "object",
      properties: {
        allowAllPropertiesOnSameLine: {
          type: "boolean",
          default: false
        },
        allowMultiplePropertiesPerLine: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace",
    messages: {
      propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
      propertiesOnNewline: "Object properties must go on a new line."
    }
  },

  create(context) {
    const allowSameLine = context.options[0] && (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine);
    const messageId = allowSameLine ? "propertiesOnNewlineAll" : "propertiesOnNewline";
    const sourceCode = context.getSourceCode();
    return {
      ObjectExpression(node) {
        if (allowSameLine) {
          if (node.properties.length > 1) {
            const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
            const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);

            if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
              return;
            }
          }
        }

        for (let i = 1; i < node.properties.length; i++) {
          const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
          const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);

          if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
            context.report({
              node,
              loc: firstTokenOfCurrentProperty.loc,
              messageId,

              fix(fixer) {
                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];

                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
                  return null;
                }

                return fixer.replaceTextRange(rangeAfterComma, "\n");
              }

            });
          }
        }
      }

    };
  }

};
const OPTIONS = {
  always: "always",
  never: "never",
  methods: "methods",
  properties: "properties",
  consistent: "consistent",
  consistentAsNeeded: "consistent-as-needed"
};
var objectShorthand = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow method and property shorthand syntax for object literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-shorthand"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods", "properties"]
        }, {
          type: "object",
          properties: {
            avoidQuotes: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods"]
        }, {
          type: "object",
          properties: {
            ignoreConstructors: {
              type: "boolean"
            },
            avoidQuotes: {
              type: "boolean"
            },
            avoidExplicitReturnArrows: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
      expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
      expectedPropertyShorthand: "Expected property shorthand.",
      expectedPropertyLongform: "Expected longform property syntax.",
      expectedMethodShorthand: "Expected method shorthand.",
      expectedMethodLongform: "Expected longform method syntax.",
      unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
    }
  },

  create(context) {
    const APPLY = context.options[0] || OPTIONS.always;
    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
    const APPLY_NEVER = APPLY === OPTIONS.never;
    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
    const PARAMS = context.options[1] || {};
    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
    const AVOID_QUOTES = PARAMS.avoidQuotes;
    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
    const sourceCode = context.getSourceCode();

    function isConstructor(name) {
      const match = /[^_$0-9]/u.exec(name);

      if (!match) {
        return false;
      }

      const firstChar = name.charAt(match.index);
      return firstChar === firstChar.toUpperCase();
    }

    function canHaveShorthand(property) {
      return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
    }

    function isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string";
    }

    function isShorthand(property) {
      return property.shorthand || property.method;
    }

    function isRedundant(property) {
      const value = property.value;

      if (value.type === "FunctionExpression") {
        return !value.id;
      }

      if (value.type === "Identifier") {
        return astUtils.getStaticPropertyName(property) === value.name;
      }

      return false;
    }

    function checkConsistency(node, checkRedundancy) {
      const properties = node.properties.filter(canHaveShorthand);

      if (properties.length > 0) {
        const shorthandProperties = properties.filter(isShorthand);

        if (shorthandProperties.length !== properties.length) {
          if (shorthandProperties.length > 0) {
            context.report({
              node,
              messageId: "unexpectedMix"
            });
          } else if (checkRedundancy) {
            const canAlwaysUseShorthand = properties.every(isRedundant);

            if (canAlwaysUseShorthand) {
              context.report({
                node,
                messageId: "expectedAllPropertiesShorthanded"
              });
            }
          }
        }
      }
    }

    function makeFunctionShorthand(fixer, node) {
      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
      let keyPrefix = "";

      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {
        return null;
      }

      if (node.value.async) {
        keyPrefix += "async ";
      }

      if (node.value.generator) {
        keyPrefix += "*";
      }

      const fixRange = [firstKeyToken.range[0], node.range[1]];
      const methodPrefix = keyPrefix + keyText;

      if (node.value.type === "FunctionExpression") {
        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === "Keyword" && token.value === "function");
        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;
        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));
      }

      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);
      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);
      let shouldAddParensAroundParameters = false;
      let tokenBeforeParams;

      if (node.value.params.length === 0) {
        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);
      } else {
        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);
      }

      if (node.value.params.length === 1) {
        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);
        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];
        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;
      }

      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];
      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];
      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);
      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;
      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);
    }

    function makeFunctionLongform(fixer, node) {
      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === "[") : sourceCode.getFirstToken(node.key);
      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === "]") : sourceCode.getLastToken(node.key);
      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
      let functionHeader = "function";

      if (node.value.async) {
        functionHeader = `async ${functionHeader}`;
      }

      if (node.value.generator) {
        functionHeader = `${functionHeader}*`;
      }

      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);
    }

    const lexicalScopeStack = [];
    const arrowsWithLexicalIdentifiers = new WeakSet();
    const argumentsIdentifiers = new WeakSet();

    function enterFunction() {
      lexicalScopeStack.unshift(new Set());
      context.getScope().variables.filter(variable => variable.name === "arguments").forEach(variable => {
        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));
      });
    }

    function exitFunction() {
      lexicalScopeStack.shift();
    }

    function reportLexicalIdentifier() {
      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));
    }

    return {
      Program: enterFunction,
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      "Program:exit": exitFunction,
      "FunctionDeclaration:exit": exitFunction,
      "FunctionExpression:exit": exitFunction,

      ArrowFunctionExpression(node) {
        lexicalScopeStack[0].add(node);
      },

      "ArrowFunctionExpression:exit"(node) {
        lexicalScopeStack[0].delete(node);
      },

      ThisExpression: reportLexicalIdentifier,
      Super: reportLexicalIdentifier,

      MetaProperty(node) {
        if (node.meta.name === "new" && node.property.name === "target") {
          reportLexicalIdentifier();
        }
      },

      Identifier(node) {
        if (argumentsIdentifiers.has(node)) {
          reportLexicalIdentifier();
        }
      },

      ObjectExpression(node) {
        if (APPLY_CONSISTENT) {
          checkConsistency(node, false);
        } else if (APPLY_CONSISTENT_AS_NEEDED) {
          checkConsistency(node, true);
        }
      },

      "Property:exit"(node) {
        const isConciseProperty = node.method || node.shorthand;

        if (node.parent.type === "ObjectPattern") {
          return;
        }

        if (node.kind === "get" || node.kind === "set") {
          return;
        }

        if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
          return;
        }

        if (isConciseProperty) {
          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
            const messageId = APPLY_NEVER ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
            context.report({
              node,
              messageId,
              fix: fixer => makeFunctionLongform(fixer, node)
            });
          } else if (APPLY_NEVER) {
            context.report({
              node,
              messageId: "expectedPropertyLongform",
              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)
            });
          }
        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
          if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
            return;
          }

          if (AVOID_QUOTES && isStringLiteral(node.key)) {
            return;
          }

          if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
            context.report({
              node,
              messageId: "expectedMethodShorthand",
              fix: fixer => makeFunctionShorthand(fixer, node)
            });
          }
        } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
          context.report({
            node,
            messageId: "expectedPropertyShorthand",

            fix(fixer) {
              return fixer.replaceText(node, node.value.name);
            }

          });
        } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
          if (AVOID_QUOTES) {
            return;
          }

          context.report({
            node,
            messageId: "expectedPropertyShorthand",

            fix(fixer) {
              return fixer.replaceText(node, node.value.name);
            }

          });
        }
      }

    };
  }

};
var oneVarDeclarationPerLine = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow newlines around variable declarations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/one-var-declaration-per-line"
    },
    schema: [{
      enum: ["always", "initializations"]
    }],
    fixable: "whitespace",
    messages: {
      expectVarOnNewline: "Expected variable declaration to be on a new line."
    }
  },

  create(context) {
    const always = context.options[0] === "always";

    function isForTypeSpecifier(keyword) {
      return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    return {
      VariableDeclaration: function (node) {
        if (isForTypeSpecifier(node.parent.type)) {
          return;
        }

        const declarations = node.declarations;
        let prev;
        declarations.forEach(current => {
          if (prev && prev.loc.end.line === current.loc.start.line) {
            if (always || prev.init || current.init) {
              context.report({
                node,
                messageId: "expectVarOnNewline",
                loc: current.loc,
                fix: fixer => fixer.insertTextBefore(current, "\n")
              });
            }
          }

          prev = current;
        });
      }
    };
  }

};

function isInStatementList(node) {
  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

var oneVar = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce variables to be declared either together or separately in functions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/one-var"
    },
    fixable: "code",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consecutive"]
      }, {
        type: "object",
        properties: {
          separateRequires: {
            type: "boolean"
          },
          var: {
            enum: ["always", "never", "consecutive"]
          },
          let: {
            enum: ["always", "never", "consecutive"]
          },
          const: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          initialized: {
            enum: ["always", "never", "consecutive"]
          },
          uninitialized: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
      combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
      splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
      splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
      splitRequires: "Split requires to be separated into a single block.",
      combine: "Combine this with the previous '{{type}}' statement.",
      split: "Split '{{type}}' declarations into multiple statements."
    }
  },

  create(context) {
    const MODE_ALWAYS = "always";
    const MODE_NEVER = "never";
    const MODE_CONSECUTIVE = "consecutive";
    const mode = context.options[0] || "always";
    const options = {};

    if (typeof mode === "string") {
      options.var = {
        uninitialized: mode,
        initialized: mode
      };
      options.let = {
        uninitialized: mode,
        initialized: mode
      };
      options.const = {
        uninitialized: mode,
        initialized: mode
      };
    } else if (typeof mode === "object") {
      options.separateRequires = !!mode.separateRequires;
      options.var = {
        uninitialized: mode.var,
        initialized: mode.var
      };
      options.let = {
        uninitialized: mode.let,
        initialized: mode.let
      };
      options.const = {
        uninitialized: mode.const,
        initialized: mode.const
      };

      if (Object.prototype.hasOwnProperty.call(mode, "uninitialized")) {
        options.var.uninitialized = mode.uninitialized;
        options.let.uninitialized = mode.uninitialized;
        options.const.uninitialized = mode.uninitialized;
      }

      if (Object.prototype.hasOwnProperty.call(mode, "initialized")) {
        options.var.initialized = mode.initialized;
        options.let.initialized = mode.initialized;
        options.const.initialized = mode.initialized;
      }
    }

    const sourceCode = context.getSourceCode();
    const functionStack = [];
    const blockStack = [];

    function startBlock() {
      blockStack.push({
        let: {
          initialized: false,
          uninitialized: false
        },
        const: {
          initialized: false,
          uninitialized: false
        }
      });
    }

    function startFunction() {
      functionStack.push({
        initialized: false,
        uninitialized: false
      });
      startBlock();
    }

    function endBlock() {
      blockStack.pop();
    }

    function endFunction() {
      functionStack.pop();
      endBlock();
    }

    function isRequire(decl) {
      return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
    }

    function recordTypes(statementType, declarations, currentScope) {
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init === null) {
          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
            currentScope.uninitialized = true;
          }
        } else {
          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
            if (options.separateRequires && isRequire(declarations[i])) {
              currentScope.required = true;
            } else {
              currentScope.initialized = true;
            }
          }
        }
      }
    }

    function getCurrentScope(statementType) {
      let currentScope;

      if (statementType === "var") {
        currentScope = functionStack[functionStack.length - 1];
      } else if (statementType === "let") {
        currentScope = blockStack[blockStack.length - 1].let;
      } else if (statementType === "const") {
        currentScope = blockStack[blockStack.length - 1].const;
      }

      return currentScope;
    }

    function countDeclarations(declarations) {
      const counts = {
        uninitialized: 0,
        initialized: 0
      };

      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init === null) {
          counts.uninitialized++;
        } else {
          counts.initialized++;
        }
      }

      return counts;
    }

    function hasOnlyOneStatement(statementType, declarations) {
      const declarationCounts = countDeclarations(declarations);
      const currentOptions = options[statementType] || {};
      const currentScope = getCurrentScope(statementType);
      const hasRequires = declarations.some(isRequire);

      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
        if (currentScope.uninitialized || currentScope.initialized) {
          if (!hasRequires) {
            return false;
          }
        }
      }

      if (declarationCounts.uninitialized > 0) {
        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
          return false;
        }
      }

      if (declarationCounts.initialized > 0) {
        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
          if (!hasRequires) {
            return false;
          }
        }
      }

      if (currentScope.required && hasRequires) {
        return false;
      }

      recordTypes(statementType, declarations, currentScope);
      return true;
    }

    function joinDeclarations(declarations) {
      const declaration = declarations[0];
      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);
      const previousNode = body[currentIndex - 1];
      return fixer => {
        const type = sourceCode.getTokenBefore(declaration);
        const prevSemi = sourceCode.getTokenBefore(type);
        const res = [];

        if (previousNode && previousNode.kind === sourceCode.getText(type)) {
          if (prevSemi.value === ";") {
            res.push(fixer.replaceText(prevSemi, ","));
          } else {
            res.push(fixer.insertTextAfter(prevSemi, ","));
          }

          res.push(fixer.replaceText(type, ""));
        }

        return res;
      };
    }

    function splitDeclarations(declaration) {
      const {
        parent
      } = declaration;

      if (!isInStatementList(parent.type === "ExportNamedDeclaration" ? parent : declaration)) {
        return null;
      }

      return fixer => declaration.declarations.map(declarator => {
        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);

        if (tokenAfterDeclarator === null) {
          return null;
        }

        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {
          includeComments: true
        });

        if (tokenAfterDeclarator.value !== ",") {
          return null;
        }

        const exportPlacement = declaration.parent.type === "ExportNamedDeclaration" ? "export " : "";

        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {
          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);
        }

        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === "Line" || afterComma.type === "Block") {
          let lastComment = afterComma;

          while (lastComment.type === "Line" || lastComment.type === "Block") {
            lastComment = sourceCode.getTokenAfter(lastComment, {
              includeComments: true
            });
          }

          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);
        }

        return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);
      }).filter(x => x);
    }

    return {
      Program: startFunction,
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      BlockStatement: startBlock,
      ForStatement: startBlock,
      ForInStatement: startBlock,
      ForOfStatement: startBlock,
      SwitchStatement: startBlock,
      VariableDeclaration: function (node) {
        const parent = node.parent;
        const type = node.kind;

        if (!options[type]) {
          return;
        }

        const declarations = node.declarations;
        const declarationCounts = countDeclarations(declarations);
        const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);

        if (options[type].initialized === MODE_ALWAYS) {
          if (options.separateRequires && mixedRequires) {
            context.report({
              node,
              messageId: "splitRequires"
            });
          }
        }

        const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;

        if (nodeIndex > 0) {
          const previousNode = parent.body[nodeIndex - 1];
          const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
          const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);

          if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {
            const previousDeclCounts = countDeclarations(previousNode.declarations);

            if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {
              context.report({
                node,
                messageId: "combine",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {
              context.report({
                node,
                messageId: "combineInitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {
              context.report({
                node,
                messageId: "combineUninitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }

        if (!hasOnlyOneStatement(type, declarations)) {
          if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
            context.report({
              node,
              messageId: "combine",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          } else {
            if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {
              context.report({
                node,
                messageId: "combineInitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }

            if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {
              if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
                return;
              }

              context.report({
                node,
                messageId: "combineUninitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }

        if (parent.type !== "ForStatement" || parent.init !== node) {
          const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;

          if (totalDeclarations > 1) {
            if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
              context.report({
                node,
                messageId: "split",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
              context.report({
                node,
                messageId: "splitInitialized",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
              context.report({
                node,
                messageId: "splitUninitialized",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            }
          }
        }
      },
      "ForStatement:exit": endBlock,
      "ForOfStatement:exit": endBlock,
      "ForInStatement:exit": endBlock,
      "SwitchStatement:exit": endBlock,
      "BlockStatement:exit": endBlock,
      "Program:exit": endFunction,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction
    };
  }

};

function isCommutativeOperatorWithShorthand(operator) {
  return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}

function isNonCommutativeOperatorWithShorthand(operator) {
  return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
}

function canBeFixed(node) {
  return node.type === "Identifier" || node.type === "MemberExpression" && (node.object.type === "Identifier" || node.object.type === "ThisExpression") && (!node.computed || node.property.type === "Literal");
}

var operatorAssignment = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow assignment operator shorthand where possible",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/operator-assignment"
    },
    schema: [{
      enum: ["always", "never"]
    }],
    fixable: "code",
    messages: {
      replaced: "Assignment can be replaced with operator assignment.",
      unexpected: "Unexpected operator assignment shorthand."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function getOperatorToken(node) {
      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
    }

    return {
      AssignmentExpression: context.options[0] !== "never" ? function (node) {
        if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
          return;
        }

        const left = node.left;
        const expr = node.right;
        const operator = expr.operator;

        if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
          if (astUtils.isSameReference(left, expr.left, true)) {
            context.report({
              node,
              messageId: "replaced",

              fix(fixer) {
                if (canBeFixed(left) && canBeFixed(expr.left)) {
                  const equalsToken = getOperatorToken(node);
                  const operatorToken = getOperatorToken(expr);
                  const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                  const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);

                  if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {
                    return null;
                  }

                  return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);
                }

                return null;
              }

            });
          } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {
            context.report({
              node,
              messageId: "replaced"
            });
          }
        }
      } : function (node) {
        if (node.operator !== "=" && !astUtils.isLogicalAssignmentOperator(node.operator)) {
          context.report({
            node,
            messageId: "unexpected",

            fix(fixer) {
              if (canBeFixed(node.left)) {
                const firstToken = sourceCode.getFirstToken(node);
                const operatorToken = getOperatorToken(node);
                const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                const newOperator = node.operator.slice(0, -1);
                let rightText;

                if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {
                  return null;
                }

                if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({
                  type: "BinaryExpression",
                  operator: newOperator
                }) && !astUtils.isParenthesised(sourceCode, node.right)) {
                  rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
                } else {
                  const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, {
                    includeComments: true
                  });
                  let rightTextPrefix = "";

                  if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({
                    type: "Punctuator",
                    value: newOperator
                  }, tokenAfterOperator)) {
                    rightTextPrefix = " ";
                  }

                  rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;
                }

                return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
              }

              return null;
            }

          });
        }
      }
    };
  }

};
var operatorLinebreak = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style for operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/operator-linebreak"
    },
    schema: [{
      enum: ["after", "before", "none", null]
    }, {
      type: "object",
      properties: {
        overrides: {
          type: "object",
          additionalProperties: {
            enum: ["after", "before", "none", "ignore"]
          }
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
      operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
      badLinebreak: "Bad line breaking before and after '{{operator}}'.",
      noLinebreak: "There should be no line break before or after '{{operator}}'."
    }
  },

  create(context) {
    const usedDefaultGlobal = !context.options[0];
    const globalStyle = context.options[0] || "after";
    const options = context.options[1] || {};
    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};

    if (usedDefaultGlobal && !styleOverrides["?"]) {
      styleOverrides["?"] = "before";
    }

    if (usedDefaultGlobal && !styleOverrides[":"]) {
      styleOverrides[":"] = "before";
    }

    const sourceCode = context.getSourceCode();

    function getFixer(operatorToken, desiredStyle) {
      return fixer => {
        const tokenBefore = sourceCode.getTokenBefore(operatorToken);
        const tokenAfter = sourceCode.getTokenAfter(operatorToken);
        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
        let newTextBefore, newTextAfter;

        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
          if (sourceCode.getTokenBefore(operatorToken, {
            includeComments: true
          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {
            includeComments: true
          }) !== tokenAfter) {
            return null;
          }

          newTextBefore = textAfter;
          newTextAfter = textBefore;
        } else {
          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
          newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
          newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");

          if (newTextBefore === textBefore && newTextAfter === textAfter) {
            return null;
          }
        }

        if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
          newTextAfter += " ";
        }

        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
      };
    }

    function validateNode(node, leftSide) {
      const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
      const leftToken = sourceCode.getTokenBefore(operatorToken);
      const rightToken = sourceCode.getTokenAfter(operatorToken);
      const operator = operatorToken.value;
      const operatorStyleOverride = styleOverrides[operator];
      const style = operatorStyleOverride || globalStyle;
      const fix = getFixer(operatorToken, style);
      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) ;else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
        context.report({
          node,
          loc: operatorToken.loc,
          messageId: "badLinebreak",
          data: {
            operator
          },
          fix
        });
      } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
        context.report({
          node,
          loc: operatorToken.loc,
          messageId: "operatorAtBeginning",
          data: {
            operator
          },
          fix
        });
      } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
        context.report({
          node,
          loc: operatorToken.loc,
          messageId: "operatorAtEnd",
          data: {
            operator
          },
          fix
        });
      } else if (style === "none") {
        context.report({
          node,
          loc: operatorToken.loc,
          messageId: "noLinebreak",
          data: {
            operator
          },
          fix
        });
      }
    }

    function validateBinaryExpression(node) {
      validateNode(node, node.left);
    }

    return {
      BinaryExpression: validateBinaryExpression,
      LogicalExpression: validateBinaryExpression,
      AssignmentExpression: validateBinaryExpression,

      VariableDeclarator(node) {
        if (node.init) {
          validateNode(node, node.id);
        }
      },

      ConditionalExpression(node) {
        validateNode(node, node.test);
        validateNode(node, node.consequent);
      }

    };
  }

};
var paddedBlocks = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding within blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/padded-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          blocks: {
            enum: ["always", "never"]
          },
          switches: {
            enum: ["always", "never"]
          },
          classes: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: false,
        minProperties: 1
      }]
    }, {
      type: "object",
      properties: {
        allowSingleLineBlocks: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      alwaysPadBlock: "Block must be padded by blank lines.",
      neverPadBlock: "Block must not be padded by blank lines."
    }
  },

  create(context) {
    const options = {};
    const typeOptions = context.options[0] || "always";
    const exceptOptions = context.options[1] || {};

    if (typeof typeOptions === "string") {
      const shouldHavePadding = typeOptions === "always";
      options.blocks = shouldHavePadding;
      options.switches = shouldHavePadding;
      options.classes = shouldHavePadding;
    } else {
      if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) {
        options.blocks = typeOptions.blocks === "always";
      }

      if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) {
        options.switches = typeOptions.switches === "always";
      }

      if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) {
        options.classes = typeOptions.classes === "always";
      }
    }

    if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) {
      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
    }

    const sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
      if (node.type === "SwitchStatement") {
        return sourceCode.getTokenBefore(node.cases[0]);
      }

      return sourceCode.getFirstToken(node);
    }

    function isComment(node) {
      return node.type === "Line" || node.type === "Block";
    }

    function isPaddingBetweenTokens(first, second) {
      return second.loc.start.line - first.loc.end.line >= 2;
    }

    function getFirstBlockToken(token) {
      let prev,
          first = token;

      do {
        prev = first;
        first = sourceCode.getTokenAfter(first, {
          includeComments: true
        });
      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);

      return first;
    }

    function getLastBlockToken(token) {
      let last = token,
          next;

      do {
        next = last;
        last = sourceCode.getTokenBefore(last, {
          includeComments: true
        });
      } while (isComment(last) && last.loc.end.line === next.loc.start.line);

      return last;
    }

    function requirePaddingFor(node) {
      switch (node.type) {
        case "BlockStatement":
          return options.blocks;

        case "SwitchStatement":
          return options.switches;

        case "ClassBody":
          return options.classes;

        default:
          throw new Error("unreachable");
      }
    }

    function checkPadding(node) {
      const openBrace = getOpenBrace(node),
            firstBlockToken = getFirstBlockToken(openBrace),
            tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {
        includeComments: true
      }),
            closeBrace = sourceCode.getLastToken(node),
            lastBlockToken = getLastBlockToken(closeBrace),
            tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {
        includeComments: true
      }),
            blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
            blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);

      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
        return;
      }

      if (requirePaddingFor(node)) {
        if (!blockHasTopPadding) {
          context.report({
            node,
            loc: {
              start: tokenBeforeFirst.loc.start,
              end: firstBlockToken.loc.start
            },

            fix(fixer) {
              return fixer.insertTextAfter(tokenBeforeFirst, "\n");
            },

            messageId: "alwaysPadBlock"
          });
        }

        if (!blockHasBottomPadding) {
          context.report({
            node,
            loc: {
              end: tokenAfterLast.loc.start,
              start: lastBlockToken.loc.end
            },

            fix(fixer) {
              return fixer.insertTextBefore(tokenAfterLast, "\n");
            },

            messageId: "alwaysPadBlock"
          });
        }
      } else {
        if (blockHasTopPadding) {
          context.report({
            node,
            loc: {
              start: tokenBeforeFirst.loc.start,
              end: firstBlockToken.loc.start
            },

            fix(fixer) {
              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
            },

            messageId: "neverPadBlock"
          });
        }

        if (blockHasBottomPadding) {
          context.report({
            node,
            loc: {
              end: tokenAfterLast.loc.start,
              start: lastBlockToken.loc.end
            },
            messageId: "neverPadBlock",

            fix(fixer) {
              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
            }

          });
        }
      }
    }

    const rule = {};

    if (Object.prototype.hasOwnProperty.call(options, "switches")) {
      rule.SwitchStatement = function (node) {
        if (node.cases.length === 0) {
          return;
        }

        checkPadding(node);
      };
    }

    if (Object.prototype.hasOwnProperty.call(options, "blocks")) {
      rule.BlockStatement = function (node) {
        if (node.body.length === 0) {
          return;
        }

        checkPadding(node);
      };
    }

    if (Object.prototype.hasOwnProperty.call(options, "classes")) {
      rule.ClassBody = function (node) {
        if (node.body.length === 0) {
          return;
        }

        checkPadding(node);
      };
    }

    return rule;
  }

};
const LT = `[${Array.from(astUtils.LINEBREAKS).join("")}]`;
const PADDING_LINE_SEQUENCE = new RegExp("^(\\s*?)\\s*(\\s*;?)$", "u");
const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
const CJS_IMPORT = /^require\(/u;

function newKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword
  };
}

function newSinglelineKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
  };
}

function newMultilineKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
  };
}

function newNodeTypeTester(type) {
  return {
    test: node => node.type === type
  };
}

function isIIFEStatement(node) {
  if (node.type === "ExpressionStatement") {
    let call = astUtils.skipChainExpression(node.expression);

    if (call.type === "UnaryExpression") {
      call = astUtils.skipChainExpression(call.argument);
    }

    return call.type === "CallExpression" && astUtils.isFunction(call.callee);
  }

  return false;
}

function isBlockLikeStatement(sourceCode, node) {
  if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
    return true;
  }

  if (isIIFEStatement(node)) {
    return true;
  }

  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;
  return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
}

function isDirective(node, sourceCode) {
  return node.type === "ExpressionStatement" && (node.parent.type === "Program" || node.parent.type === "BlockStatement" && astUtils.isFunction(node.parent.parent)) && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
}

function isDirectivePrologue(node, sourceCode) {
  if (isDirective(node, sourceCode)) {
    for (const sibling of node.parent.body) {
      if (sibling === node) {
        break;
      }

      if (!isDirective(sibling, sourceCode)) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function getActualLastToken(sourceCode, node) {
  const semiToken = sourceCode.getLastToken(node);
  const prevToken = sourceCode.getTokenBefore(semiToken);
  const nextToken = sourceCode.getTokenAfter(semiToken);
  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);
  return isSemicolonLessStyle ? prevToken : semiToken;
}

function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
  return trailingSpaces + indentSpaces;
}

function verifyForAny() {}

function verifyForNever(context, _, nextNode, paddingLines) {
  if (paddingLines.length === 0) {
    return;
  }

  context.report({
    node: nextNode,
    messageId: "unexpectedBlankLine",

    fix(fixer) {
      if (paddingLines.length >= 2) {
        return null;
      }

      const prevToken = paddingLines[0][0];
      const nextToken = paddingLines[0][1];
      const start = prevToken.range[1];
      const end = nextToken.range[0];
      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
      return fixer.replaceTextRange([start, end], text);
    }

  });
}

function verifyForAlways(context, prevNode, nextNode, paddingLines) {
  if (paddingLines.length > 0) {
    return;
  }

  context.report({
    node: nextNode,
    messageId: "expectedBlankLine",

    fix(fixer) {
      const sourceCode = context.getSourceCode();
      let prevToken = getActualLastToken(sourceCode, prevNode);
      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
        includeComments: true,

        filter(token) {
          if (astUtils.isTokenOnSameLine(prevToken, token)) {
            prevToken = token;
            return false;
          }

          return true;
        }

      }) || nextNode;
      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";
      return fixer.insertTextAfter(prevToken, insertText);
    }

  });
}

const PaddingTypes = {
  any: {
    verify: verifyForAny
  },
  never: {
    verify: verifyForNever
  },
  always: {
    verify: verifyForAlways
  }
};
const StatementTypes = {
  "*": {
    test: () => true
  },
  "block-like": {
    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
  },
  "cjs-export": {
    test: (node, sourceCode) => node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))
  },
  "cjs-import": {
    test: (node, sourceCode) => node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
  },
  directive: {
    test: isDirectivePrologue
  },
  expression: {
    test: (node, sourceCode) => node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
  },
  iife: {
    test: isIIFEStatement
  },
  "multiline-block-like": {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)
  },
  "multiline-expression": {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
  },
  "multiline-const": newMultilineKeywordTester("const"),
  "multiline-let": newMultilineKeywordTester("let"),
  "multiline-var": newMultilineKeywordTester("var"),
  "singleline-const": newSinglelineKeywordTester("const"),
  "singleline-let": newSinglelineKeywordTester("let"),
  "singleline-var": newSinglelineKeywordTester("var"),
  block: newNodeTypeTester("BlockStatement"),
  empty: newNodeTypeTester("EmptyStatement"),
  function: newNodeTypeTester("FunctionDeclaration"),
  break: newKeywordTester("break"),
  case: newKeywordTester("case"),
  class: newKeywordTester("class"),
  const: newKeywordTester("const"),
  continue: newKeywordTester("continue"),
  debugger: newKeywordTester("debugger"),
  default: newKeywordTester("default"),
  do: newKeywordTester("do"),
  export: newKeywordTester("export"),
  for: newKeywordTester("for"),
  if: newKeywordTester("if"),
  import: newKeywordTester("import"),
  let: newKeywordTester("let"),
  return: newKeywordTester("return"),
  switch: newKeywordTester("switch"),
  throw: newKeywordTester("throw"),
  try: newKeywordTester("try"),
  var: newKeywordTester("var"),
  while: newKeywordTester("while"),
  with: newKeywordTester("with")
};
var paddingLineBetweenStatements = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding lines between statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/padding-line-between-statements"
    },
    fixable: "whitespace",
    schema: {
      definitions: {
        paddingType: {
          enum: Object.keys(PaddingTypes)
        },
        statementType: {
          anyOf: [{
            enum: Object.keys(StatementTypes)
          }, {
            type: "array",
            items: {
              enum: Object.keys(StatementTypes)
            },
            minItems: 1,
            uniqueItems: true,
            additionalItems: false
          }]
        }
      },
      type: "array",
      items: {
        type: "object",
        properties: {
          blankLine: {
            $ref: "#/definitions/paddingType"
          },
          prev: {
            $ref: "#/definitions/statementType"
          },
          next: {
            $ref: "#/definitions/statementType"
          }
        },
        additionalProperties: false,
        required: ["blankLine", "prev", "next"]
      },
      additionalItems: false
    },
    messages: {
      unexpectedBlankLine: "Unexpected blank line before this statement.",
      expectedBlankLine: "Expected blank line before this statement."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const configureList = context.options || [];
    let scopeInfo = null;

    function enterScope() {
      scopeInfo = {
        upper: scopeInfo,
        prevNode: null
      };
    }

    function exitScope() {
      scopeInfo = scopeInfo.upper;
    }

    function match(node, type) {
      let innerStatementNode = node;

      while (innerStatementNode.type === "LabeledStatement") {
        innerStatementNode = innerStatementNode.body;
      }

      if (Array.isArray(type)) {
        return type.some(match.bind(null, innerStatementNode));
      }

      return StatementTypes[type].test(innerStatementNode, sourceCode);
    }

    function getPaddingType(prevNode, nextNode) {
      for (let i = configureList.length - 1; i >= 0; --i) {
        const configure = configureList[i];
        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);

        if (matched) {
          return PaddingTypes[configure.blankLine];
        }
      }

      return PaddingTypes.any;
    }

    function getPaddingLineSequences(prevNode, nextNode) {
      const pairs = [];
      let prevToken = getActualLastToken(sourceCode, prevNode);

      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
        do {
          const token = sourceCode.getTokenAfter(prevToken, {
            includeComments: true
          });

          if (token.loc.start.line - prevToken.loc.end.line >= 2) {
            pairs.push([prevToken, token]);
          }

          prevToken = token;
        } while (prevToken.range[0] < nextNode.range[0]);
      }

      return pairs;
    }

    function verify(node) {
      const parentType = node.parent.type;
      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";

      if (!validParent) {
        return;
      }

      const prevNode = scopeInfo.prevNode;

      if (prevNode) {
        const type = getPaddingType(prevNode, node);
        const paddingLines = getPaddingLineSequences(prevNode, node);
        type.verify(context, prevNode, node, paddingLines);
      }

      scopeInfo.prevNode = node;
    }

    return {
      Program: enterScope,
      BlockStatement: enterScope,
      SwitchStatement: enterScope,
      "Program:exit": exitScope,
      "BlockStatement:exit": exitScope,
      "SwitchStatement:exit": exitScope,
      ":statement": verify,
      SwitchCase: function (node) {
        verify(node);
        enterScope();
      },
      "SwitchCase:exit": exitScope
    };
  }

};

function isFunctionName(variable) {
  return variable && variable.defs[0].type === "FunctionName";
}

function checkMetaProperty(node, metaName, propertyName) {
  return node.meta.name === metaName && node.property.name === propertyName;
}

function getVariableOfArguments$1(scope) {
  const variables = scope.variables;

  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];

    if (variable.name === "arguments") {
      return variable.identifiers.length === 0 ? variable : null;
    }
  }

  return null;
}

function getCallbackInfo(node) {
  const retv = {
    isCallback: false,
    isLexicalThis: false
  };
  let currentNode = node;
  let parent = node.parent;
  let bound = false;

  while (currentNode) {
    switch (parent.type) {
      case "LogicalExpression":
      case "ChainExpression":
      case "ConditionalExpression":
        break;

      case "MemberExpression":
        if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind") {
          const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;

          if (astUtils.isCallee(maybeCallee)) {
            if (!bound) {
              bound = true;
              retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === "ThisExpression";
            }

            parent = maybeCallee.parent;
          } else {
            return retv;
          }
        } else {
          return retv;
        }

        break;

      case "CallExpression":
      case "NewExpression":
        if (parent.callee !== currentNode) {
          retv.isCallback = true;
        }

        return retv;

      default:
        return retv;
    }

    currentNode = parent;
    parent = parent.parent;
  }

  throw new Error("unreachable");
}

function hasDuplicateParams(paramsList) {
  return paramsList.every(param => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;
}

var preferArrowCallback = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using arrow functions for callbacks",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-arrow-callback"
    },
    schema: [{
      type: "object",
      properties: {
        allowNamedFunctions: {
          type: "boolean",
          default: false
        },
        allowUnboundThis: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      preferArrowCallback: "Unexpected function expression."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const allowUnboundThis = options.allowUnboundThis !== false;
    const allowNamedFunctions = options.allowNamedFunctions;
    const sourceCode = context.getSourceCode();
    let stack = [];

    function enterScope() {
      stack.push({
        this: false,
        super: false,
        meta: false
      });
    }

    function exitScope() {
      return stack.pop();
    }

    return {
      Program() {
        stack = [];
      },

      ThisExpression() {
        const info = stack[stack.length - 1];

        if (info) {
          info.this = true;
        }
      },

      Super() {
        const info = stack[stack.length - 1];

        if (info) {
          info.super = true;
        }
      },

      MetaProperty(node) {
        const info = stack[stack.length - 1];

        if (info && checkMetaProperty(node, "new", "target")) {
          info.meta = true;
        }
      },

      FunctionDeclaration: enterScope,
      "FunctionDeclaration:exit": exitScope,
      FunctionExpression: enterScope,

      "FunctionExpression:exit"(node) {
        const scopeInfo = exitScope();

        if (allowNamedFunctions && node.id && node.id.name) {
          return;
        }

        if (node.generator) {
          return;
        }

        const nameVar = context.getDeclaredVariables(node)[0];

        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        }

        const variable = getVariableOfArguments$1(context.getScope());

        if (variable && variable.references.length > 0) {
          return;
        }

        const callbackInfo = getCallbackInfo(node);

        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
          context.report({
            node,
            messageId: "preferArrowCallback",

            *fix(fixer) {
              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
                return;
              }

              if (callbackInfo.isLexicalThis) {
                const memberNode = node.parent;

                if (memberNode.type !== "MemberExpression") {
                  return;
                }

                const callNode = memberNode.parent;
                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                const lastTokenToRemove = sourceCode.getLastToken(callNode);

                if (astUtils.isParenthesised(sourceCode, memberNode)) {
                  return;
                }

                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                  return;
                }

                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
              }

              const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
              const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);

              if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {
                yield fixer.remove(functionToken);

                if (node.id) {
                  yield fixer.remove(node.id);
                }
              } else {
                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
              }

              yield fixer.insertTextBefore(node.body, "=> ");
              let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;

              if (replacedNode.type === "ChainExpression") {
                replacedNode = replacedNode.parent;
              }

              if (replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {
                yield fixer.insertTextBefore(replacedNode, "(");
                yield fixer.insertTextAfter(replacedNode, ")");
              }
            }

          });
        }
      }

    };
  }

};
const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;
const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;

function isInitOfForStatement(node) {
  return node.parent.type === "ForStatement" && node.parent.init === node;
}

function canBecomeVariableDeclaration(identifier) {
  let node = identifier.parent;

  while (PATTERN_TYPE.test(node.type)) {
    node = node.parent;
  }

  return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
}

function isOuterVariableInDestructing(name, initScope) {
  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {
    return true;
  }

  const variable = astUtils.getVariableByName(initScope, name);

  if (variable !== null) {
    return variable.defs.some(def => def.type === "Parameter");
  }

  return false;
}

function getDestructuringHost(reference) {
  if (!reference.isWrite()) {
    return null;
  }

  let node = reference.identifier.parent;

  while (PATTERN_TYPE.test(node.type)) {
    node = node.parent;
  }

  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
    return null;
  }

  return node;
}

function hasMemberExpressionAssignment(node) {
  switch (node.type) {
    case "ObjectPattern":
      return node.properties.some(prop => {
        if (prop) {
          return hasMemberExpressionAssignment(prop.argument || prop.value);
        }

        return false;
      });

    case "ArrayPattern":
      return node.elements.some(element => {
        if (element) {
          return hasMemberExpressionAssignment(element);
        }

        return false;
      });

    case "AssignmentPattern":
      return hasMemberExpressionAssignment(node.left);

    case "MemberExpression":
      return true;
  }

  return false;
}

function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
  if (variable.eslintUsed && variable.scope.type === "global") {
    return null;
  }

  let writer = null;
  let isReadBeforeInit = false;
  const references = variable.references;

  for (let i = 0; i < references.length; ++i) {
    const reference = references[i];

    if (reference.isWrite()) {
      const isReassigned = writer !== null && writer.identifier !== reference.identifier;

      if (isReassigned) {
        return null;
      }

      const destructuringHost = getDestructuringHost(reference);

      if (destructuringHost !== null && destructuringHost.left !== void 0) {
        const leftNode = destructuringHost.left;
        let hasOuterVariables = false,
            hasNonIdentifiers = false;

        if (leftNode.type === "ObjectPattern") {
          const properties = leftNode.properties;
          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));
          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
        } else if (leftNode.type === "ArrayPattern") {
          const elements = leftNode.elements;
          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));
          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
        }

        if (hasOuterVariables || hasNonIdentifiers) {
          return null;
        }
      }

      writer = reference;
    } else if (reference.isRead() && writer === null) {
      if (ignoreReadBeforeAssign) {
        return null;
      }

      isReadBeforeInit = true;
    }
  }

  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);

  if (!shouldBeConst) {
    return null;
  }

  if (isReadBeforeInit) {
    return variable.defs[0].name;
  }

  return writer.identifier;
}

function groupByDestructuring(variables, ignoreReadBeforeAssign) {
  const identifierMap = new Map();

  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];
    const references = variable.references;
    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
    let prevId = null;

    for (let j = 0; j < references.length; ++j) {
      const reference = references[j];
      const id = reference.identifier;

      if (id === prevId) {
        continue;
      }

      prevId = id;
      const group = getDestructuringHost(reference);

      if (group) {
        if (identifierMap.has(group)) {
          identifierMap.get(group).push(identifier);
        } else {
          identifierMap.set(group, [identifier]);
        }
      }
    }
  }

  return identifierMap;
}

function findUp(node, type, shouldStop) {
  if (!node || shouldStop(node)) {
    return null;
  }

  if (node.type === type) {
    return node;
  }

  return findUp(node.parent, type, shouldStop);
}

var preferConst = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `const` declarations for variables that are never reassigned after declared",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-const"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        destructuring: {
          enum: ["any", "all"],
          default: "any"
        },
        ignoreReadBeforeAssign: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      useConst: "'{{name}}' is never reassigned. Use 'const' instead."
    }
  },

  create(context) {
    const options = context.options[0] || {};
    const sourceCode = context.getSourceCode();
    const shouldMatchAnyDestructuredVariable = options.destructuring !== "all";
    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
    const variables = [];
    let reportCount = 0;
    let checkedId = null;
    let checkedName = "";

    function checkGroup(nodes) {
      const nodesToReport = nodes.filter(Boolean);

      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {
        const varDeclParent = findUp(nodes[0], "VariableDeclaration", parentNode => parentNode.type.endsWith("Statement"));
        const isVarDecParentNull = varDeclParent === null;

        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {
          const firstDeclaration = varDeclParent.declarations[0];

          if (firstDeclaration.init) {
            const firstDecParent = firstDeclaration.init.parent;

            if (firstDecParent.type === "VariableDeclarator") {
              if (firstDecParent.id.name !== checkedName) {
                checkedName = firstDecParent.id.name;
                reportCount = 0;
              }

              if (firstDecParent.id.type === "ObjectPattern") {
                if (firstDecParent.init.name !== checkedName) {
                  checkedName = firstDecParent.init.name;
                  reportCount = 0;
                }
              }

              if (firstDecParent.id !== checkedId) {
                checkedId = firstDecParent.id;
                reportCount = 0;
              }
            }
          }
        }

        let shouldFix = varDeclParent && (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations.every(declaration => declaration.init)) && nodesToReport.length === nodes.length;

        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {
          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {
            reportCount += nodesToReport.length;
            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;
          }
        }

        nodesToReport.forEach(node => {
          context.report({
            node,
            messageId: "useConst",
            data: node,
            fix: shouldFix ? fixer => {
              const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);
              return new fixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, "const");
            } : null
          });
        });
      }
    }

    return {
      "Program:exit"() {
        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
      },

      VariableDeclaration(node) {
        if (node.kind === "let" && !isInitOfForStatement(node)) {
          variables.push(...context.getDeclaredVariables(node));
        }
      }

    };
  }

};
const PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({
  type: "AssignmentExpression"
});
var preferDestructuring = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require destructuring from arrays and/or objects",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-destructuring"
    },
    fixable: "code",
    schema: [{
      oneOf: [{
        type: "object",
        properties: {
          VariableDeclarator: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          AssignmentExpression: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          array: {
            type: "boolean"
          },
          object: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }, {
      type: "object",
      properties: {
        enforceForRenamedProperties: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      preferDestructuring: "Use {{type}} destructuring."
    }
  },

  create(context) {
    const enabledTypes = context.options[0];
    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
    let normalizedOptions = {
      VariableDeclarator: {
        array: true,
        object: true
      },
      AssignmentExpression: {
        array: true,
        object: true
      }
    };

    if (enabledTypes) {
      normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? {
        VariableDeclarator: enabledTypes,
        AssignmentExpression: enabledTypes
      } : enabledTypes;
    }

    function shouldCheck(nodeType, destructuringType) {
      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
    }

    function isArrayIndexAccess(node) {
      return Number.isInteger(node.property.value);
    }

    function report(reportNode, type, fix) {
      context.report({
        node: reportNode,
        messageId: "preferDestructuring",
        data: {
          type
        },
        fix
      });
    }

    function shouldFix(node) {
      return node.type === "VariableDeclarator" && node.id.type === "Identifier" && node.init.type === "MemberExpression" && !node.init.computed && node.init.property.type === "Identifier" && node.id.name === node.init.property.name;
    }

    function fixIntoObjectDestructuring(fixer, node) {
      const rightNode = node.init;
      const sourceCode = context.getSourceCode();

      if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {
        return null;
      }

      let objectText = sourceCode.getText(rightNode.object);

      if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {
        objectText = `(${objectText})`;
      }

      return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);
    }

    function performCheck(leftNode, rightNode, reportNode) {
      if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super") {
        return;
      }

      if (isArrayIndexAccess(rightNode)) {
        if (shouldCheck(reportNode.type, "array")) {
          report(reportNode, "array", null);
        }

        return;
      }

      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;

      if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
        report(reportNode, "object", fix);
        return;
      }

      if (shouldCheck(reportNode.type, "object")) {
        const property = rightNode.property;

        if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed) {
          report(reportNode, "object", fix);
        }
      }
    }

    return {
      VariableDeclarator: function (node) {
        if (!node.init) {
          return;
        }

        if (node.init.type !== "MemberExpression") {
          return;
        }

        performCheck(node.id, node.init, node);
      },
      AssignmentExpression: function (node) {
        if (node.operator === "=") {
          performCheck(node.left, node.right, node);
        }
      }
    };
  }

};
const {
  CALL: CALL$4,
  ReferenceTracker: ReferenceTracker$4
} = eslintUtils__default['default'];
const PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({
  type: "BinaryExpression",
  operator: "**"
});

function doesBaseNeedParens(base) {
  return astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || base.type === "AwaitExpression" || base.type === "UnaryExpression";
}

function doesExponentNeedParens(exponent) {
  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
}

function doesExponentiationExpressionNeedParens(node, sourceCode) {
  const parent = node.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
  const needsParens = parent.type === "ClassDeclaration" || parent.type.endsWith("Expression") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node) && !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node)) && !(parent.type === "MemberExpression" && parent.computed && parent.property === node) && !(parent.type === "ArrayExpression");
  return needsParens && !astUtils.isParenthesised(sourceCode, node);
}

function parenthesizeIfShould(text, shouldParenthesize) {
  return shouldParenthesize ? `(${text})` : text;
}

var preferExponentiationOperator = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `Math.pow` in favor of the `**` operator",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-exponentiation-operator"
    },
    schema: [],
    fixable: "code",
    messages: {
      useExponentiation: "Use the '**' operator instead of 'Math.pow'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    function report(node) {
      context.report({
        node,
        messageId: "useExponentiation",

        fix(fixer) {
          if (node.arguments.length !== 2 || node.arguments.some(arg => arg.type === "SpreadElement") || sourceCode.getCommentsInside(node).length > 0) {
            return null;
          }

          const base = node.arguments[0],
                exponent = node.arguments[1],
                baseText = sourceCode.getText(base),
                exponentText = sourceCode.getText(exponent),
                shouldParenthesizeBase = doesBaseNeedParens(base),
                shouldParenthesizeExponent = doesExponentNeedParens(exponent),
                shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);
          let prefix = "",
              suffix = "";

          if (!shouldParenthesizeAll) {
            if (!shouldParenthesizeBase) {
              const firstReplacementToken = sourceCode.getFirstToken(base),
                    tokenBefore = sourceCode.getTokenBefore(node);

              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                prefix = " ";
              }
            }

            if (!shouldParenthesizeExponent) {
              const lastReplacementToken = sourceCode.getLastToken(exponent),
                    tokenAfter = sourceCode.getTokenAfter(node);

              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {
                suffix = " ";
              }
            }
          }

          const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),
                exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),
                replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);
          return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
        }

      });
    }

    return {
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$4(scope);
        const trackMap = {
          Math: {
            pow: {
              [CALL$4]: true
            }
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(trackMap)) {
          report(node);
        }
      }

    };
  }

};
const {
  CALL: CALL$3,
  CONSTRUCT: CONSTRUCT$2,
  ReferenceTracker: ReferenceTracker$3,
  getStringIfConstant: getStringIfConstant$1
} = eslintUtils__default['default'];
const parser = new regexpp__default['default'].RegExpParser();
var preferNamedCaptureGroup = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce using named capture group in regular expression",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-named-capture-group"
    },
    schema: [],
    messages: {
      required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
    }
  },

  create(context) {
    function checkRegex(pattern, node, uFlag) {
      let ast;

      try {
        ast = parser.parsePattern(pattern, 0, pattern.length, uFlag);
      } catch {
        return;
      }

      regexpp__default['default'].visitRegExpAST(ast, {
        onCapturingGroupEnter(group) {
          if (!group.name) {
            context.report({
              node,
              messageId: "required",
              data: {
                group: group.raw
              }
            });
          }
        }

      });
    }

    return {
      Literal(node) {
        if (node.regex) {
          checkRegex(node.regex.pattern, node, node.regex.flags.includes("u"));
        }
      },

      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$3(scope);
        const traceMap = {
          RegExp: {
            [CALL$3]: true,
            [CONSTRUCT$2]: true
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(traceMap)) {
          const regex = getStringIfConstant$1(node.arguments[0]);
          const flags = getStringIfConstant$1(node.arguments[1]);

          if (regex) {
            checkRegex(regex, node, flags && flags.includes("u"));
          }
        }
      }

    };
  }

};
const radixMap = new Map([[2, {
  system: "binary",
  literalPrefix: "0b"
}], [8, {
  system: "octal",
  literalPrefix: "0o"
}], [16, {
  system: "hexadecimal",
  literalPrefix: "0x"
}]]);

function isParseInt(calleeNode) {
  return astUtils.isSpecificId(calleeNode, "parseInt") || astUtils.isSpecificMemberAccess(calleeNode, "Number", "parseInt");
}

var preferNumericLiterals = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-numeric-literals"
    },
    schema: [],
    messages: {
      useLiteral: "Use {{system}} literals instead of {{functionName}}()."
    },
    fixable: "code"
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      "CallExpression[arguments.length=2]"(node) {
        const [strNode, radixNode] = node.arguments,
              str = astUtils.getStaticStringValue(strNode),
              radix = radixNode.value;

        if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === "Literal" && typeof radix === "number" && radixMap.has(radix) && isParseInt(node.callee)) {
          const {
            system,
            literalPrefix
          } = radixMap.get(radix);
          context.report({
            node,
            messageId: "useLiteral",
            data: {
              system,
              functionName: sourceCode.getText(node.callee)
            },

            fix(fixer) {
              if (sourceCode.getCommentsInside(node).length) {
                return null;
              }

              const replacement = `${literalPrefix}${str}`;

              if (+replacement !== parseInt(str, radix)) {
                return null;
              }

              const tokenBefore = sourceCode.getTokenBefore(node),
                    tokenAfter = sourceCode.getTokenAfter(node);
              let prefix = "",
                  suffix = "";

              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                prefix = " ";
              }

              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {
                suffix = " ";
              }

              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
            }

          });
        }
      }

    };
  }

};
const {
  CALL: CALL$2,
  ReferenceTracker: ReferenceTracker$2
} = eslintUtils__default['default'];
const {
  isCommaToken,
  isOpeningParenToken,
  isClosingParenToken,
  isParenthesised
} = astUtils;
const ANY_SPACE = /\s/u;

function hasArraySpread(node) {
  return node.arguments.some(arg => arg.type === "SpreadElement");
}

function isAccessorProperty(node) {
  return node.type === "Property" && (node.kind === "get" || node.kind === "set");
}

function hasAccessors(node) {
  return node.properties.some(isAccessorProperty);
}

function hasArgumentsWithAccessors(node) {
  return node.arguments.filter(arg => arg.type === "ObjectExpression").some(hasAccessors);
}

function needsParens(node, sourceCode) {
  const parent = node.parent;

  switch (parent.type) {
    case "VariableDeclarator":
    case "ArrayExpression":
    case "ReturnStatement":
    case "CallExpression":
    case "Property":
      return false;

    case "AssignmentExpression":
      return parent.left === node && !isParenthesised(sourceCode, node);

    default:
      return !isParenthesised(sourceCode, node);
  }
}

function argNeedsParens(node, sourceCode) {
  switch (node.type) {
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "ConditionalExpression":
      return !isParenthesised(sourceCode, node);

    default:
      return false;
  }
}

function getParenTokens(node, leftArgumentListParen, sourceCode) {
  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
  let leftNext = sourceCode.getTokenBefore(node);
  let rightNext = sourceCode.getTokenAfter(node);

  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
    parens.push(leftNext, rightNext);
    leftNext = sourceCode.getTokenBefore(leftNext);
    rightNext = sourceCode.getTokenAfter(rightNext);
  }

  return parens.sort((a, b) => a.range[0] - b.range[0]);
}

function getStartWithSpaces(token, sourceCode) {
  const text = sourceCode.text;
  let start = token.range[0];
  {
    const prevToken = sourceCode.getTokenBefore(token, {
      includeComments: true
    });

    if (prevToken && prevToken.type === "Line") {
      return start;
    }
  }

  while (ANY_SPACE.test(text[start - 1] || "")) {
    start -= 1;
  }

  return start;
}

function getEndWithSpaces(token, sourceCode) {
  const text = sourceCode.text;
  let end = token.range[1];

  while (ANY_SPACE.test(text[end] || "")) {
    end += 1;
  }

  return end;
}

function defineFixer(node, sourceCode) {
  return function* (fixer) {
    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
    const rightParen = sourceCode.getLastToken(node);
    yield fixer.removeRange([node.range[0], leftParen.range[0]]);

    if (needsParens(node, sourceCode)) {
      yield fixer.replaceText(leftParen, "({");
      yield fixer.replaceText(rightParen, "})");
    } else {
      yield fixer.replaceText(leftParen, "{");
      yield fixer.replaceText(rightParen, "}");
    }

    for (const argNode of node.arguments) {
      const innerParens = getParenTokens(argNode, leftParen, sourceCode);
      const left = innerParens.shift();
      const right = innerParens.pop();

      if (argNode.type === "ObjectExpression") {
        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
        const maybeArgumentComma = sourceCode.getTokenAfter(right);

        for (const innerParen of innerParens) {
          yield fixer.remove(innerParen);
        }

        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), right.range[1]];
        yield fixer.removeRange(leftRange);
        yield fixer.removeRange(rightRange);

        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {
          yield fixer.remove(maybeArgumentComma);
        }
      } else {
        if (argNeedsParens(argNode, sourceCode)) {
          yield fixer.insertTextBefore(left, "...(");
          yield fixer.insertTextAfter(right, ")");
        } else {
          yield fixer.insertTextBefore(left, "...");
        }
      }
    }
  };
}

var preferObjectSpread = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-object-spread"
    },
    schema: [],
    fixable: "code",
    messages: {
      useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
      useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$2(scope);
        const trackMap = {
          Object: {
            assign: {
              [CALL$2]: true
            }
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(trackMap)) {
          if (node.arguments.length >= 1 && node.arguments[0].type === "ObjectExpression" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {
            const messageId = node.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
            const fix = defineFixer(node, sourceCode);
            context.report({
              node,
              messageId,
              fix
            });
          }
        }
      }

    };
  }

};
var preferPromiseRejectErrors = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using Error objects as Promise rejection reasons",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-promise-reject-errors"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowEmptyReject: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      rejectAnError: "Expected the Promise rejection reason to be an Error."
    }
  },

  create(context) {
    const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;

    function checkRejectCall(callExpression) {
      if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
        return;
      }

      if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
        context.report({
          node: callExpression,
          messageId: "rejectAnError"
        });
      }
    }

    function isPromiseRejectCall(node) {
      return astUtils.isSpecificMemberAccess(node.callee, "Promise", "reject");
    }

    return {
      CallExpression(node) {
        if (isPromiseRejectCall(node)) {
          checkRejectCall(node);
        }
      },

      "NewExpression:exit"(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
          context.getDeclaredVariables(node.arguments[0]).find(variable => variable.name === node.arguments[0].params[1].name).references.filter(ref => ref.isRead()).filter(ref => ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee).forEach(ref => checkRejectCall(ref.identifier.parent));
        }
      }

    };
  }

};
var preferReflect = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `Reflect` methods where applicable",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-reflect"
    },
    deprecated: true,
    replacedBy: [],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"]
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
    }
  },

  create(context) {
    const existingNames = {
      apply: "Function.prototype.apply",
      call: "Function.prototype.call",
      defineProperty: "Object.defineProperty",
      getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
      getPrototypeOf: "Object.getPrototypeOf",
      setPrototypeOf: "Object.setPrototypeOf",
      isExtensible: "Object.isExtensible",
      getOwnPropertyNames: "Object.getOwnPropertyNames",
      preventExtensions: "Object.preventExtensions"
    };
    const reflectSubstitutes = {
      apply: "Reflect.apply",
      call: "Reflect.apply",
      defineProperty: "Reflect.defineProperty",
      getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
      getPrototypeOf: "Reflect.getPrototypeOf",
      setPrototypeOf: "Reflect.setPrototypeOf",
      isExtensible: "Reflect.isExtensible",
      getOwnPropertyNames: "Reflect.getOwnPropertyNames",
      preventExtensions: "Reflect.preventExtensions"
    };
    const exceptions = (context.options[0] || {}).exceptions || [];

    function report(node, existing, substitute) {
      context.report({
        node,
        messageId: "preferReflect",
        data: {
          existing,
          substitute
        }
      });
    }

    return {
      CallExpression(node) {
        const methodName = (node.callee.property || {}).name;
        const isReflectCall = (node.callee.object || {}).name === "Reflect";
        const hasReflectSubstitute = Object.prototype.hasOwnProperty.call(reflectSubstitutes, methodName);
        const userConfiguredException = exceptions.indexOf(methodName) !== -1;

        if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {
          report(node, existingNames[methodName], reflectSubstitutes[methodName]);
        }
      },

      UnaryExpression(node) {
        const isDeleteOperator = node.operator === "delete";
        const targetsIdentifier = node.argument.type === "Identifier";
        const userConfiguredException = exceptions.indexOf("delete") !== -1;

        if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
          report(node, "the delete keyword", "Reflect.deleteProperty");
        }
      }

    };
  }

};
const {
  CALL: CALL$1,
  CONSTRUCT: CONSTRUCT$1,
  ReferenceTracker: ReferenceTracker$1,
  findVariable
} = eslintUtils__default['default'];

function isStringLiteral(node) {
  return node.type === "Literal" && typeof node.value === "string";
}

function isRegexLiteral(node) {
  return node.type === "Literal" && Object.prototype.hasOwnProperty.call(node, "regex");
}

function isStaticTemplateLiteral$1(node) {
  return node.type === "TemplateLiteral" && node.expressions.length === 0;
}

var preferRegexLiterals = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow use of the `RegExp` constructor in favor of regular expression literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-regex-literals"
    },
    schema: [{
      type: "object",
      properties: {
        disallowRedundantWrapping: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
      unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
      unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
    }
  },

  create(context) {
    const [{
      disallowRedundantWrapping = false
    } = {}] = context.options;

    function isGlobalReference(node) {
      const scope = context.getScope();
      const variable = findVariable(scope, node);
      return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
    }

    function isStringRawTaggedStaticTemplateLiteral(node) {
      return node.type === "TaggedTemplateExpression" && astUtils.isSpecificMemberAccess(node.tag, "String", "raw") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral$1(node.quasi);
    }

    function isStaticString(node) {
      return isStringLiteral(node) || isStaticTemplateLiteral$1(node) || isStringRawTaggedStaticTemplateLiteral(node);
    }

    function hasOnlyStaticStringArguments(node) {
      const args = node.arguments;

      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {
        return true;
      }

      return false;
    }

    function isUnnecessarilyWrappedRegexLiteral(node) {
      const args = node.arguments;

      if (args.length === 1 && isRegexLiteral(args[0])) {
        return true;
      }

      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {
        return true;
      }

      return false;
    }

    return {
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker$1(scope);
        const traceMap = {
          RegExp: {
            [CALL$1]: true,
            [CONSTRUCT$1]: true
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(traceMap)) {
          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {
            if (node.arguments.length === 2) {
              context.report({
                node,
                messageId: "unexpectedRedundantRegExpWithFlags"
              });
            } else {
              context.report({
                node,
                messageId: "unexpectedRedundantRegExp"
              });
            }
          } else if (hasOnlyStaticStringArguments(node)) {
            context.report({
              node,
              messageId: "unexpectedRegExp"
            });
          }
        }
      }

    };
  }

};

function getVariableOfArguments(scope) {
  const variables = scope.variables;

  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];

    if (variable.name === "arguments") {
      return variable.identifiers.length === 0 ? variable : null;
    }
  }

  return null;
}

function isNotNormalMemberAccess(reference) {
  const id = reference.identifier;
  const parent = id.parent;
  return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
}

var preferRestParams = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require rest parameters instead of `arguments`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-rest-params"
    },
    schema: [],
    messages: {
      preferRestParams: "Use the rest parameters instead of 'arguments'."
    }
  },

  create(context) {
    function report(reference) {
      context.report({
        node: reference.identifier,
        loc: reference.identifier.loc,
        messageId: "preferRestParams"
      });
    }

    function checkForArguments() {
      const argumentsVar = getVariableOfArguments(context.getScope());

      if (argumentsVar) {
        argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
      }
    }

    return {
      "FunctionDeclaration:exit": checkForArguments,
      "FunctionExpression:exit": checkForArguments
    };
  }

};

function isVariadicApplyCalling(node) {
  return astUtils.isSpecificMemberAccess(node.callee, null, "apply") && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
}

function isValidThisArg(expectedThis, thisArg, context) {
  if (!expectedThis) {
    return astUtils.isNullOrUndefined(thisArg);
  }

  return astUtils.equalTokens(expectedThis, thisArg, context);
}

var preferSpread = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require spread operators instead of `.apply()`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-spread"
    },
    schema: [],
    fixable: null,
    messages: {
      preferSpread: "Use the spread operator instead of '.apply()'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      CallExpression(node) {
        if (!isVariadicApplyCalling(node)) {
          return;
        }

        const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);
        const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
        const thisArg = node.arguments[0];

        if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
          context.report({
            node,
            messageId: "preferSpread"
          });
        }
      }

    };
  }

};

function isConcatenation(node) {
  return node.type === "BinaryExpression" && node.operator === "+";
}

function getTopConcatBinaryExpression(node) {
  let currentNode = node;

  while (isConcatenation(currentNode.parent)) {
    currentNode = currentNode.parent;
  }

  return currentNode;
}

function hasOctalOrNonOctalDecimalEscapeSequence(node) {
  if (isConcatenation(node)) {
    return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);
  }

  if (node.type === "Literal" && typeof node.value === "string") {
    return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);
  }

  return false;
}

function hasStringLiteral(node) {
  if (isConcatenation(node)) {
    return hasStringLiteral(node.right) || hasStringLiteral(node.left);
  }

  return astUtils.isStringLiteral(node);
}

function hasNonStringLiteral(node) {
  if (isConcatenation(node)) {
    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
  }

  return !astUtils.isStringLiteral(node);
}

function startsWithTemplateCurly(node) {
  if (node.type === "BinaryExpression") {
    return startsWithTemplateCurly(node.left);
  }

  if (node.type === "TemplateLiteral") {
    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
  }

  return node.type !== "Literal" || typeof node.value !== "string";
}

function endsWithTemplateCurly(node) {
  if (node.type === "BinaryExpression") {
    return startsWithTemplateCurly(node.right);
  }

  if (node.type === "TemplateLiteral") {
    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
  }

  return node.type !== "Literal" || typeof node.value !== "string";
}

var preferTemplate = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require template literals instead of string concatenation",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-template"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedStringConcatenation: "Unexpected string concatenation."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let done = Object.create(null);

    function getTextBetween(node1, node2) {
      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
      const sourceText = sourceCode.getText();
      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
    }

    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
      if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
        return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, matched => {
          if (matched.lastIndexOf("\\") % 2) {
            return `\\${matched}`;
          }

          return matched;
        }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "gu"), currentNode.raw[0])}\``;
      }

      if (currentNode.type === "TemplateLiteral") {
        return sourceCode.getText(currentNode);
      }

      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === "+");
        const textBeforePlus = getTextBetween(currentNode.left, plusSign);
        const textAfterPlus = getTextBetween(plusSign, currentNode.right);
        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);

        if (leftEndsWithCurly) {
          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
        }

        if (rightStartsWithCurly) {
          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
        }

        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
      }

      return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
    }

    function fixNonStringBinaryExpression(fixer, node) {
      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);

      if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {
        return null;
      }

      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
    }

    function checkForStringConcat(node) {
      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
        return;
      }

      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);

      if (done[topBinaryExpr.range[0]]) {
        return;
      }

      done[topBinaryExpr.range[0]] = true;

      if (hasNonStringLiteral(topBinaryExpr)) {
        context.report({
          node: topBinaryExpr,
          messageId: "unexpectedStringConcatenation",
          fix: fixer => fixNonStringBinaryExpression(fixer, node)
        });
      }
    }

    return {
      Program() {
        done = Object.create(null);
      },

      Literal: checkForStringConcat,
      TemplateLiteral: checkForStringConcat
    };
  }

};
var quoteProps = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require quotes around object literal property names",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/quote-props"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }, {
          type: "object",
          properties: {
            keywords: {
              type: "boolean"
            },
            unnecessary: {
              type: "boolean"
            },
            numbers: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
      inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
      unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
      unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
      unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
      unquotedPropertyFound: "Unquoted property '{{property}}' found.",
      redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
    }
  },

  create(context) {
    const MODE = context.options[0],
          KEYWORDS = context.options[1] && context.options[1].keywords,
          CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
          NUMBERS = context.options[1] && context.options[1].numbers,
          sourceCode = context.getSourceCode();

    function isKeyword(tokenStr) {
      return keywords.indexOf(tokenStr) >= 0;
    }

    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
    }

    function getUnquotedKey(key) {
      return key.type === "Identifier" ? key.name : key.value;
    }

    function getQuotedKey(key) {
      if (key.type === "Literal" && typeof key.value === "string") {
        return sourceCode.getText(key);
      }

      return `"${key.type === "Identifier" ? key.name : key.value}"`;
    }

    function checkUnnecessaryQuotes(node) {
      const key = node.key;

      if (node.method || node.computed || node.shorthand) {
        return;
      }

      if (key.type === "Literal" && typeof key.value === "string") {
        let tokens;

        try {
          tokens = espree__default['default'].tokenize(key.value);
        } catch {
          return;
        }

        if (tokens.length !== 1) {
          return;
        }

        const isKeywordToken = isKeyword(tokens[0].value);

        if (isKeywordToken && KEYWORDS) {
          return;
        }

        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
          context.report({
            node,
            messageId: "unnecessarilyQuotedProperty",
            data: {
              property: key.value
            },
            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))
          });
        }
      } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
        context.report({
          node,
          messageId: "unquotedReservedProperty",
          data: {
            property: key.name
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      } else if (NUMBERS && key.type === "Literal" && astUtils.isNumericLiteral(key)) {
        context.report({
          node,
          messageId: "unquotedNumericProperty",
          data: {
            property: key.value
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      }
    }

    function checkOmittedQuotes(node) {
      const key = node.key;

      if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
        context.report({
          node,
          messageId: "unquotedPropertyFound",
          data: {
            property: key.name || key.value
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      }
    }

    function checkConsistency(node, checkQuotesRedundancy) {
      const quotedProps = [],
            unquotedProps = [];
      let keywordKeyName = null,
          necessaryQuotes = false;
      node.properties.forEach(property => {
        const key = property.key;

        if (!key || property.method || property.computed || property.shorthand) {
          return;
        }

        if (key.type === "Literal" && typeof key.value === "string") {
          quotedProps.push(property);

          if (checkQuotesRedundancy) {
            let tokens;

            try {
              tokens = espree__default['default'].tokenize(key.value);
            } catch {
              necessaryQuotes = true;
              return;
            }

            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
          }
        } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
          unquotedProps.push(property);
          necessaryQuotes = true;
          keywordKeyName = key.name;
        } else {
          unquotedProps.push(property);
        }
      });

      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
        quotedProps.forEach(property => {
          context.report({
            node: property,
            messageId: "redundantQuoting",
            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))
          });
        });
      } else if (unquotedProps.length && keywordKeyName) {
        unquotedProps.forEach(property => {
          context.report({
            node: property,
            messageId: "requireQuotesDueToReservedWord",
            data: {
              property: keywordKeyName
            },
            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
          });
        });
      } else if (quotedProps.length && unquotedProps.length) {
        unquotedProps.forEach(property => {
          context.report({
            node: property,
            messageId: "inconsistentlyQuotedProperty",
            data: {
              key: property.key.name || property.key.value
            },
            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
          });
        });
      }
    }

    return {
      Property(node) {
        if (MODE === "always" || !MODE) {
          checkOmittedQuotes(node);
        }

        if (MODE === "as-needed") {
          checkUnnecessaryQuotes(node);
        }
      },

      ObjectExpression(node) {
        if (MODE === "consistent") {
          checkConsistency(node, false);
        }

        if (MODE === "consistent-as-needed") {
          checkConsistency(node, true);
        }
      }

    };
  }

};
const QUOTE_SETTINGS = {
  double: {
    quote: "\"",
    alternateQuote: "'",
    description: "doublequote"
  },
  single: {
    quote: "'",
    alternateQuote: "\"",
    description: "singlequote"
  },
  backtick: {
    quote: "`",
    alternateQuote: "\"",
    description: "backtick"
  }
};
const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`, "u");

QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {
  const newQuote = this.quote;
  const oldQuote = str[0];

  if (newQuote === oldQuote) {
    return str;
  }

  return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
    if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
      return escaped;
    }

    if (match === newQuote || newQuote === "`" && match === "${") {
      return `\\${match}`;
    }

    if (newline && oldQuote === "`") {
      return "\\n";
    }

    return match;
  }) + newQuote;
};

const AVOID_ESCAPE = "avoid-escape";
var quotes = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either backticks, double, or single quotes",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/quotes"
    },
    fixable: "code",
    schema: [{
      enum: ["single", "double", "backtick"]
    }, {
      anyOf: [{
        enum: ["avoid-escape"]
      }, {
        type: "object",
        properties: {
          avoidEscape: {
            type: "boolean"
          },
          allowTemplateLiterals: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      wrongQuotes: "Strings must use {{description}}."
    }
  },

  create(context) {
    const quoteOption = context.options[0],
          settings = QUOTE_SETTINGS[quoteOption || "double"],
          options = context.options[1],
          allowTemplateLiterals = options && options.allowTemplateLiterals === true,
          sourceCode = context.getSourceCode();
    let avoidEscape = options && options.avoidEscape === true;

    if (options === AVOID_ESCAPE) {
      avoidEscape = true;
    }

    function isJSXLiteral(node) {
      return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
    }

    function isDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function isPartOfDirectivePrologue(node) {
      const block = node.parent.parent;

      if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
        return false;
      }

      for (let i = 0; i < block.body.length; ++i) {
        const statement = block.body[i];

        if (statement === node.parent) {
          return true;
        }

        if (!isDirective(statement)) {
          break;
        }
      }

      return false;
    }

    function isAllowedAsNonBacktick(node) {
      const parent = node.parent;

      switch (parent.type) {
        case "ExpressionStatement":
          return isPartOfDirectivePrologue(node);

        case "Property":
        case "MethodDefinition":
          return parent.key === node && !parent.computed;

        case "ImportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return parent.source === node;

        default:
          return false;
      }
    }

    function isUsingFeatureOfTemplateLiteral(node) {
      const hasTag = node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi;

      if (hasTag) {
        return true;
      }

      const hasStringInterpolation = node.expressions.length > 0;

      if (hasStringInterpolation) {
        return true;
      }

      const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);

      if (isMultilineString) {
        return true;
      }

      return false;
    }

    return {
      Literal(node) {
        const val = node.value,
              rawVal = node.raw;

        if (settings && typeof val === "string") {
          let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);

          if (!isValid && avoidEscape) {
            isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
          }

          if (!isValid) {
            context.report({
              node,
              messageId: "wrongQuotes",
              data: {
                description: settings.description
              },

              fix(fixer) {
                if (quoteOption === "backtick" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {
                  return null;
                }

                return fixer.replaceText(node, settings.convert(node.raw));
              }

            });
          }
        }
      },

      TemplateLiteral(node) {
        if (allowTemplateLiterals || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node)) {
          return;
        }

        context.report({
          node,
          messageId: "wrongQuotes",
          data: {
            description: settings.description
          },

          fix(fixer) {
            if (isPartOfDirectivePrologue(node)) {
              return null;
            }

            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
          }

        });
      }

    };
  }

};
const MODE_ALWAYS = "always",
      MODE_AS_NEEDED = "as-needed";
const validRadixValues = new Set(Array.from({
  length: 35
}, (_, index) => index + 2));

function isShadowed(variable) {
  return variable.defs.length >= 1;
}

function isParseIntMethod(node) {
  return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
}

function isValidRadix(radix) {
  return !(radix.type === "Literal" && !validRadixValues.has(radix.value) || radix.type === "Identifier" && radix.name === "undefined");
}

function isDefaultRadix(radix) {
  return radix.type === "Literal" && radix.value === 10;
}

var radix = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of the radix argument when using `parseInt()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/radix"
    },
    schema: [{
      enum: ["always", "as-needed"]
    }],
    messages: {
      missingParameters: "Missing parameters.",
      redundantRadix: "Redundant radix parameter.",
      missingRadix: "Missing radix parameter.",
      invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36."
    }
  },

  create(context) {
    const mode = context.options[0] || MODE_ALWAYS;

    function checkArguments(node) {
      const args = node.arguments;

      switch (args.length) {
        case 0:
          context.report({
            node,
            messageId: "missingParameters"
          });
          break;

        case 1:
          if (mode === MODE_ALWAYS) {
            context.report({
              node,
              messageId: "missingRadix"
            });
          }

          break;

        default:
          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
            context.report({
              node,
              messageId: "redundantRadix"
            });
          } else if (!isValidRadix(args[1])) {
            context.report({
              node,
              messageId: "invalidRadix"
            });
          }

          break;
      }
    }

    return {
      "Program:exit"() {
        const scope = context.getScope();
        let variable = astUtils.getVariableByName(scope, "parseInt");

        if (variable && !isShadowed(variable)) {
          variable.references.forEach(reference => {
            const node = reference.identifier;

            if (astUtils.isCallee(node)) {
              checkArguments(node.parent);
            }
          });
        }

        variable = astUtils.getVariableByName(scope, "Number");

        if (variable && !isShadowed(variable)) {
          variable.references.forEach(reference => {
            const node = reference.identifier.parent;
            const maybeCallee = node.parent.type === "ChainExpression" ? node.parent : node;

            if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {
              checkArguments(maybeCallee.parent);
            }
          });
        }
      }

    };
  }

};

function createReferenceMap(scope, outReferenceMap = new Map()) {
  for (const reference of scope.references) {
    outReferenceMap.set(reference.identifier, reference);
  }

  for (const childScope of scope.childScopes) {
    if (childScope.type !== "function") {
      createReferenceMap(childScope, outReferenceMap);
    }
  }

  return outReferenceMap;
}

function getWriteExpr(reference) {
  if (reference.writeExpr) {
    return reference.writeExpr;
  }

  let node = reference.identifier;

  while (node) {
    const t = node.parent.type;

    if (t === "AssignmentExpression" && node.parent.left === node) {
      return node.parent.right;
    }

    if (t === "MemberExpression" && node.parent.object === node) {
      node = node.parent;
      continue;
    }

    break;
  }

  return null;
}

function isLocalVariableWithoutEscape(variable, isMemberAccess) {
  if (!variable) {
    return false;
  }

  if (isMemberAccess && variable.defs.some(d => d.type === "Parameter")) {
    return false;
  }

  const functionScope = variable.scope.variableScope;
  return variable.references.every(reference => reference.from.variableScope === functionScope);
}

class SegmentInfo {
  constructor() {
    this.info = new WeakMap();
  }

  initialize(segment) {
    const outdatedReadVariableNames = new Set();
    const freshReadVariableNames = new Set();

    for (const prevSegment of segment.prevSegments) {
      const info = this.info.get(prevSegment);

      if (info) {
        info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);
        info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);
      }
    }

    this.info.set(segment, {
      outdatedReadVariableNames,
      freshReadVariableNames
    });
  }

  markAsRead(segments, variableName) {
    for (const segment of segments) {
      const info = this.info.get(segment);

      if (info) {
        info.freshReadVariableNames.add(variableName);
        info.outdatedReadVariableNames.delete(variableName);
      }
    }
  }

  makeOutdated(segments) {
    for (const segment of segments) {
      const info = this.info.get(segment);

      if (info) {
        info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);
        info.freshReadVariableNames.clear();
      }
    }
  }

  isOutdated(segments, variableName) {
    for (const segment of segments) {
      const info = this.info.get(segment);

      if (info && info.outdatedReadVariableNames.has(variableName)) {
        return true;
      }
    }

    return false;
  }

}

var requireAtomicUpdates = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-atomic-updates"
    },
    fixable: null,
    schema: [],
    messages: {
      nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const assignmentReferences = new Map();
    const segmentInfo = new SegmentInfo();
    let stack = null;
    return {
      onCodePathStart(codePath) {
        const scope = context.getScope();
        const shouldVerify = scope.type === "function" && (scope.block.async || scope.block.generator);
        stack = {
          upper: stack,
          codePath,
          referenceMap: shouldVerify ? createReferenceMap(scope) : null
        };
      },

      onCodePathEnd() {
        stack = stack.upper;
      },

      onCodePathSegmentStart(segment) {
        segmentInfo.initialize(segment);
      },

      Identifier(node) {
        const {
          codePath,
          referenceMap
        } = stack;
        const reference = referenceMap && referenceMap.get(node);

        if (!reference) {
          return;
        }

        const name = reference.identifier.name;
        const variable = reference.resolved;
        const writeExpr = getWriteExpr(reference);
        const isMemberAccess = reference.identifier.parent.type === "MemberExpression";

        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
          segmentInfo.markAsRead(codePath.currentSegments, name);
        }

        if (writeExpr && writeExpr.parent.right === writeExpr && !isLocalVariableWithoutEscape(variable, isMemberAccess)) {
          let refs = assignmentReferences.get(writeExpr);

          if (!refs) {
            refs = [];
            assignmentReferences.set(writeExpr, refs);
          }

          refs.push(reference);
        }
      },

      ":expression:exit"(node) {
        const {
          codePath,
          referenceMap
        } = stack;

        if (!referenceMap) {
          return;
        }

        if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
          segmentInfo.makeOutdated(codePath.currentSegments);
        }

        const references = assignmentReferences.get(node);

        if (references) {
          assignmentReferences.delete(node);

          for (const reference of references) {
            const name = reference.identifier.name;

            if (segmentInfo.isOutdated(codePath.currentSegments, name)) {
              context.report({
                node: node.parent,
                messageId: "nonAtomicUpdate",
                data: {
                  value: sourceCode.getText(node.parent.left)
                }
              });
            }
          }
        }
      }

    };
  }

};

function capitalizeFirstLetter(text) {
  return text[0].toUpperCase() + text.slice(1);
}

var requireAwait = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow async functions which have no `await` expression",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-await"
    },
    schema: [],
    messages: {
      missingAwait: "{{name}} has no 'await' expression."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    function enterFunction() {
      scopeInfo = {
        upper: scopeInfo,
        hasAwait: false
      };
    }

    function exitFunction(node) {
      if (!node.generator && node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
        context.report({
          node,
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          messageId: "missingAwait",
          data: {
            name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))
          }
        });
      }

      scopeInfo = scopeInfo.upper;
    }

    return {
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      ArrowFunctionExpression: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      "FunctionExpression:exit": exitFunction,
      "ArrowFunctionExpression:exit": exitFunction,

      AwaitExpression() {
        if (!scopeInfo) {
          return;
        }

        scopeInfo.hasAwait = true;
      },

      ForOfStatement(node) {
        if (!scopeInfo) {
          return;
        }

        if (node.await) {
          scopeInfo.hasAwait = true;
        }
      }

    };
  }

};
var requireJsdoc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require JSDoc comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        require: {
          type: "object",
          properties: {
            ClassDeclaration: {
              type: "boolean",
              default: false
            },
            MethodDefinition: {
              type: "boolean",
              default: false
            },
            FunctionDeclaration: {
              type: "boolean",
              default: true
            },
            ArrowFunctionExpression: {
              type: "boolean",
              default: false
            },
            FunctionExpression: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false,
          default: {}
        }
      },
      additionalProperties: false
    }],
    deprecated: true,
    replacedBy: [],
    messages: {
      missingJSDocComment: "Missing JSDoc comment."
    }
  },

  create(context) {
    const source = context.getSourceCode();
    const options = Object.assign({
      FunctionDeclaration: true,
      MethodDefinition: false,
      ClassDeclaration: false,
      ArrowFunctionExpression: false,
      FunctionExpression: false
    }, context.options[0] && context.options[0].require);

    function report(node) {
      context.report({
        node,
        messageId: "missingJSDocComment"
      });
    }

    function checkJsDoc(node) {
      const jsdocComment = source.getJSDocComment(node);

      if (!jsdocComment) {
        report(node);
      }
    }

    return {
      FunctionDeclaration(node) {
        if (options.FunctionDeclaration) {
          checkJsDoc(node);
        }
      },

      FunctionExpression(node) {
        if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
          checkJsDoc(node);
        }
      },

      ClassDeclaration(node) {
        if (options.ClassDeclaration) {
          checkJsDoc(node);
        }
      },

      ArrowFunctionExpression(node) {
        if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
          checkJsDoc(node);
        }
      }

    };
  }

};
const {
  CALL,
  CONSTRUCT,
  ReferenceTracker,
  getStringIfConstant
} = eslintUtils__default['default'];
var requireUnicodeRegexp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of `u` flag on RegExp",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-unicode-regexp"
    },
    messages: {
      requireUFlag: "Use the 'u' flag."
    },
    schema: []
  },

  create(context) {
    return {
      "Literal[regex]"(node) {
        const flags = node.regex.flags || "";

        if (!flags.includes("u")) {
          context.report({
            node,
            messageId: "requireUFlag"
          });
        }
      },

      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker(scope);
        const trackMap = {
          RegExp: {
            [CALL]: true,
            [CONSTRUCT]: true
          }
        };

        for (const {
          node
        } of tracker.iterateGlobalReferences(trackMap)) {
          const flagsNode = node.arguments[1];
          const flags = getStringIfConstant(flagsNode, scope);

          if (!flagsNode || typeof flags === "string" && !flags.includes("u")) {
            context.report({
              node,
              messageId: "requireUFlag"
            });
          }
        }
      }

    };
  }

};
var requireYield = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require generator functions to contain `yield`",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/require-yield"
    },
    schema: [],
    messages: {
      missingYield: "This generator function does not have 'yield'."
    }
  },

  create(context) {
    const stack = [];

    function beginChecking(node) {
      if (node.generator) {
        stack.push(0);
      }
    }

    function endChecking(node) {
      if (!node.generator) {
        return;
      }

      const countYield = stack.pop();

      if (countYield === 0 && node.body.body.length > 0) {
        context.report({
          node,
          messageId: "missingYield"
        });
      }
    }

    return {
      FunctionDeclaration: beginChecking,
      "FunctionDeclaration:exit": endChecking,
      FunctionExpression: beginChecking,
      "FunctionExpression:exit": endChecking,

      YieldExpression() {
        if (stack.length > 0) {
          stack[stack.length - 1] += 1;
        }
      }

    };
  }

};
var restSpreadSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing between rest and spread operators and their expressions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/rest-spread-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
      expectedWhitespace: "Expected whitespace after {{type}} operator."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode(),
          alwaysSpace = context.options[0] === "always";

    function checkWhiteSpace(node) {
      const operator = sourceCode.getFirstToken(node),
            nextToken = sourceCode.getTokenAfter(operator),
            hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
      let type;

      switch (node.type) {
        case "SpreadElement":
          type = "spread";

          if (node.parent.type === "ObjectExpression") {
            type += " property";
          }

          break;

        case "RestElement":
          type = "rest";

          if (node.parent.type === "ObjectPattern") {
            type += " property";
          }

          break;

        case "ExperimentalSpreadProperty":
          type = "spread property";
          break;

        case "ExperimentalRestProperty":
          type = "rest property";
          break;

        default:
          return;
      }

      if (alwaysSpace && !hasWhitespace) {
        context.report({
          node,
          loc: operator.loc,
          messageId: "expectedWhitespace",
          data: {
            type
          },

          fix(fixer) {
            return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
          }

        });
      } else if (!alwaysSpace && hasWhitespace) {
        context.report({
          node,
          loc: {
            start: operator.loc.end,
            end: nextToken.loc.start
          },
          messageId: "unexpectedWhitespace",
          data: {
            type
          },

          fix(fixer) {
            return fixer.removeRange([operator.range[1], nextToken.range[0]]);
          }

        });
      }
    }

    return {
      SpreadElement: checkWhiteSpace,
      RestElement: checkWhiteSpace,
      ExperimentalSpreadProperty: checkWhiteSpace,
      ExperimentalRestProperty: checkWhiteSpace
    };
  }

};
var semiSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after semicolons",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
      unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
      missingWhitespaceBefore: "Missing whitespace before semicolon.",
      missingWhitespaceAfter: "Missing whitespace after semicolon."
    }
  },

  create(context) {
    const config = context.options[0],
          sourceCode = context.getSourceCode();
    let requireSpaceBefore = false,
        requireSpaceAfter = true;

    if (typeof config === "object") {
      requireSpaceBefore = config.before;
      requireSpaceAfter = config.after;
    }

    function hasLeadingSpace(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
    }

    function hasTrailingSpace(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
    }

    function isLastTokenInCurrentLine(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
    }

    function isFirstTokenInCurrentLine(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
    }

    function isBeforeClosingParen(token) {
      const nextToken = sourceCode.getTokenAfter(token);
      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
    }

    function checkSemicolonSpacing(token, node) {
      if (astUtils.isSemicolonToken(token)) {
        if (hasLeadingSpace(token)) {
          if (!requireSpaceBefore) {
            const tokenBefore = sourceCode.getTokenBefore(token);
            const loc = {
              start: tokenBefore.loc.end,
              end: token.loc.start
            };
            context.report({
              node,
              loc,
              messageId: "unexpectedWhitespaceBefore",

              fix(fixer) {
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
              }

            });
          }
        } else {
          if (requireSpaceBefore) {
            const loc = token.loc;
            context.report({
              node,
              loc,
              messageId: "missingWhitespaceBefore",

              fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }

            });
          }
        }

        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
          if (hasTrailingSpace(token)) {
            if (!requireSpaceAfter) {
              const tokenAfter = sourceCode.getTokenAfter(token);
              const loc = {
                start: token.loc.end,
                end: tokenAfter.loc.start
              };
              context.report({
                node,
                loc,
                messageId: "unexpectedWhitespaceAfter",

                fix(fixer) {
                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                }

              });
            }
          } else {
            if (requireSpaceAfter) {
              const loc = token.loc;
              context.report({
                node,
                loc,
                messageId: "missingWhitespaceAfter",

                fix(fixer) {
                  return fixer.insertTextAfter(token, " ");
                }

              });
            }
          }
        }
      }
    }

    function checkNode(node) {
      const token = sourceCode.getLastToken(node);
      checkSemicolonSpacing(token, node);
    }

    return {
      VariableDeclaration: checkNode,
      ExpressionStatement: checkNode,
      BreakStatement: checkNode,
      ContinueStatement: checkNode,
      DebuggerStatement: checkNode,
      DoWhileStatement: checkNode,
      ReturnStatement: checkNode,
      ThrowStatement: checkNode,
      ImportDeclaration: checkNode,
      ExportNamedDeclaration: checkNode,
      ExportAllDeclaration: checkNode,
      ExportDefaultDeclaration: checkNode,

      ForStatement(node) {
        if (node.init) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
        }

        if (node.test) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
        }
      }

    };
  }

};
const SELECTOR = `:matches(${"BreakStatement,ContinueStatement,DebuggerStatement,DoWhileStatement,ExportAllDeclaration,ExportDefaultDeclaration,ExportNamedDeclaration,ExpressionStatement,ImportDeclaration,ReturnStatement,ThrowStatement,VariableDeclaration"})`;

function getChildren(node) {
  const t = node.type;

  if (t === "BlockStatement" || t === "Program") {
    return node.body;
  }

  if (t === "SwitchCase") {
    return node.consequent;
  }

  return null;
}

function isLastChild(node) {
  const t = node.parent.type;

  if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
    return true;
  }

  if (t === "DoWhileStatement") {
    return true;
  }

  const nodeList = getChildren(node.parent);
  return nodeList !== null && nodeList[nodeList.length - 1] === node;
}

var semiStyle = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce location of semicolons",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi-style"
    },
    schema: [{
      enum: ["last", "first"]
    }],
    fixable: "whitespace",
    messages: {
      expectedSemiColon: "Expected this semicolon to be at {{pos}}."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "last";

    function check(semiToken, expected) {
      const prevToken = sourceCode.getTokenBefore(semiToken);
      const nextToken = sourceCode.getTokenAfter(semiToken);
      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);

      if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
        context.report({
          loc: semiToken.loc,
          messageId: "expectedSemiColon",
          data: {
            pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
          },

          fix(fixer) {
            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
              return null;
            }

            const start = prevToken ? prevToken.range[1] : semiToken.range[0];
            const end = nextToken ? nextToken.range[0] : semiToken.range[1];
            const text = expected === "last" ? ";\n" : "\n;";
            return fixer.replaceTextRange([start, end], text);
          }

        });
      }
    }

    return {
      [SELECTOR](node) {
        if (option === "first" && isLastChild(node)) {
          return;
        }

        const lastToken = sourceCode.getLastToken(node);

        if (astUtils.isSemicolonToken(lastToken)) {
          check(lastToken, option);
        }
      },

      ForStatement(node) {
        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);

        if (firstSemi) {
          check(firstSemi, "last");
        }

        if (secondSemi) {
          check(secondSemi, "last");
        }
      }

    };
  }

};
var semi = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow semicolons instead of ASI",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            beforeStatementContinuationChars: {
              enum: ["always", "any", "never"]
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            omitLastInOneLineBlock: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      missingSemi: "Missing semicolon.",
      extraSemi: "Extra semicolon."
    }
  },

  create(context) {
    const options = context.options[1];
    const never = context.options[0] === "never";
    const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
    const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
    const sourceCode = context.getSourceCode();

    function report(node, missing) {
      const lastToken = sourceCode.getLastToken(node);
      let messageId, fix, loc;

      if (!missing) {
        messageId = "missingSemi";
        loc = {
          start: lastToken.loc.end,
          end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)
        };

        fix = function (fixer) {
          return fixer.insertTextAfter(lastToken, ";");
        };
      } else {
        messageId = "extraSemi";
        loc = lastToken.loc;

        fix = function (fixer) {
          return new fixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
        };
      }

      context.report({
        node,
        loc,
        messageId,
        fix
      });
    }

    function isRedundantSemi(semiToken) {
      const nextToken = sourceCode.getTokenAfter(semiToken);
      return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
    }

    function isEndOfArrowBlock(lastToken) {
      if (!astUtils.isClosingBraceToken(lastToken)) {
        return false;
      }

      const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);
      return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
    }

    function isOnSameLineWithNextToken(node) {
      const prevToken = sourceCode.getLastToken(node, 1);
      const nextToken = sourceCode.getTokenAfter(node);
      return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
    }

    function maybeAsiHazardAfter(node) {
      const t = node.type;

      if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
        return false;
      }

      if (t === "ReturnStatement") {
        return Boolean(node.argument);
      }

      if (t === "ExportNamedDeclaration") {
        return Boolean(node.declaration);
      }

      if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
        return false;
      }

      return true;
    }

    function maybeAsiHazardBefore(token) {
      return Boolean(token) && /^[-[(/+`]/u.test(token.value) && token.value !== "++" && token.value !== "--";
    }

    function canRemoveSemicolon(node) {
      if (isRedundantSemi(sourceCode.getLastToken(node))) {
        return true;
      }

      if (isOnSameLineWithNextToken(node)) {
        return false;
      }

      if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
        return true;
      }

      if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
        return true;
      }

      return false;
    }

    function isOneLinerBlock(node) {
      const parent = node.parent;
      const nextToken = sourceCode.getTokenAfter(node);

      if (!nextToken || nextToken.value !== "}") {
        return false;
      }

      return !!parent && parent.type === "BlockStatement" && parent.loc.start.line === parent.loc.end.line;
    }

    function checkForSemicolon(node) {
      const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));

      if (never) {
        if (isSemi && canRemoveSemicolon(node)) {
          report(node, true);
        } else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
          report(node);
        }
      } else {
        const oneLinerBlock = exceptOneLine && isOneLinerBlock(node);

        if (isSemi && oneLinerBlock) {
          report(node, true);
        } else if (!isSemi && !oneLinerBlock) {
          report(node);
        }
      }
    }

    return {
      VariableDeclaration: function (node) {
        const parent = node.parent;

        if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {
          checkForSemicolon(node);
        }
      },
      ExpressionStatement: checkForSemicolon,
      ReturnStatement: checkForSemicolon,
      ThrowStatement: checkForSemicolon,
      DoWhileStatement: checkForSemicolon,
      DebuggerStatement: checkForSemicolon,
      BreakStatement: checkForSemicolon,
      ContinueStatement: checkForSemicolon,
      ImportDeclaration: checkForSemicolon,
      ExportAllDeclaration: checkForSemicolon,

      ExportNamedDeclaration(node) {
        if (!node.declaration) {
          checkForSemicolon(node);
        }
      },

      ExportDefaultDeclaration(node) {
        if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {
          checkForSemicolon(node);
        }
      }

    };
  }

};
var sortImports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted import declarations within modules",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-imports"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: false
        },
        memberSyntaxSortOrder: {
          type: "array",
          items: {
            enum: ["none", "all", "multiple", "single"]
          },
          uniqueItems: true,
          minItems: 4,
          maxItems: 4
        },
        ignoreDeclarationSort: {
          type: "boolean",
          default: false
        },
        ignoreMemberSort: {
          type: "boolean",
          default: false
        },
        allowSeparatedGroups: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      sortImportsAlphabetically: "Imports should be sorted alphabetically.",
      sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
      unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
    }
  },

  create(context) {
    const configuration = context.options[0] || {},
          ignoreCase = configuration.ignoreCase || false,
          ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,
          ignoreMemberSort = configuration.ignoreMemberSort || false,
          memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
          allowSeparatedGroups = configuration.allowSeparatedGroups || false,
          sourceCode = context.getSourceCode();
    let previousDeclaration = null;

    function usedMemberSyntax(node) {
      if (node.specifiers.length === 0) {
        return "none";
      }

      if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
        return "all";
      }

      if (node.specifiers.length === 1) {
        return "single";
      }

      return "multiple";
    }

    function getMemberParameterGroupIndex(node) {
      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
    }

    function getFirstLocalMemberName(node) {
      if (node.specifiers[0]) {
        return node.specifiers[0].local.name;
      }

      return null;
    }

    function getNumberOfLinesBetween(left, right) {
      return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);
    }

    return {
      ImportDeclaration(node) {
        if (!ignoreDeclarationSort) {
          if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {
            previousDeclaration = null;
          }

          if (previousDeclaration) {
            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
                  previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
            let currentLocalMemberName = getFirstLocalMemberName(node),
                previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);

            if (ignoreCase) {
              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
            }

            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                context.report({
                  node,
                  messageId: "unexpectedSyntaxOrder",
                  data: {
                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                  }
                });
              }
            } else {
              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
                context.report({
                  node,
                  messageId: "sortImportsAlphabetically"
                });
              }
            }
          }

          previousDeclaration = node;
        }

        if (!ignoreMemberSort) {
          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === "ImportSpecifier");
          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;
          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);

          if (firstUnsortedIndex !== -1) {
            context.report({
              node: importSpecifiers[firstUnsortedIndex],
              messageId: "sortMembersAlphabetically",
              data: {
                memberName: importSpecifiers[firstUnsortedIndex].local.name
              },

              fix(fixer) {
                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {
                  return null;
                }

                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers.slice().sort((specifierA, specifierB) => {
                  const aName = getSortableName(specifierA);
                  const bName = getSortableName(specifierB);
                  return aName > bName ? 1 : -1;
                }).reduce((sourceText, specifier, index) => {
                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);
                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
                }, ""));
              }

            });
          }
        }
      }

    };
  }

};

function getPropertyName(node) {
  const staticName = astUtils.getStaticPropertyName(node);

  if (staticName !== null) {
    return staticName;
  }

  return node.key.name || null;
}

const isValidOrders = {
  asc(a, b) {
    return a <= b;
  },

  ascI(a, b) {
    return a.toLowerCase() <= b.toLowerCase();
  },

  ascN(a, b) {
    return naturalCompare__default['default'](a, b) <= 0;
  },

  ascIN(a, b) {
    return naturalCompare__default['default'](a.toLowerCase(), b.toLowerCase()) <= 0;
  },

  desc(a, b) {
    return isValidOrders.asc(b, a);
  },

  descI(a, b) {
    return isValidOrders.ascI(b, a);
  },

  descN(a, b) {
    return isValidOrders.ascN(b, a);
  },

  descIN(a, b) {
    return isValidOrders.ascIN(b, a);
  }

};
var sortKeys = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require object keys to be sorted",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-keys"
    },
    schema: [{
      enum: ["asc", "desc"]
    }, {
      type: "object",
      properties: {
        caseSensitive: {
          type: "boolean",
          default: true
        },
        natural: {
          type: "boolean",
          default: false
        },
        minKeys: {
          type: "integer",
          minimum: 2,
          default: 2
        }
      },
      additionalProperties: false
    }],
    messages: {
      sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
    }
  },

  create(context) {
    const order = context.options[0] || "asc";
    const options = context.options[1];
    const insensitive = options && options.caseSensitive === false;
    const natural = options && options.natural;
    const minKeys = options && options.minKeys;
    const isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natural ? "N" : "")];
    let stack = null;
    return {
      ObjectExpression(node) {
        stack = {
          upper: stack,
          prevName: null,
          numKeys: node.properties.length
        };
      },

      "ObjectExpression:exit"() {
        stack = stack.upper;
      },

      SpreadElement(node) {
        if (node.parent.type === "ObjectExpression") {
          stack.prevName = null;
        }
      },

      Property(node) {
        if (node.parent.type === "ObjectPattern") {
          return;
        }

        const prevName = stack.prevName;
        const numKeys = stack.numKeys;
        const thisName = getPropertyName(node);

        if (thisName !== null) {
          stack.prevName = thisName;
        }

        if (prevName === null || thisName === null || numKeys < minKeys) {
          return;
        }

        if (!isValidOrder(prevName, thisName)) {
          context.report({
            node,
            loc: node.key.loc,
            messageId: "sortKeys",
            data: {
              thisName,
              prevName,
              order,
              insensitive: insensitive ? "insensitive " : "",
              natural: natural ? "natural " : ""
            }
          });
        }
      }

    };
  }

};
var sortVars = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require variables within the same declaration block to be sorted",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-vars"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      sortVars: "Variables within the same declaration block should be sorted alphabetically."
    }
  },

  create(context) {
    const configuration = context.options[0] || {},
          ignoreCase = configuration.ignoreCase || false,
          sourceCode = context.getSourceCode();
    return {
      VariableDeclaration(node) {
        const idDeclarations = node.declarations.filter(decl => decl.id.type === "Identifier");
        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;
        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== "Literal");
        let fixed = false;
        idDeclarations.slice(1).reduce((memo, decl) => {
          const lastVariableName = getSortableName(memo),
                currentVariableName = getSortableName(decl);

          if (currentVariableName < lastVariableName) {
            context.report({
              node: decl,
              messageId: "sortVars",

              fix(fixer) {
                if (unfixable || fixed) {
                  return null;
                }

                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations.slice().sort((declA, declB) => {
                  const aName = getSortableName(declA);
                  const bName = getSortableName(declB);
                  return aName > bName ? 1 : -1;
                }).reduce((sourceText, identifier, index) => {
                  const textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);
                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
                }, ""));
              }

            });
            fixed = true;
            return memo;
          }

          return decl;
        }, idDeclarations[0]);
      }

    };
  }

};

function isFunctionBody(node) {
  const parent = node.parent;
  return node.type === "BlockStatement" && astUtils.isFunction(parent) && parent.body === node;
}

var spaceBeforeBlocks = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-before-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          keywords: {
            enum: ["always", "never", "off"]
          },
          functions: {
            enum: ["always", "never", "off"]
          },
          classes: {
            enum: ["always", "never", "off"]
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedSpace: "Unexpected space before opening brace.",
      missingSpace: "Missing space before opening brace."
    }
  },

  create(context) {
    const config = context.options[0],
          sourceCode = context.getSourceCode();
    let alwaysFunctions = true,
        alwaysKeywords = true,
        alwaysClasses = true,
        neverFunctions = false,
        neverKeywords = false,
        neverClasses = false;

    if (typeof config === "object") {
      alwaysFunctions = config.functions === "always";
      alwaysKeywords = config.keywords === "always";
      alwaysClasses = config.classes === "always";
      neverFunctions = config.functions === "never";
      neverKeywords = config.keywords === "never";
      neverClasses = config.classes === "never";
    } else if (config === "never") {
      alwaysFunctions = false;
      alwaysKeywords = false;
      alwaysClasses = false;
      neverFunctions = true;
      neverKeywords = true;
      neverClasses = true;
    }

    function isConflicted(precedingToken, node) {
      return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node);
    }

    function checkPrecedingSpace(node) {
      const precedingToken = sourceCode.getTokenBefore(node);

      if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {
        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
        let requireSpace;
        let requireNoSpace;

        if (isFunctionBody(node)) {
          requireSpace = alwaysFunctions;
          requireNoSpace = neverFunctions;
        } else if (node.type === "ClassBody") {
          requireSpace = alwaysClasses;
          requireNoSpace = neverClasses;
        } else {
          requireSpace = alwaysKeywords;
          requireNoSpace = neverKeywords;
        }

        if (requireSpace && !hasSpace) {
          context.report({
            node,
            messageId: "missingSpace",

            fix(fixer) {
              return fixer.insertTextBefore(node, " ");
            }

          });
        } else if (requireNoSpace && hasSpace) {
          context.report({
            node,
            messageId: "unexpectedSpace",

            fix(fixer) {
              return fixer.removeRange([precedingToken.range[1], node.range[0]]);
            }

          });
        }
      }
    }

    return {
      BlockStatement: checkPrecedingSpace,
      ClassBody: checkPrecedingSpace,
      SwitchStatement: function (node) {
        const cases = node.cases;
        let openingBrace;

        if (cases.length > 0) {
          openingBrace = sourceCode.getTokenBefore(cases[0]);
        } else {
          openingBrace = sourceCode.getLastToken(node, 1);
        }

        checkPrecedingSpace(openingBrace);
      }
    };
  }

};
var spaceBeforeFunctionParen = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before `function` definition opening parenthesis",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-before-function-paren"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          anonymous: {
            enum: ["always", "never", "ignore"]
          },
          named: {
            enum: ["always", "never", "ignore"]
          },
          asyncArrow: {
            enum: ["always", "never", "ignore"]
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedSpace: "Unexpected space before function parentheses.",
      missingSpace: "Missing space before function parentheses."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
    const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};

    function isNamedFunction(node) {
      if (node.id) {
        return true;
      }

      const parent = node.parent;
      return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
    }

    function getConfigForFunction(node) {
      if (node.type === "ArrowFunctionExpression") {
        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {
          skip: 1
        }))) {
          return overrideConfig.asyncArrow || baseConfig;
        }
      } else if (isNamedFunction(node)) {
        return overrideConfig.named || baseConfig;
      } else if (!node.generator) {
        return overrideConfig.anonymous || baseConfig;
      }

      return "ignore";
    }

    function checkFunction(node) {
      const functionConfig = getConfigForFunction(node);

      if (functionConfig === "ignore") {
        return;
      }

      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
      const leftToken = sourceCode.getTokenBefore(rightToken);
      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);

      if (hasSpacing && functionConfig === "never") {
        context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: rightToken.loc.start
          },
          messageId: "unexpectedSpace",

          fix(fixer) {
            const comments = sourceCode.getCommentsBefore(rightToken);

            if (comments.some(comment => comment.type === "Line")) {
              return null;
            }

            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
          }

        });
      } else if (!hasSpacing && functionConfig === "always") {
        context.report({
          node,
          loc: rightToken.loc,
          messageId: "missingSpace",
          fix: fixer => fixer.insertTextAfter(leftToken, " ")
        });
      }
    }

    return {
      ArrowFunctionExpression: checkFunction,
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction
    };
  }

};
var spaceInParens = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside parentheses",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-in-parens"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["{}", "[]", "()", "empty"]
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingOpeningSpace: "There must be a space after this paren.",
      missingClosingSpace: "There must be a space before this paren.",
      rejectedOpeningSpace: "There should be no space after this paren.",
      rejectedClosingSpace: "There should be no space before this paren."
    }
  },

  create(context) {
    const ALWAYS = context.options[0] === "always",
          exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],
          options = {};
    let exceptions;

    if (exceptionsArrayOptions.length) {
      options.braceException = exceptionsArrayOptions.includes("{}");
      options.bracketException = exceptionsArrayOptions.includes("[]");
      options.parenException = exceptionsArrayOptions.includes("()");
      options.empty = exceptionsArrayOptions.includes("empty");
    }

    function getExceptions() {
      const openers = [],
            closers = [];

      if (options.braceException) {
        openers.push("{");
        closers.push("}");
      }

      if (options.bracketException) {
        openers.push("[");
        closers.push("]");
      }

      if (options.parenException) {
        openers.push("(");
        closers.push(")");
      }

      if (options.empty) {
        openers.push(")");
        closers.push("(");
      }

      return {
        openers,
        closers
      };
    }

    const sourceCode = context.getSourceCode();

    function isOpenerException(token) {
      return exceptions.openers.includes(token.value);
    }

    function isCloserException(token) {
      return exceptions.closers.includes(token.value);
    }

    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {
      if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
        return false;
      }

      if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {
        return false;
      }

      if (ALWAYS) {
        return !isOpenerException(tokenAfterOpeningParen);
      }

      return isOpenerException(tokenAfterOpeningParen);
    }

    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {
      if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {
        return false;
      }

      if (tokenAfterOpeningParen.type === "Line") {
        return false;
      }

      if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
        return false;
      }

      if (ALWAYS) {
        return isOpenerException(tokenAfterOpeningParen);
      }

      return !isOpenerException(tokenAfterOpeningParen);
    }

    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {
      if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
        return false;
      }

      if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {
        return false;
      }

      if (ALWAYS) {
        return !isCloserException(tokenBeforeClosingParen);
      }

      return isCloserException(tokenBeforeClosingParen);
    }

    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {
      if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {
        return false;
      }

      if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
        return false;
      }

      if (ALWAYS) {
        return isCloserException(tokenBeforeClosingParen);
      }

      return !isCloserException(tokenBeforeClosingParen);
    }

    return {
      Program: function (node) {
        exceptions = getExceptions();
        const tokens = sourceCode.tokensAndComments;
        tokens.forEach((token, i) => {
          const prevToken = tokens[i - 1];
          const nextToken = tokens[i + 1];

          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
            return;
          }

          if (token.value === "(" && openerMissingSpace(token, nextToken)) {
            context.report({
              node,
              loc: token.loc,
              messageId: "missingOpeningSpace",

              fix(fixer) {
                return fixer.insertTextAfter(token, " ");
              }

            });
          }

          if (token.value === "(" && openerRejectsSpace(token, nextToken)) {
            context.report({
              node,
              loc: {
                start: token.loc.end,
                end: nextToken.loc.start
              },
              messageId: "rejectedOpeningSpace",

              fix(fixer) {
                return fixer.removeRange([token.range[1], nextToken.range[0]]);
              }

            });
          }

          if (token.value === ")" && closerMissingSpace(prevToken, token)) {
            context.report({
              node,
              loc: token.loc,
              messageId: "missingClosingSpace",

              fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }

            });
          }

          if (token.value === ")" && closerRejectsSpace(prevToken, token)) {
            context.report({
              node,
              loc: {
                start: prevToken.loc.end,
                end: token.loc.start
              },
              messageId: "rejectedClosingSpace",

              fix(fixer) {
                return fixer.removeRange([prevToken.range[1], token.range[0]]);
              }

            });
          }
        });
      }
    };
  }

};
var spaceInfixOps = {
  meta: {
    type: "layout",
    docs: {
      description: "require spacing around infix operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-infix-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        int32Hint: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingSpace: "Operator '{{operator}}' must be spaced."
    }
  },

  create(context) {
    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
    const sourceCode = context.getSourceCode();

    function getFirstNonSpacedToken(left, right, op) {
      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);
      const prev = sourceCode.getTokenBefore(operator);
      const next = sourceCode.getTokenAfter(operator);

      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {
        return operator;
      }

      return null;
    }

    function report(mainNode, culpritToken) {
      context.report({
        node: mainNode,
        loc: culpritToken.loc,
        messageId: "missingSpace",
        data: {
          operator: culpritToken.value
        },

        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(culpritToken);
          const afterToken = sourceCode.getTokenAfter(culpritToken);
          let fixString = "";

          if (culpritToken.range[0] - previousToken.range[1] === 0) {
            fixString = " ";
          }

          fixString += culpritToken.value;

          if (afterToken.range[0] - culpritToken.range[1] === 0) {
            fixString += " ";
          }

          return fixer.replaceText(culpritToken, fixString);
        }

      });
    }

    function checkBinary(node) {
      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
      const rightNode = node.right;
      const operator = node.operator || "=";
      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);

      if (nonSpacedNode) {
        if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
          report(node, nonSpacedNode);
        }
      }
    }

    return {
      AssignmentExpression: checkBinary,
      AssignmentPattern: checkBinary,
      BinaryExpression: checkBinary,
      LogicalExpression: checkBinary,
      ConditionalExpression: function (node) {
        const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, "?");
        const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, ":");

        if (nonSpacedConsequentNode) {
          report(node, nonSpacedConsequentNode);
        }

        if (nonSpacedAlternateNode) {
          report(node, nonSpacedAlternateNode);
        }
      },
      VariableDeclarator: function (node) {
        const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
        const rightNode = node.init;

        if (rightNode) {
          const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, "=");

          if (nonSpacedNode) {
            report(node, nonSpacedNode);
          }
        }
      }
    };
  }

};
var spaceUnaryOps = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before or after unary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-unary-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        words: {
          type: "boolean",
          default: true
        },
        nonwords: {
          type: "boolean",
          default: false
        },
        overrides: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
      unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
      unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
      wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
      operator: "Unary operator '{{operator}}' must be followed by whitespace.",
      beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
    }
  },

  create(context) {
    const options = context.options[0] || {
      words: true,
      nonwords: false
    };
    const sourceCode = context.getSourceCode();

    function isFirstBangInBangBangExpression(node) {
      return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }

    function overrideExistsForOperator(operator) {
      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
    }

    function overrideEnforcesSpaces(operator) {
      return options.overrides[operator];
    }

    function verifyWordHasSpaces(node, firstToken, secondToken, word) {
      if (secondToken.range[0] === firstToken.range[1]) {
        context.report({
          node,
          messageId: "wordOperator",
          data: {
            word
          },

          fix(fixer) {
            return fixer.insertTextAfter(firstToken, " ");
          }

        });
      }
    }

    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedAfterWord",
            data: {
              word
            },

            fix(fixer) {
              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            }

          });
        }
      }
    }

    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
      if (overrideExistsForOperator(word)) {
        if (overrideEnforcesSpaces(word)) {
          verifyWordHasSpaces(node, firstToken, secondToken, word);
        } else {
          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
        }
      } else if (options.words) {
        verifyWordHasSpaces(node, firstToken, secondToken, word);
      } else {
        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
      }
    }

    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
      if (node.prefix) {
        if (isFirstBangInBangBangExpression(node)) {
          return;
        }

        if (firstToken.range[1] === secondToken.range[0]) {
          context.report({
            node,
            messageId: "operator",
            data: {
              operator: firstToken.value
            },

            fix(fixer) {
              return fixer.insertTextAfter(firstToken, " ");
            }

          });
        }
      } else {
        if (firstToken.range[1] === secondToken.range[0]) {
          context.report({
            node,
            messageId: "beforeUnaryExpressions",
            data: {
              token: secondToken.value
            },

            fix(fixer) {
              return fixer.insertTextBefore(secondToken, " ");
            }

          });
        }
      }
    }

    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
      if (node.prefix) {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedAfter",
            data: {
              operator: firstToken.value
            },

            fix(fixer) {
              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
              }

              return null;
            }

          });
        }
      } else {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedBefore",
            data: {
              operator: secondToken.value
            },

            fix(fixer) {
              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            }

          });
        }
      }
    }

    function checkForSpaces(node) {
      const tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
      const firstToken = tokens[0];
      const secondToken = tokens[1];

      if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
        return;
      }

      const operator = node.prefix ? tokens[0].value : tokens[1].value;

      if (overrideExistsForOperator(operator)) {
        if (overrideEnforcesSpaces(operator)) {
          verifyNonWordsHaveSpaces(node, firstToken, secondToken);
        } else {
          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
        }
      } else if (options.nonwords) {
        verifyNonWordsHaveSpaces(node, firstToken, secondToken);
      } else {
        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
      }
    }

    return {
      UnaryExpression: checkForSpaces,
      UpdateExpression: checkForSpaces,
      NewExpression: checkForSpaces,
      YieldExpression: function (node) {
        const tokens = sourceCode.getFirstTokens(node, 3);

        if (!node.argument || node.delegate) {
          return;
        }

        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "yield");
      },
      AwaitExpression: function (node) {
        const tokens = sourceCode.getFirstTokens(node, 3);
        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
      }
    };
  }

};

function escape(s) {
  return `(?:${lodash__default['default'].escapeRegExp(s)})`;
}

function escapeAndRepeat(s) {
  return `${escape(s)}+`;
}

function parseMarkersOption(markers) {
  if (markers.indexOf("*") === -1) {
    return markers.concat("*");
  }

  return markers;
}

function createExceptionsPattern(exceptions) {
  let pattern = "";

  if (exceptions.length === 0) {
    pattern += "\\s";
  } else {
    pattern += "(?:\\s|";

    if (exceptions.length === 1) {
      pattern += escapeAndRepeat(exceptions[0]);
    } else {
      pattern += "(?:";
      pattern += exceptions.map(escapeAndRepeat).join("|");
      pattern += ")";
    }

    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;
  }

  return pattern;
}

function createAlwaysStylePattern(markers, exceptions) {
  let pattern = "^";

  if (markers.length === 1) {
    pattern += escape(markers[0]);
  } else {
    pattern += "(?:";
    pattern += markers.map(escape).join("|");
    pattern += ")";
  }

  pattern += "?";
  pattern += createExceptionsPattern(exceptions);
  return new RegExp(pattern, "u");
}

function createNeverStylePattern(markers) {
  const pattern = `^(${markers.map(escape).join("|")})?[ \t]+`;
  return new RegExp(pattern, "u");
}

var spacedComment = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent spacing after the `//` or `/*` in a comment",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/spaced-comment"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        markers: {
          type: "array",
          items: {
            type: "string"
          }
        },
        line: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        },
        block: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            balanced: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
      expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
      unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
      unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
      expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
      expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const requireSpace = context.options[0] !== "never";
    const config = context.options[1] || {};
    const balanced = config.block && config.block.balanced;
    const styleRules = ["block", "line"].reduce((rule, type) => {
      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);
      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
      rule[type] = {
        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, "u") : new RegExp("[ \t]+$", "u"),
        hasExceptions: exceptions.length > 0,
        captureMarker: new RegExp(`^(${markers.map(escape).join("|")})`, "u"),
        markers: new Set(markers)
      };
      return rule;
    }, {});

    function reportBegin(node, messageId, match, refChar) {
      const type = node.type.toLowerCase(),
            commentIdentifier = type === "block" ? "/*" : "//";
      context.report({
        node,

        fix(fixer) {
          const start = node.range[0];
          let end = start + 2;

          if (requireSpace) {
            if (match) {
              end += match[0].length;
            }

            return fixer.insertTextAfterRange([start, end], " ");
          }

          end += match[0].length;
          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
        },

        messageId,
        data: {
          refChar
        }
      });
    }

    function reportEnd(node, messageId, match) {
      context.report({
        node,

        fix(fixer) {
          if (requireSpace) {
            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
          }

          const end = node.range[1] - 2,
                start = end - match[0].length;
          return fixer.replaceTextRange([start, end], "");
        },

        messageId
      });
    }

    function checkCommentForSpace(node) {
      const type = node.type.toLowerCase(),
            rule = styleRules[type],
            commentIdentifier = type === "block" ? "/*" : "//";

      if (node.value.length === 0 || rule.markers.has(node.value)) {
        return;
      }

      const beginMatch = rule.beginRegex.exec(node.value);
      const endMatch = rule.endRegex.exec(node.value);

      if (requireSpace) {
        if (!beginMatch) {
          const hasMarker = rule.captureMarker.exec(node.value);
          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;

          if (rule.hasExceptions) {
            reportBegin(node, "expectedExceptionAfter", hasMarker, marker);
          } else {
            reportBegin(node, "expectedSpaceAfter", hasMarker, marker);
          }
        }

        if (balanced && type === "block" && !endMatch) {
          reportEnd(node, "expectedSpaceBefore");
        }
      } else {
        if (beginMatch) {
          if (!beginMatch[1]) {
            reportBegin(node, "unexpectedSpaceAfter", beginMatch, commentIdentifier);
          } else {
            reportBegin(node, "unexpectedSpaceAfterMarker", beginMatch, beginMatch[1]);
          }
        }

        if (balanced && type === "block" && endMatch) {
          reportEnd(node, "unexpectedSpaceBefore", endMatch);
        }
      }
    }

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(checkCommentForSpace);
      }

    };
  }

};

function getUseStrictDirectives(statements) {
  const directives = [];

  for (let i = 0; i < statements.length; i++) {
    const statement = statements[i];

    if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
      directives[i] = statement;
    } else {
      break;
    }
  }

  return directives;
}

function isSimpleParameter(node) {
  return node.type === "Identifier";
}

function isSimpleParameterList(params) {
  return params.every(isSimpleParameter);
}

var strict = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow strict mode directives",
      category: "Strict Mode",
      recommended: false,
      url: "https://eslint.org/docs/rules/strict"
    },
    schema: [{
      enum: ["never", "global", "function", "safe"]
    }],
    fixable: "code",
    messages: {
      function: "Use the function form of 'use strict'.",
      global: "Use the global form of 'use strict'.",
      multiple: "Multiple 'use strict' directives.",
      never: "Strict mode is not permitted.",
      unnecessary: "Unnecessary 'use strict' directive.",
      module: "'use strict' is unnecessary inside of modules.",
      implied: "'use strict' is unnecessary when implied strict mode is enabled.",
      unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
      nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
      wrap: "Wrap {{name}} in a function with 'use strict' directive."
    }
  },

  create(context) {
    const ecmaFeatures = context.parserOptions.ecmaFeatures || {},
          scopes = [],
          classScopes = [];
    let mode = context.options[0] || "safe";

    if (ecmaFeatures.impliedStrict) {
      mode = "implied";
    } else if (mode === "safe") {
      mode = ecmaFeatures.globalReturn ? "global" : "function";
    }

    function shouldFix(errorType) {
      return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
    }

    function getFixFunction(node) {
      return fixer => fixer.remove(node);
    }

    function reportSlice(nodes, start, end, messageId, fix) {
      nodes.slice(start, end).forEach(node => {
        context.report({
          node,
          messageId,
          fix: fix ? getFixFunction(node) : null
        });
      });
    }

    function reportAll(nodes, messageId, fix) {
      reportSlice(nodes, 0, nodes.length, messageId, fix);
    }

    function reportAllExceptFirst(nodes, messageId, fix) {
      reportSlice(nodes, 1, nodes.length, messageId, fix);
    }

    function enterFunctionInFunctionMode(node, useStrictDirectives) {
      const isInClass = classScopes.length > 0,
            isParentGlobal = scopes.length === 0 && classScopes.length === 0,
            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
            isStrict = useStrictDirectives.length > 0;

      if (isStrict) {
        if (!isSimpleParameterList(node.params)) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "nonSimpleParameterList"
          });
        } else if (isParentStrict) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "unnecessary",
            fix: getFixFunction(useStrictDirectives[0])
          });
        } else if (isInClass) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "unnecessaryInClasses",
            fix: getFixFunction(useStrictDirectives[0])
          });
        }

        reportAllExceptFirst(useStrictDirectives, "multiple", true);
      } else if (isParentGlobal) {
        if (isSimpleParameterList(node.params)) {
          context.report({
            node,
            messageId: "function"
          });
        } else {
          context.report({
            node,
            messageId: "wrap",
            data: {
              name: astUtils.getFunctionNameWithKind(node)
            }
          });
        }
      }

      scopes.push(isParentStrict || isStrict);
    }

    function exitFunctionInFunctionMode() {
      scopes.pop();
    }

    function enterFunction(node) {
      const isBlock = node.body.type === "BlockStatement",
            useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];

      if (mode === "function") {
        enterFunctionInFunctionMode(node, useStrictDirectives);
      } else if (useStrictDirectives.length > 0) {
        if (isSimpleParameterList(node.params)) {
          reportAll(useStrictDirectives, mode, shouldFix(mode));
        } else {
          context.report({
            node: useStrictDirectives[0],
            messageId: "nonSimpleParameterList"
          });
          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        }
      }
    }

    const rule = {
      Program(node) {
        const useStrictDirectives = getUseStrictDirectives(node.body);

        if (node.sourceType === "module") {
          mode = "module";
        }

        if (mode === "global") {
          if (node.body.length > 0 && useStrictDirectives.length === 0) {
            context.report({
              node,
              messageId: "global"
            });
          }

          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        } else {
          reportAll(useStrictDirectives, mode, shouldFix(mode));
        }
      },

      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      ArrowFunctionExpression: enterFunction
    };

    if (mode === "function") {
      Object.assign(rule, {
        ClassBody() {
          classScopes.push(true);
        },

        "ClassBody:exit"() {
          classScopes.pop();
        },

        "FunctionDeclaration:exit": exitFunctionInFunctionMode,
        "FunctionExpression:exit": exitFunctionInFunctionMode,
        "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
      });
    }

    return rule;
  }

};
var switchColonSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing around colons of switch statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/switch-colon-spacing"
    },
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace",
    messages: {
      expectedBefore: "Expected space(s) before this colon.",
      expectedAfter: "Expected space(s) after this colon.",
      unexpectedBefore: "Unexpected space(s) before this colon.",
      unexpectedAfter: "Unexpected space(s) after this colon."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {};
    const beforeSpacing = options.before === true;
    const afterSpacing = options.after !== false;

    function getColonToken(node) {
      if (node.test) {
        return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
      }

      return sourceCode.getFirstToken(node, 1);
    }

    function isValidSpacing(left, right, expected) {
      return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
    }

    function commentsExistBetween(left, right) {
      return sourceCode.getFirstTokenBetween(left, right, {
        includeComments: true,
        filter: astUtils.isCommentToken
      }) !== null;
    }

    function fix(fixer, left, right, spacing) {
      if (commentsExistBetween(left, right)) {
        return null;
      }

      if (spacing) {
        return fixer.insertTextAfter(left, " ");
      }

      return fixer.removeRange([left.range[1], right.range[0]]);
    }

    return {
      SwitchCase(node) {
        const colonToken = getColonToken(node);
        const beforeToken = sourceCode.getTokenBefore(colonToken);
        const afterToken = sourceCode.getTokenAfter(colonToken);

        if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
          context.report({
            node,
            loc: colonToken.loc,
            messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
            fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)
          });
        }

        if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
          context.report({
            node,
            loc: colonToken.loc,
            messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
            fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)
          });
        }
      }

    };
  }

};
var symbolDescription = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require symbol descriptions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/symbol-description"
    },
    fixable: null,
    schema: [],
    messages: {
      expected: "Expected Symbol to have a description."
    }
  },

  create(context) {
    function checkArgument(node) {
      if (node.arguments.length === 0) {
        context.report({
          node,
          messageId: "expected"
        });
      }
    }

    return {
      "Program:exit"() {
        const scope = context.getScope();
        const variable = astUtils.getVariableByName(scope, "Symbol");

        if (variable && variable.defs.length === 0) {
          variable.references.forEach(reference => {
            const node = reference.identifier;

            if (astUtils.isCallee(node)) {
              checkArgument(node.parent);
            }
          });
        }
      }

    };
  }

};
var templateCurlySpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around embedded expressions of template strings",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/template-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expectedBefore: "Expected space(s) before '}'.",
      expectedAfter: "Expected space(s) after '${'.",
      unexpectedBefore: "Unexpected space(s) before '}'.",
      unexpectedAfter: "Unexpected space(s) after '${'."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    const always = context.options[0] === "always";

    function checkSpacingBefore(token) {
      if (!token.value.startsWith("}")) {
        return;
      }

      const prevToken = sourceCode.getTokenBefore(token, {
        includeComments: true
      }),
            hasSpace = sourceCode.isSpaceBetween(prevToken, token);

      if (!astUtils.isTokenOnSameLine(prevToken, token)) {
        return;
      }

      if (always && !hasSpace) {
        context.report({
          loc: {
            start: token.loc.start,
            end: {
              line: token.loc.start.line,
              column: token.loc.start.column + 1
            }
          },
          messageId: "expectedBefore",
          fix: fixer => fixer.insertTextBefore(token, " ")
        });
      }

      if (!always && hasSpace) {
        context.report({
          loc: {
            start: prevToken.loc.end,
            end: token.loc.start
          },
          messageId: "unexpectedBefore",
          fix: fixer => fixer.removeRange([prevToken.range[1], token.range[0]])
        });
      }
    }

    function checkSpacingAfter(token) {
      if (!token.value.endsWith("${")) {
        return;
      }

      const nextToken = sourceCode.getTokenAfter(token, {
        includeComments: true
      }),
            hasSpace = sourceCode.isSpaceBetween(token, nextToken);

      if (!astUtils.isTokenOnSameLine(token, nextToken)) {
        return;
      }

      if (always && !hasSpace) {
        context.report({
          loc: {
            start: {
              line: token.loc.end.line,
              column: token.loc.end.column - 2
            },
            end: token.loc.end
          },
          messageId: "expectedAfter",
          fix: fixer => fixer.insertTextAfter(token, " ")
        });
      }

      if (!always && hasSpace) {
        context.report({
          loc: {
            start: token.loc.end,
            end: nextToken.loc.start
          },
          messageId: "unexpectedAfter",
          fix: fixer => fixer.removeRange([token.range[1], nextToken.range[0]])
        });
      }
    }

    return {
      TemplateElement(node) {
        const token = sourceCode.getFirstToken(node);
        checkSpacingBefore(token);
        checkSpacingAfter(token);
      }

    };
  }

};
var templateTagSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between template tags and their literals",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/template-tag-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpected: "Unexpected space between template tag and template literal.",
      missing: "Missing space between template tag and template literal."
    }
  },

  create(context) {
    const never = context.options[0] !== "always";
    const sourceCode = context.getSourceCode();
    return {
      TaggedTemplateExpression: function (node) {
        const tagToken = sourceCode.getTokenBefore(node.quasi);
        const literalToken = sourceCode.getFirstToken(node.quasi);
        const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);

        if (never && hasWhitespace) {
          context.report({
            node,
            loc: {
              start: tagToken.loc.end,
              end: literalToken.loc.start
            },
            messageId: "unexpected",

            fix(fixer) {
              const comments = sourceCode.getCommentsBefore(node.quasi);

              if (comments.some(comment => comment.type === "Line")) {
                return null;
              }

              return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
            }

          });
        } else if (!never && !hasWhitespace) {
          context.report({
            node,
            loc: {
              start: node.loc.start,
              end: literalToken.loc.start
            },
            messageId: "missing",

            fix(fixer) {
              return fixer.insertTextAfter(tagToken, " ");
            }

          });
        }
      }
    };
  }

};
var unicodeBom = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow Unicode byte order mark (BOM)",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/unicode-bom"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expected: "Expected Unicode BOM (Byte Order Mark).",
      unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
    }
  },

  create(context) {
    return {
      Program: function (node) {
        const sourceCode = context.getSourceCode(),
              location = {
          column: 0,
          line: 1
        },
              requireBOM = context.options[0] || "never";

        if (!sourceCode.hasBOM && requireBOM === "always") {
          context.report({
            node,
            loc: location,
            messageId: "expected",

            fix(fixer) {
              return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
            }

          });
        } else if (sourceCode.hasBOM && requireBOM === "never") {
          context.report({
            node,
            loc: location,
            messageId: "unexpected",

            fix(fixer) {
              return fixer.removeRange([-1, 0]);
            }

          });
        }
      }
    };
  }

};

function isNaNIdentifier(node) {
  return Boolean(node) && node.type === "Identifier" && node.name === "NaN";
}

var useIsnan = {
  meta: {
    type: "problem",
    docs: {
      description: "require calls to `isNaN()` when checking for `NaN`",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/use-isnan"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForSwitchCase: {
          type: "boolean",
          default: true
        },
        enforceForIndexOf: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      comparisonWithNaN: "Use the isNaN function to compare with NaN.",
      switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
      caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
      indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN."
    }
  },

  create(context) {
    const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;
    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;

    function checkSwitchStatement(node) {
      if (isNaNIdentifier(node.discriminant)) {
        context.report({
          node,
          messageId: "switchNaN"
        });
      }

      for (const switchCase of node.cases) {
        if (isNaNIdentifier(switchCase.test)) {
          context.report({
            node: switchCase,
            messageId: "caseNaN"
          });
        }
      }
    }

    function checkCallExpression(node) {
      const callee = astUtils.skipChainExpression(node.callee);

      if (callee.type === "MemberExpression") {
        const methodName = astUtils.getStaticPropertyName(callee);

        if ((methodName === "indexOf" || methodName === "lastIndexOf") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {
          context.report({
            node,
            messageId: "indexOfNaN",
            data: {
              methodName
            }
          });
        }
      }
    }

    const listeners = {
      BinaryExpression: function (node) {
        if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {
          context.report({
            node,
            messageId: "comparisonWithNaN"
          });
        }
      }
    };

    if (enforceForSwitchCase) {
      listeners.SwitchStatement = checkSwitchStatement;
    }

    if (enforceForIndexOf) {
      listeners.CallExpression = checkCallExpression;
    }

    return listeners;
  }

};
var validJsdoc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce valid JSDoc comments",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/valid-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        prefer: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        preferType: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        requireReturn: {
          type: "boolean",
          default: true
        },
        requireParamDescription: {
          type: "boolean",
          default: true
        },
        requireReturnDescription: {
          type: "boolean",
          default: true
        },
        matchDescription: {
          type: "string"
        },
        requireReturnType: {
          type: "boolean",
          default: true
        },
        requireParamType: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
      expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
      use: "Use @{{name}} instead.",
      useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
      syntaxError: "JSDoc syntax error.",
      missingBrace: "JSDoc type missing brace.",
      missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
      missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
      missingReturnType: "Missing JSDoc return type.",
      missingReturnDesc: "Missing JSDoc return description.",
      missingReturn: "Missing JSDoc @{{returns}} for function.",
      missingParam: "Missing JSDoc for parameter '{{name}}'.",
      duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
      unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
    },
    deprecated: true,
    replacedBy: []
  },

  create(context) {
    const options = context.options[0] || {},
          prefer = options.prefer || {},
          sourceCode = context.getSourceCode(),
          requireReturn = options.requireReturn !== false,
          requireParamDescription = options.requireParamDescription !== false,
          requireReturnDescription = options.requireReturnDescription !== false,
          requireReturnType = options.requireReturnType !== false,
          requireParamType = options.requireParamType !== false,
          preferType = options.preferType || {},
          checkPreferType = Object.keys(preferType).length !== 0;
    const fns = [];

    function isTypeClass(node) {
      return node.type === "ClassExpression" || node.type === "ClassDeclaration";
    }

    function startFunction(node) {
      fns.push({
        returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node) || node.async
      });
    }

    function isValidReturnType(tag) {
      return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
    }

    function canTypeBeValidated(type) {
      return type !== "UndefinedLiteral" && type !== "NullLiteral" && type !== "NullableLiteral" && type !== "FunctionType" && type !== "AllLiteral";
    }

    function getCurrentExpectedTypes(type) {
      let currentType;

      if (type.name) {
        currentType = type;
      } else if (type.expression) {
        currentType = type.expression;
      }

      return {
        currentType,
        expectedTypeName: currentType && preferType[currentType.name]
      };
    }

    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {
      return {
        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
      };
    }

    function validateType(jsdocNode, type) {
      if (!type || !canTypeBeValidated(type.type)) {
        return;
      }

      const typesToCheck = [];
      let elements = [];

      switch (type.type) {
        case "TypeApplication":
          elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
          typesToCheck.push(getCurrentExpectedTypes(type));
          break;

        case "RecordType":
          elements = type.fields;
          break;

        case "UnionType":
        case "ArrayType":
          elements = type.elements;
          break;

        case "FieldType":
          if (type.value) {
            typesToCheck.push(getCurrentExpectedTypes(type.value));
          }

          break;

        default:
          typesToCheck.push(getCurrentExpectedTypes(type));
      }

      elements.forEach(validateType.bind(null, jsdocNode));
      typesToCheck.forEach(typeToCheck => {
        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {
          context.report({
            node: jsdocNode,
            messageId: "useType",
            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
            data: {
              currentTypeName: typeToCheck.currentType.name,
              expectedTypeName: typeToCheck.expectedTypeName
            },

            fix(fixer) {
              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);
            }

          });
        }
      });
    }

    function checkJSDoc(node) {
      const jsdocNode = sourceCode.getJSDocComment(node),
            functionData = fns.pop(),
            paramTagsByName = Object.create(null),
            paramTags = [];
      let hasReturns = false,
          returnsTag,
          hasConstructor = false,
          isInterface = false,
          isOverride = false,
          isAbstract = false;

      if (jsdocNode) {
        let jsdoc;

        try {
          jsdoc = doctrine__default['default'].parse(jsdocNode.value, {
            strict: true,
            unwrap: true,
            sloppy: true,
            range: true
          });
        } catch (ex) {
          if (/braces/iu.test(ex.message)) {
            context.report({
              node: jsdocNode,
              messageId: "missingBrace"
            });
          } else {
            context.report({
              node: jsdocNode,
              messageId: "syntaxError"
            });
          }

          return;
        }

        jsdoc.tags.forEach(tag => {
          switch (tag.title.toLowerCase()) {
            case "param":
            case "arg":
            case "argument":
              paramTags.push(tag);
              break;

            case "return":
            case "returns":
              hasReturns = true;
              returnsTag = tag;
              break;

            case "constructor":
            case "class":
              hasConstructor = true;
              break;

            case "override":
            case "inheritdoc":
              isOverride = true;
              break;

            case "abstract":
            case "virtual":
              isAbstract = true;
              break;

            case "interface":
              isInterface = true;
              break;
          }

          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
            const entireTagRange = getAbsoluteRange(jsdocNode, tag);
            context.report({
              node: jsdocNode,
              messageId: "use",
              loc: {
                start: entireTagRange.start,
                end: {
                  line: entireTagRange.start.line,
                  column: entireTagRange.start.column + `@${tag.title}`.length
                }
              },
              data: {
                name: prefer[tag.title]
              },

              fix(fixer) {
                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);
              }

            });
          }

          if (checkPreferType && tag.type) {
            validateType(jsdocNode, tag.type);
          }
        });
        paramTags.forEach(param => {
          if (requireParamType && !param.type) {
            context.report({
              node: jsdocNode,
              messageId: "missingParamType",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          }

          if (!param.description && requireParamDescription) {
            context.report({
              node: jsdocNode,
              messageId: "missingParamDesc",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          }

          if (paramTagsByName[param.name]) {
            context.report({
              node: jsdocNode,
              messageId: "duplicateParam",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          } else if (param.name.indexOf(".") === -1) {
            paramTagsByName[param.name] = param;
          }
        });

        if (hasReturns) {
          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
            context.report({
              node: jsdocNode,
              messageId: "unexpectedTag",
              loc: getAbsoluteRange(jsdocNode, returnsTag),
              data: {
                title: returnsTag.title
              }
            });
          } else {
            if (requireReturnType && !returnsTag.type) {
              context.report({
                node: jsdocNode,
                messageId: "missingReturnType"
              });
            }

            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
              context.report({
                node: jsdocNode,
                messageId: "missingReturnDesc"
              });
            }
          }
        }

        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
          if (requireReturn || functionData.returnPresent && !node.async) {
            context.report({
              node: jsdocNode,
              messageId: "missingReturn",
              data: {
                returns: prefer.returns || "returns"
              }
            });
          }
        }

        const jsdocParamNames = Object.keys(paramTagsByName);

        if (node.params) {
          node.params.forEach((param, paramsIndex) => {
            const bindingParam = param.type === "AssignmentPattern" ? param.left : param;

            if (bindingParam.type === "Identifier") {
              const name = bindingParam.name;

              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {
                context.report({
                  node: jsdocNode,
                  messageId: "expected",
                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                  data: {
                    name,
                    jsdocName: jsdocParamNames[paramsIndex]
                  }
                });
              } else if (!paramTagsByName[name] && !isOverride) {
                context.report({
                  node: jsdocNode,
                  messageId: "missingParam",
                  data: {
                    name
                  }
                });
              }
            }
          });
        }

        if (options.matchDescription) {
          const regex = new RegExp(options.matchDescription, "u");

          if (!regex.test(jsdoc.description)) {
            context.report({
              node: jsdocNode,
              messageId: "unsatisfiedDesc"
            });
          }
        }
      }
    }

    return {
      ArrowFunctionExpression: startFunction,
      FunctionExpression: startFunction,
      FunctionDeclaration: startFunction,
      ClassExpression: startFunction,
      ClassDeclaration: startFunction,
      "ArrowFunctionExpression:exit": checkJSDoc,
      "FunctionExpression:exit": checkJSDoc,
      "FunctionDeclaration:exit": checkJSDoc,
      "ClassExpression:exit": checkJSDoc,
      "ClassDeclaration:exit": checkJSDoc,
      ReturnStatement: function (node) {
        const functionState = fns[fns.length - 1];

        if (functionState && node.argument !== null) {
          functionState.returnPresent = true;
        }
      }
    };
  }

};
var validTypeof = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce comparing `typeof` expressions against valid strings",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/valid-typeof"
    },
    schema: [{
      type: "object",
      properties: {
        requireStringLiterals: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      invalidValue: "Invalid typeof comparison value.",
      notString: "Typeof comparisons should be to string literals."
    }
  },

  create(context) {
    const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"],
          OPERATORS = ["==", "===", "!=", "!=="];
    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;

    function isTypeofExpression(node) {
      return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    return {
      UnaryExpression(node) {
        if (isTypeofExpression(node)) {
          const parent = context.getAncestors().pop();

          if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
            const sibling = parent.left === node ? parent.right : parent.left;

            if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
              const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;

              if (VALID_TYPES.indexOf(value) === -1) {
                context.report({
                  node: sibling,
                  messageId: "invalidValue"
                });
              }
            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
              context.report({
                node: sibling,
                messageId: "notString"
              });
            }
          }
        }
      }

    };
  }

};
var varsOnTop = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `var` declarations be placed at the top of their containing scope",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/vars-on-top"
    },
    schema: [],
    messages: {
      top: "All 'var' declarations must be at the top of the function scope."
    }
  },

  create(context) {
    function looksLikeDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function looksLikeImport(node) {
      return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
    }

    function isVariableDeclaration(node) {
      return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
    }

    function isVarOnTop(node, statements) {
      const l = statements.length;
      let i = 0;

      for (; i < l; ++i) {
        if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
          break;
        }
      }

      for (; i < l; ++i) {
        if (!isVariableDeclaration(statements[i])) {
          return false;
        }

        if (statements[i] === node) {
          return true;
        }
      }

      return false;
    }

    function globalVarCheck(node, parent) {
      if (!isVarOnTop(node, parent.body)) {
        context.report({
          node,
          messageId: "top"
        });
      }
    }

    function blockScopeVarCheck(node, parent, grandParent) {
      if (!(/Function/u.test(grandParent.type) && parent.type === "BlockStatement" && isVarOnTop(node, parent.body))) {
        context.report({
          node,
          messageId: "top"
        });
      }
    }

    return {
      "VariableDeclaration[kind='var']"(node) {
        if (node.parent.type === "ExportNamedDeclaration") {
          globalVarCheck(node.parent, node.parent.parent);
        } else if (node.parent.type === "Program") {
          globalVarCheck(node, node.parent);
        } else {
          blockScopeVarCheck(node, node.parent, node.parent.parent);
        }
      }

    };
  }

};

function isCalleeOfNewExpression(node) {
  const maybeCallee = node.parent.type === "ChainExpression" ? node.parent : node;
  return maybeCallee.parent.type === "NewExpression" && maybeCallee.parent.callee === maybeCallee;
}

var wrapIife = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around immediate `function` invocations",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/wrap-iife"
    },
    schema: [{
      enum: ["outside", "inside", "any"]
    }, {
      type: "object",
      properties: {
        functionPrototypeMethods: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      wrapInvocation: "Wrap an immediate function invocation in parentheses.",
      wrapExpression: "Wrap only the function expression in parens.",
      moveInvocation: "Move the invocation into the parens that contain the function."
    }
  },

  create(context) {
    const style = context.options[0] || "outside";
    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;
    const sourceCode = context.getSourceCode();

    function isWrappedInAnyParens(node) {
      return astUtils.isParenthesised(sourceCode, node);
    }

    function isWrappedInGroupingParens(node) {
      return eslintUtils__default['default'].isParenthesized(1, node, sourceCode);
    }

    function getFunctionNodeFromIIFE(node) {
      const callee = astUtils.skipChainExpression(node.callee);

      if (callee.type === "FunctionExpression") {
        return callee;
      }

      if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
        return callee.object;
      }

      return null;
    }

    return {
      CallExpression(node) {
        const innerNode = getFunctionNodeFromIIFE(node);

        if (!innerNode) {
          return;
        }

        const isCallExpressionWrapped = isWrappedInAnyParens(node),
              isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);

        if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {
          context.report({
            node,
            messageId: "wrapInvocation",

            fix(fixer) {
              const nodeToSurround = style === "inside" ? innerNode : node;
              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
            }

          });
        } else if (style === "inside" && !isFunctionExpressionWrapped) {
          context.report({
            node,
            messageId: "wrapExpression",

            fix(fixer) {
              if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {
                const parenAfter = sourceCode.getTokenAfter(node);
                return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);
              }

              return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);
            }

          });
        } else if (style === "outside" && !isCallExpressionWrapped) {
          context.report({
            node,
            messageId: "moveInvocation",

            fix(fixer) {
              const parenAfter = sourceCode.getTokenAfter(innerNode);
              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);
            }

          });
        }
      }

    };
  }

};
var wrapRegex = {
  meta: {
    type: "layout",
    docs: {
      description: "require parenthesis around regex literals",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/wrap-regex"
    },
    schema: [],
    fixable: "code",
    messages: {
      requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node),
              nodeType = token.type;

        if (nodeType === "RegularExpression") {
          const beforeToken = sourceCode.getTokenBefore(node);
          const afterToken = sourceCode.getTokenAfter(node);
          const ancestors = context.getAncestors();
          const grandparent = ancestors[ancestors.length - 1];

          if (grandparent.type === "MemberExpression" && grandparent.object === node && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) {
            context.report({
              node,
              messageId: "requireParens",
              fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
            });
          }
        }
      }

    };
  }

};
var yieldStarSpacing = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around the `*` in `yield*` expressions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/yield-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();

    const mode = function (option) {
      if (!option || typeof option === "string") {
        return {
          before: {
            before: true,
            after: false
          },
          after: {
            before: false,
            after: true
          },
          both: {
            before: true,
            after: true
          },
          neither: {
            before: false,
            after: false
          }
        }[option || "after"];
      }

      return option;
    }(context.options[0]);

    function checkSpacing(side, leftToken, rightToken) {
      if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
        const after = leftToken.value === "*";
        const spaceRequired = mode[side];
        const node = after ? leftToken : rightToken;
        let messageId = "";

        if (spaceRequired) {
          messageId = side === "before" ? "missingBefore" : "missingAfter";
        } else {
          messageId = side === "before" ? "unexpectedBefore" : "unexpectedAfter";
        }

        context.report({
          node,
          messageId,

          fix(fixer) {
            if (spaceRequired) {
              if (after) {
                return fixer.insertTextAfter(node, " ");
              }

              return fixer.insertTextBefore(node, " ");
            }

            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }

        });
      }
    }

    return {
      YieldExpression: function (node) {
        if (!node.delegate) {
          return;
        }

        const tokens = sourceCode.getFirstTokens(node, 3);
        const yieldToken = tokens[0];
        const starToken = tokens[1];
        const nextToken = tokens[2];
        checkSpacing("before", yieldToken, starToken);
        checkSpacing("after", starToken, nextToken);
      }
    };
  }

};

function isComparisonOperator(operator) {
  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);
}

function isEqualityOperator(operator) {
  return /^(==|===)$/u.test(operator);
}

function isRangeTestOperator(operator) {
  return ["<", "<="].indexOf(operator) >= 0;
}

function isNegativeNumericLiteral(node) {
  return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && astUtils.isNumericLiteral(node.argument);
}

function isStaticTemplateLiteral(node) {
  return node.type === "TemplateLiteral" && node.expressions.length === 0;
}

function looksLikeLiteral(node) {
  return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);
}

function getNormalizedLiteral(node) {
  if (node.type === "Literal") {
    return node;
  }

  if (isNegativeNumericLiteral(node)) {
    return {
      type: "Literal",
      value: -node.argument.value,
      raw: `-${node.argument.value}`
    };
  }

  if (isStaticTemplateLiteral(node)) {
    return {
      type: "Literal",
      value: node.quasis[0].value.cooked,
      raw: node.quasis[0].value.raw
    };
  }

  return null;
}

var yoda = {
  meta: {
    type: "suggestion",
    docs: {
      description: 'require or disallow "Yoda" conditions',
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/yoda"
    },
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptRange: {
          type: "boolean",
          default: false
        },
        onlyEquality: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
    }
  },

  create(context) {
    const always = context.options[0] === "always";
    const exceptRange = context.options[1] && context.options[1].exceptRange;
    const onlyEquality = context.options[1] && context.options[1].onlyEquality;
    const sourceCode = context.getSourceCode();

    function isRangeTest(node) {
      const left = node.left,
            right = node.right;
      return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (function () {
        if (node.operator === "&&" && astUtils.isSameReference(left.right, right.left)) {
          const leftLiteral = getNormalizedLiteral(left.left);
          const rightLiteral = getNormalizedLiteral(right.right);

          if (leftLiteral === null && rightLiteral === null) {
            return false;
          }

          if (rightLiteral === null || leftLiteral === null) {
            return true;
          }

          if (leftLiteral.value <= rightLiteral.value) {
            return true;
          }
        }

        return false;
      }() || function () {
        if (node.operator === "||" && astUtils.isSameReference(left.left, right.right)) {
          const leftLiteral = getNormalizedLiteral(left.right);
          const rightLiteral = getNormalizedLiteral(right.left);

          if (leftLiteral === null && rightLiteral === null) {
            return false;
          }

          if (rightLiteral === null || leftLiteral === null) {
            return true;
          }

          if (leftLiteral.value <= rightLiteral.value) {
            return true;
          }
        }

        return false;
      }()) && function () {
        return astUtils.isParenthesised(sourceCode, node);
      }();
    }

    const OPERATOR_FLIP_MAP = {
      "===": "===",
      "!==": "!==",
      "==": "==",
      "!=": "!=",
      "<": ">",
      ">": "<",
      "<=": ">=",
      ">=": "<="
    };

    function getFlippedString(node) {
      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);
      const firstRightToken = sourceCode.getTokenAfter(operatorToken);
      const source = sourceCode.getText();
      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);
      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);
      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);
      const rightText = source.slice(firstRightToken.range[0], node.range[1]);
      const tokenBefore = sourceCode.getTokenBefore(node);
      const tokenAfter = sourceCode.getTokenAfter(node);
      let prefix = "";
      let suffix = "";

      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {
        prefix = " ";
      }

      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {
        suffix = " ";
      }

      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;
    }

    return {
      BinaryExpression(node) {
        const expectedLiteral = always ? node.left : node.right;
        const expectedNonLiteral = always ? node.right : node.left;

        if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {
          context.report({
            node,
            messageId: "expected",
            data: {
              operator: node.operator,
              expectedSide: always ? "left" : "right"
            },
            fix: fixer => fixer.replaceText(node, getFlippedString(node))
          });
        }
      }

    };
  }

};
var coreRules = {
  "accessor-pairs": accessorPairs,
  "array-bracket-newline": arrayBracketNewline,
  "array-bracket-spacing": arrayBracketSpacing,
  "array-callback-return": arrayCallbackReturn,
  "array-element-newline": arrayElementNewline,
  "arrow-body-style": arrowBodyStyle,
  "arrow-parens": arrowParens,
  "arrow-spacing": arrowSpacing,
  "block-scoped-var": blockScopedVar,
  "block-spacing": blockSpacing,
  "brace-style": braceStyle,
  "callback-return": callbackReturn,
  "camelcase": camelcase,
  "capitalized-comments": capitalizedComments,
  "class-methods-use-this": classMethodsUseThis,
  "comma-dangle": commaDangle,
  "comma-spacing": commaSpacing,
  "comma-style": commaStyle,
  "complexity": complexity,
  "computed-property-spacing": computedPropertySpacing,
  "consistent-return": consistentReturn,
  "consistent-this": consistentThis,
  "constructor-super": constructorSuper,
  "curly": curly,
  "default-case-last": defaultCaseLast,
  "default-case": defaultCase,
  "default-param-last": defaultParamLast,
  "dot-location": dotLocation,
  "dot-notation": dotNotation,
  "eol-last": eolLast,
  "eqeqeq": eqeqeq,
  "for-direction": forDirection,
  "func-call-spacing": funcCallSpacing,
  "func-name-matching": funcNameMatching,
  "func-names": funcNames,
  "func-style": funcStyle,
  "function-call-argument-newline": functionCallArgumentNewline,
  "function-paren-newline": functionParenNewline,
  "generator-star-spacing": generatorStarSpacing,
  "getter-return": getterReturn,
  "global-require": globalRequire,
  "grouped-accessor-pairs": groupedAccessorPairs,
  "guard-for-in": guardForIn,
  "handle-callback-err": handleCallbackErr,
  "id-blacklist": idBlacklist,
  "id-denylist": idDenylist,
  "id-length": idLength,
  "id-match": idMatch,
  "implicit-arrow-linebreak": implicitArrowLinebreak,
  "indent-legacy": indentLegacy,
  "indent": indent,
  "init-declarations": initDeclarations,
  "jsx-quotes": jsxQuotes,
  "key-spacing": keySpacing,
  "keyword-spacing": keywordSpacing,
  "line-comment-position": lineCommentPosition,
  "linebreak-style": linebreakStyle,
  "lines-around-comment": linesAroundComment,
  "lines-around-directive": linesAroundDirective,
  "lines-between-class-members": linesBetweenClassMembers,
  "max-classes-per-file": maxClassesPerFile,
  "max-depth": maxDepth,
  "max-len": maxLen,
  "max-lines-per-function": maxLinesPerFunction,
  "max-lines": maxLines,
  "max-nested-callbacks": maxNestedCallbacks,
  "max-params": maxParams,
  "max-statements-per-line": maxStatementsPerLine,
  "max-statements": maxStatements,
  "multiline-comment-style": multilineCommentStyle,
  "multiline-ternary": multilineTernary,
  "new-cap": newCap,
  "new-parens": newParens,
  "newline-after-var": newlineAfterVar,
  "newline-before-return": newlineBeforeReturn,
  "newline-per-chained-call": newlinePerChainedCall,
  "no-alert": noAlert,
  "no-array-constructor": noArrayConstructor,
  "no-async-promise-executor": noAsyncPromiseExecutor,
  "no-await-in-loop": noAwaitInLoop,
  "no-bitwise": noBitwise,
  "no-buffer-constructor": noBufferConstructor,
  "no-caller": noCaller,
  "no-case-declarations": noCaseDeclarations,
  "no-catch-shadow": noCatchShadow,
  "no-class-assign": noClassAssign,
  "no-compare-neg-zero": noCompareNegZero,
  "no-cond-assign": noCondAssign,
  "no-confusing-arrow": noConfusingArrow,
  "no-console": noConsole,
  "no-const-assign": noConstAssign,
  "no-constant-condition": noConstantCondition,
  "no-constructor-return": noConstructorReturn,
  "no-continue": noContinue,
  "no-control-regex": noControlRegex,
  "no-debugger": noDebugger,
  "no-delete-var": noDeleteVar,
  "no-div-regex": noDivRegex,
  "no-dupe-args": noDupeArgs,
  "no-dupe-class-members": noDupeClassMembers,
  "no-dupe-else-if": noDupeElseIf,
  "no-dupe-keys": noDupeKeys,
  "no-duplicate-case": noDuplicateCase,
  "no-duplicate-imports": noDuplicateImports,
  "no-else-return": noElseReturn,
  "no-empty-character-class": noEmptyCharacterClass,
  "no-empty-function": noEmptyFunction,
  "no-empty-pattern": noEmptyPattern,
  "no-empty": noEmpty,
  "no-eq-null": noEqNull,
  "no-eval": noEval,
  "no-ex-assign": noExAssign,
  "no-extend-native": noExtendNative,
  "no-extra-bind": noExtraBind,
  "no-extra-boolean-cast": noExtraBooleanCast,
  "no-extra-label": noExtraLabel,
  "no-extra-parens": noExtraParens,
  "no-extra-semi": noExtraSemi,
  "no-fallthrough": noFallthrough,
  "no-floating-decimal": noFloatingDecimal,
  "no-func-assign": noFuncAssign,
  "no-global-assign": noGlobalAssign,
  "no-implicit-coercion": noImplicitCoercion,
  "no-implicit-globals": noImplicitGlobals,
  "no-implied-eval": noImpliedEval,
  "no-import-assign": noImportAssign,
  "no-inline-comments": noInlineComments,
  "no-inner-declarations": noInnerDeclarations,
  "no-invalid-regexp": noInvalidRegexp,
  "no-invalid-this": noInvalidThis,
  "no-irregular-whitespace": noIrregularWhitespace,
  "no-iterator": noIterator,
  "no-label-var": noLabelVar,
  "no-labels": noLabels,
  "no-lone-blocks": noLoneBlocks,
  "no-lonely-if": noLonelyIf,
  "no-loop-func": noLoopFunc,
  "no-loss-of-precision": noLossOfPrecision,
  "no-magic-numbers": noMagicNumbers,
  "no-misleading-character-class": noMisleadingCharacterClass,
  "no-mixed-operators": noMixedOperators,
  "no-mixed-requires": noMixedRequires,
  "no-mixed-spaces-and-tabs": noMixedSpacesAndTabs,
  "no-multi-assign": noMultiAssign,
  "no-multi-spaces": noMultiSpaces,
  "no-multi-str": noMultiStr,
  "no-multiple-empty-lines": noMultipleEmptyLines,
  "no-native-reassign": noNativeReassign,
  "no-negated-condition": noNegatedCondition,
  "no-negated-in-lhs": noNegatedInLhs,
  "no-nested-ternary": noNestedTernary,
  "no-new-func": noNewFunc,
  "no-new-object": noNewObject,
  "no-new-require": noNewRequire,
  "no-new-symbol": noNewSymbol,
  "no-new-wrappers": noNewWrappers,
  "no-new": noNew,
  "no-nonoctal-decimal-escape": noNonoctalDecimalEscape,
  "no-obj-calls": noObjCalls,
  "no-octal-escape": noOctalEscape,
  "no-octal": noOctal,
  "no-param-reassign": noParamReassign,
  "no-path-concat": noPathConcat,
  "no-plusplus": noPlusplus,
  "no-process-env": noProcessEnv,
  "no-process-exit": noProcessExit,
  "no-promise-executor-return": noPromiseExecutorReturn,
  "no-proto": noProto,
  "no-prototype-builtins": noPrototypeBuiltins,
  "no-redeclare": noRedeclare,
  "no-regex-spaces": noRegexSpaces,
  "no-restricted-exports": noRestrictedExports,
  "no-restricted-globals": noRestrictedGlobals,
  "no-restricted-imports": noRestrictedImports,
  "no-restricted-modules": noRestrictedModules,
  "no-restricted-properties": noRestrictedProperties,
  "no-restricted-syntax": noRestrictedSyntax,
  "no-return-assign": noReturnAssign,
  "no-return-await": noReturnAwait,
  "no-script-url": noScriptUrl,
  "no-self-assign": noSelfAssign,
  "no-self-compare": noSelfCompare,
  "no-sequences": noSequences,
  "no-setter-return": noSetterReturn,
  "no-shadow-restricted-names": noShadowRestrictedNames,
  "no-shadow": noShadow,
  "no-spaced-func": noSpacedFunc,
  "no-sparse-arrays": noSparseArrays,
  "no-sync": noSync,
  "no-tabs": noTabs,
  "no-template-curly-in-string": noTemplateCurlyInString,
  "no-ternary": noTernary,
  "no-this-before-super": noThisBeforeSuper,
  "no-throw-literal": noThrowLiteral,
  "no-trailing-spaces": noTrailingSpaces,
  "no-undef-init": noUndefInit,
  "no-undef": noUndef,
  "no-undefined": noUndefined,
  "no-underscore-dangle": noUnderscoreDangle,
  "no-unexpected-multiline": noUnexpectedMultiline,
  "no-unmodified-loop-condition": noUnmodifiedLoopCondition,
  "no-unneeded-ternary": noUnneededTernary,
  "no-unreachable-loop": noUnreachableLoop,
  "no-unreachable": noUnreachable,
  "no-unsafe-finally": noUnsafeFinally,
  "no-unsafe-negation": noUnsafeNegation,
  "no-unsafe-optional-chaining": noUnsafeOptionalChaining,
  "no-unused-expressions": noUnusedExpressions,
  "no-unused-labels": noUnusedLabels,
  "no-unused-vars": noUnusedVars,
  "no-use-before-define": noUseBeforeDefine,
  "no-useless-backreference": noUselessBackreference,
  "no-useless-call": noUselessCall,
  "no-useless-catch": noUselessCatch,
  "no-useless-computed-key": noUselessComputedKey,
  "no-useless-concat": noUselessConcat,
  "no-useless-constructor": noUselessConstructor,
  "no-useless-escape": noUselessEscape,
  "no-useless-rename": noUselessRename,
  "no-useless-return": noUselessReturn,
  "no-var": noVar,
  "no-void": noVoid,
  "no-warning-comments": noWarningComments,
  "no-whitespace-before-property": noWhitespaceBeforeProperty,
  "no-with": noWith,
  "nonblock-statement-body-position": nonblockStatementBodyPosition,
  "object-curly-newline": objectCurlyNewline,
  "object-curly-spacing": objectCurlySpacing,
  "object-property-newline": objectPropertyNewline,
  "object-shorthand": objectShorthand,
  "one-var-declaration-per-line": oneVarDeclarationPerLine,
  "one-var": oneVar,
  "operator-assignment": operatorAssignment,
  "operator-linebreak": operatorLinebreak,
  "padded-blocks": paddedBlocks,
  "padding-line-between-statements": paddingLineBetweenStatements,
  "prefer-arrow-callback": preferArrowCallback,
  "prefer-const": preferConst,
  "prefer-destructuring": preferDestructuring,
  "prefer-exponentiation-operator": preferExponentiationOperator,
  "prefer-named-capture-group": preferNamedCaptureGroup,
  "prefer-numeric-literals": preferNumericLiterals,
  "prefer-object-spread": preferObjectSpread,
  "prefer-promise-reject-errors": preferPromiseRejectErrors,
  "prefer-reflect": preferReflect,
  "prefer-regex-literals": preferRegexLiterals,
  "prefer-rest-params": preferRestParams,
  "prefer-spread": preferSpread,
  "prefer-template": preferTemplate,
  "quote-props": quoteProps,
  "quotes": quotes,
  "radix": radix,
  "require-atomic-updates": requireAtomicUpdates,
  "require-await": requireAwait,
  "require-jsdoc": requireJsdoc,
  "require-unicode-regexp": requireUnicodeRegexp,
  "require-yield": requireYield,
  "rest-spread-spacing": restSpreadSpacing,
  "semi-spacing": semiSpacing,
  "semi-style": semiStyle,
  "semi": semi,
  "sort-imports": sortImports,
  "sort-keys": sortKeys,
  "sort-vars": sortVars,
  "space-before-blocks": spaceBeforeBlocks,
  "space-before-function-paren": spaceBeforeFunctionParen,
  "space-in-parens": spaceInParens,
  "space-infix-ops": spaceInfixOps,
  "space-unary-ops": spaceUnaryOps,
  "spaced-comment": spacedComment,
  "strict": strict,
  "switch-colon-spacing": switchColonSpacing,
  "symbol-description": symbolDescription,
  "template-curly-spacing": templateCurlySpacing,
  "template-tag-spacing": templateTagSpacing,
  "unicode-bom": unicodeBom,
  "use-isnan": useIsnan,
  "valid-jsdoc": validJsdoc,
  "valid-typeof": validTypeof,
  "vars-on-top": varsOnTop,
  "wrap-iife": wrapIife,
  "wrap-regex": wrapRegex,
  "yield-star-spacing": yieldStarSpacing,
  "yoda": yoda
};
module.exports = coreRules;
//# sourceMappingURL=core-rules.js.map