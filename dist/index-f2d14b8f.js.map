{"version":3,"sources":["node_modules/eslint/lib/source-code/token-store/cursor.js","node_modules/eslint/lib/source-code/token-store/utils.js","node_modules/eslint/lib/source-code/token-store/backward-token-comment-cursor.js","node_modules/eslint/lib/source-code/token-store/backward-token-cursor.js","node_modules/eslint/lib/source-code/token-store/decorative-cursor.js","node_modules/eslint/lib/source-code/token-store/filter-cursor.js","node_modules/eslint/lib/source-code/token-store/forward-token-comment-cursor.js","node_modules/eslint/lib/source-code/token-store/forward-token-cursor.js","node_modules/eslint/lib/source-code/token-store/limit-cursor.js","node_modules/eslint/lib/source-code/token-store/skip-cursor.js","node_modules/eslint/lib/source-code/token-store/cursors.js","node_modules/eslint/lib/source-code/token-store/padded-token-cursor.js","node_modules/eslint/lib/source-code/token-store/index.js","node_modules/eslint/lib/source-code/source-code.js","node_modules/eslint/lib/source-code/index.js","node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js","node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js","node_modules/eslint/lib/linter/code-path-analysis/fork-context.js","node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js","node_modules/eslint/lib/linter/code-path-analysis/id-generator.js","node_modules/eslint/lib/linter/code-path-analysis/code-path.js","node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js","node_modules/eslint/lib/linter/apply-disable-directives.js","node_modules/eslint/lib/linter/config-comment-parser.js","node_modules/eslint/lib/linter/node-event-generator.js","node_modules/eslint/lib/linter/rule-fixer.js","node_modules/eslint/lib/linter/interpolate.js","node_modules/eslint/lib/linter/report-translator.js","scripts/shim/rules-index.js","node_modules/eslint/lib/linter/rules.js","node_modules/eslint/lib/linter/safe-emitter.js","node_modules/eslint/lib/linter/source-code-fixer.js","node_modules/eslint/lib/linter/timing.js","node_modules/eslint/lib/linter/linter.js","node_modules/eslint/lib/linter/index.js"],"names":["lodash","isCommentToken","require$$0","assert","Traverser","astUtils","debug","CodePathSegment","ForkContext","forkContext","codePath","CodePath","levn","ConfigOps","esquery","builtInRules","require$$1","eslintScope","ConfigValidator","Rules","path","evk","createEmitter","reportTranslator","createReportTranslator","BuiltInEnvironments","espree","SourceCodeFixer"],"mappings":"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","sourcesContent":["/**\n * @fileoverview Define the abstract class about cursors which iterate tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which iterate tokens.\n *\n * This class has 2 abstract methods.\n *\n * - `current: Token | Comment | null` ... The current token.\n * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.\n *\n * This is similar to ES2015 Iterators.\n * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.\n *\n * There are the following known sub classes.\n *\n * - ForwardTokenCursor .......... The cursor which iterates tokens only.\n * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.\n * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.\n * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.\n * - DecorativeCursor\n *     - FilterCursor ............ The cursor which ignores the specified tokens.\n *     - SkipCursor .............. The cursor which ignores the first few tokens.\n *     - LimitCursor ............. The cursor which limits the count of tokens.\n *\n */\nmodule.exports = class Cursor {\n\n    /**\n     * Initializes this cursor.\n     */\n    constructor() {\n        this.current = null;\n    }\n\n    /**\n     * Gets the first token.\n     * This consumes this cursor.\n     * @returns {Token|Comment} The first token or null.\n     */\n    getOneToken() {\n        return this.moveNext() ? this.current : null;\n    }\n\n    /**\n     * Gets the first tokens.\n     * This consumes this cursor.\n     * @returns {(Token|Comment)[]} All tokens.\n     */\n    getAllTokens() {\n        const tokens = [];\n\n        while (this.moveNext()) {\n            tokens.push(this.current);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Moves this cursor to the next token.\n     * @returns {boolean} `true` if the next token exists.\n     * @abstract\n     */\n    /* istanbul ignore next */\n    moveNext() { // eslint-disable-line class-methods-use-this\n        throw new Error(\"Not implemented.\");\n    }\n};\n","/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n * @param {Node|Token|Comment} token The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    return lodash.sortedIndexBy(\n        tokens,\n        { range: [location] },\n        getStartLocation\n    );\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens and comments in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments in reverse.\n */\nmodule.exports = class BackwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.commentIndex = utils.search(comments, endLoc) - 1;\n        this.border = startLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex >= 0) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex >= 0) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[1] > comment.range[1])) {\n            this.current = token;\n            this.tokenIndex -= 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex -= 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens only in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only in reverse.\n */\nmodule.exports = class BackwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index >= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index -= 1;\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     *\n     * Shorthand for performance.\n     *\n     */\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index >= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n};\n","/**\n * @fileoverview Define the abstract class about cursors which manipulate another cursor.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which manipulate another cursor.\n */\nmodule.exports = class DecorativeCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor The cursor to be decorated.\n     */\n    constructor(cursor) {\n        super();\n        this.cursor = cursor;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const retv = this.cursor.moveNext();\n\n        this.current = this.cursor.current;\n\n        return retv;\n    }\n};\n","/**\n * @fileoverview Define the cursor which ignores specified tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores specified tokens.\n */\nmodule.exports = class FilterCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor The cursor to be decorated.\n     * @param {Function} predicate The predicate function to decide tokens this cursor iterates.\n     */\n    constructor(cursor, predicate) {\n        super(cursor);\n        this.predicate = predicate;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const predicate = this.predicate;\n\n        while (super.moveNext()) {\n            if (predicate(this.current)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens and comments.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments.\n */\nmodule.exports = class ForwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.commentIndex = utils.search(comments, startLoc);\n        this.border = endLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex < this.tokens.length) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex < this.comments.length) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[0] < comment.range[0])) {\n            this.current = token;\n            this.tokenIndex += 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex += 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens only.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only.\n */\nmodule.exports = class ForwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index <= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index += 1;\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     *\n     * Shorthand for performance.\n     *\n     */\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index <= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n\n    /** @inheritdoc */\n    getAllTokens() {\n        return this.tokens.slice(this.index, this.indexEnd + 1);\n    }\n};\n","/**\n * @fileoverview Define the cursor which limits the number of tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which limits the number of tokens.\n */\nmodule.exports = class LimitCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor The cursor to be decorated.\n     * @param {number} count The count of tokens this cursor iterates.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.count > 0) {\n            this.count -= 1;\n            return super.moveNext();\n        }\n        return false;\n    }\n};\n","/**\n * @fileoverview Define the cursor which ignores the first few tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores the first few tokens.\n */\nmodule.exports = class SkipCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor The cursor to be decorated.\n     * @param {number} count The count of tokens this cursor skips.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        while (this.count > 0) {\n            this.count -= 1;\n            if (!super.moveNext()) {\n                return false;\n            }\n        }\n        return super.moveNext();\n    }\n};\n","/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {boolean} includeComments The flag to iterate comments as well.\n     * @param {Function|null} filter The predicate function to choose tokens.\n     * @param {number} skip The count of tokens the cursor skips.\n     * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n","/**\n * @fileoverview Define the cursor which iterates tokens only, with inflated range.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only, with inflated range.\n * This is for the backward compatibility of padding options.\n */\nmodule.exports = class PaddedTokenCursor extends ForwardTokenCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     * @param {Object} indexMap The map from locations to indices in `tokens`.\n     * @param {number} startLoc The start location of the iteration range.\n     * @param {number} endLoc The end location of the iteration range.\n     * @param {number} beforeCount The number of tokens this cursor iterates before start.\n     * @param {number} afterCount The number of tokens this cursor iterates after end.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n        super(tokens, comments, indexMap, startLoc, endLoc);\n        this.index = Math.max(0, this.index - beforeCount);\n        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);\n    }\n};\n","/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst { isCommentToken } = require(\"eslint-utils\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n    const tokens = [];\n    let currentToken = cursor.getOneToken();\n\n    while (currentToken && isCommentToken(currentToken)) {\n        tokens.push(currentToken);\n        currentToken = cursor.getOneToken();\n    }\n\n    return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     */\n    constructor(tokens, comments) {\n        this[TOKENS] = tokens;\n        this[COMMENTS] = comments;\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset Index of the start of the token's range.\n     * @param {Object} [options=0] The option object.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.skip=0] The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n\n    //--------------------------------------------------------------------------\n    // Others.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     * @param {ASTNode} left The node to check.\n     * @param {ASTNode} right The node to check.\n     * @returns {boolean} `true` if one or more comments exist.\n     */\n    commentsExistBetween(left, right) {\n        const index = utils.search(this[COMMENTS], left.range[1]);\n\n        return (\n            index < this[COMMENTS].length &&\n            this[COMMENTS][index].range[1] <= right.range[0]\n        );\n    }\n\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            nodeOrToken.range[0],\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\n    }\n\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            nodeOrToken.range[1],\n            -1,\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor);\n    }\n\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsInside(node) {\n        return this.getTokens(node, {\n            includeComments: true,\n            filter: isCommentToken\n        });\n    }\n};\n","/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    Traverser = require(\"../shared/traverser\"),\n    lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check spaces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n\n    /**\n     * Represents parsed source code.\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type boolean\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type string\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type ASTNode\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type string[]\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n         * be inserted into lineIndices to keep the list sorted.\n         */\n        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n}\n\nmodule.exports = SourceCode;\n","\"use strict\";\n\nmodule.exports = {\n    SourceCode: require(\"./source-code\")\n};\n","/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line jsdoc/require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n/**\n * Get string for the given node and operation.\n * @param {ASTNode} node The node to convert.\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\n * @returns {string} The string representation.\n */\nfunction nodeToString(node, label) {\n    const suffix = label ? `:${label}` : \"\";\n\n    switch (node.type) {\n        case \"Identifier\": return `${node.type}${suffix} (${node.name})`;\n        case \"Literal\": return `${node.type}${suffix} (${node.value})`;\n        default: return `${node.type}${suffix}`;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     * @param {...any} args objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     * @param {ASTNode} node A node to dump.\n     * @param {CodePathState} state A state to dump.\n     * @param {boolean} leaving A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                const last = segInternal.nodes.length - 1;\n\n                if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n                    segInternal.nodes[last] = nodeToString(node, void 0);\n                } else {\n                    segInternal.nodes.push(nodeToString(node, \"exit\"));\n                }\n            } else {\n                segInternal.nodes.push(nodeToString(node, \"enter\"));\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0) {\n                text += segment.internal.nodes.join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visualized with Graphvis.\n     * @param {CodePath} codePath A code path to make DOT.\n     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n","/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be remove.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Replaces unused segments with the previous segments of each unused segment.\n     * @param {CodePathSegment[]} segments An array of segments to replace.\n     * @returns {CodePathSegment[]} The replaced array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = Object.create(null);\n        const retv = [];\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done[segment.id]) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done[prevSegment.id]) {\n                        done[prevSegment.id] = true;\n                        retv.push(prevSegment);\n                    }\n                }\n            } else {\n                done[segment.id] = true;\n                retv.push(segment);\n            }\n        }\n\n        return retv;\n    }\n}\n\nmodule.exports = CodePathSegment;\n","/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n * @param {ForkContext} context An instance.\n * @param {number} begin The first index of the previous segments.\n * @param {number} end The last index of the previous segments.\n * @param {Function} create A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n    const normalizedEnd = end >= 0 ? end : list.length + end;\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n * @param {ForkContext} context An instance.\n * @param {CodePathSegment[]} segments Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n        currentSegments = merged;\n    }\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper An upper fork context.\n     * @param {number} count A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     * @param {number} begin The first index of previous segments.\n     * @param {number} end The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     * @param {CodePathSegment[]} segments Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} context A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all segments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n","/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state A state to get.\n * @param {string} label The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n * @param {CodePathState} state A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n * @param {any[]} xs An array to remove the specific element.\n * @param {any} x An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n * @param {CodePathState} state The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n        choiceContext.qqForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n        this.chainContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[0];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            qqForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n            case \"??\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                    context.qqForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.qqForkContext.addAll(context.qqForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            let prevForkContext;\n\n            switch (context.kind) {\n                case \"&&\": // if true then go to the right-hand side.\n                    prevForkContext = context.trueForkContext;\n                    break;\n                case \"||\": // if false then go to the right-hand side.\n                    prevForkContext = context.falseForkContext;\n                    break;\n                case \"??\": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n                    prevForkContext = context.qqForkContext;\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            switch (context.kind) {\n                case \"&&\": // the false path can short-circuit.\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                case \"||\": // the true path can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    break;\n                case \"??\": // both can short-circuit.\n                    context.trueForkContext.add(forkContext.head);\n                    context.falseForkContext.add(forkContext.head);\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n            context.qqForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // ChainExpression\n    //--------------------------------------------------------------------------\n\n    /**\n     * Push a new `ChainExpression` context to the stack.\n     * This method is called on entering to each `ChainExpression` node.\n     * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\n     * @returns {void}\n     */\n    pushChainContext() {\n        this.chainContext = {\n            upper: this.chainContext,\n            countChoiceContexts: 0\n        };\n    }\n\n    /**\n     * Pop a `ChainExpression` context from the stack.\n     * This method is called on exiting from each `ChainExpression` node.\n     * This merges all forks of the last optional chaining.\n     * @returns {void}\n     */\n    popChainContext() {\n        const context = this.chainContext;\n\n        this.chainContext = context.upper;\n\n        // pop all choice contexts of this.\n        for (let i = context.countChoiceContexts; i > 0; --i) {\n            this.popChoiceContext();\n        }\n    }\n\n    /**\n     * Create a choice context for optional access.\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n     * @returns {void}\n     */\n    makeOptionalNode() {\n        if (this.chainContext) {\n            this.chainContext.countChoiceContexts += 1;\n            this.pushChoiceContext(\"??\", false);\n        }\n    }\n\n    /**\n     * Create a fork.\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n     * @returns {void}\n     */\n    makeOptionalRight() {\n        if (this.chainContext) {\n            this.makeLogicalRight();\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isEmpty `true` if the body is empty.\n     * @param {boolean} isDefault `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     * @param {boolean} breakable The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string} label A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n","/**\n * @fileoverview A class of identifiers generator for code path segments.\n *\n * Each rule uses the identifier of code path segments to store additional\n * information of the code path.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A generator for unique ids.\n */\nclass IdGenerator {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} prefix Optional. A prefix of generated ids.\n     */\n    constructor(prefix) {\n        this.prefix = String(prefix);\n        this.n = 0;\n    }\n\n    /**\n     * Generates id.\n     * @returns {string} A generated id.\n     */\n    next() {\n        this.n = 1 + this.n | 0;\n\n        /* istanbul ignore if */\n        if (this.n < 0) {\n            this.n = 1;\n        }\n\n        return this.prefix + this.n;\n    }\n}\n\nmodule.exports = IdGenerator;\n","/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} id An identifier.\n     * @param {CodePath|null} upper The code path of the upper function scope.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n    constructor(id, upper, onLooped) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\n        );\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     * @param {CodePath} codePath A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments.\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments which is with `return` statements.\n     * This array contains the last path segment if it's reachable.\n     * Since the reachable last path returns `undefined`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments which is with `throw` statements.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Current code path segments.\n     * @type {CodePathSegment[]}\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments(function(segment, controller) {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` object has two methods.\n     *\n     * - `controller.skip()` - Skip the following segments in this branch.\n     * - `controller.break()` - Skip all following segments.\n     * @param {Object} [options] Omittable.\n     * @param {CodePathSegment} [options.first] The first segment to traverse.\n     * @param {CodePathSegment} [options.last] The last segment to traverse.\n     * @param {Function} callback A callback function.\n     * @returns {void}\n     */\n    traverseSegments(options, callback) {\n        let resolvedOptions;\n        let resolvedCallback;\n\n        if (typeof options === \"function\") {\n            resolvedCallback = options;\n            resolvedOptions = {};\n        } else {\n            resolvedOptions = options || {};\n            resolvedCallback = callback;\n        }\n\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\n        const lastSegment = resolvedOptions.last;\n\n        let item = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n        const visited = Object.create(null);\n        const stack = [[startSegment, 0]];\n        let skippedSegment = null;\n        let broken = false;\n        const controller = {\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited[prevSegment.id] ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        while (stack.length > 0) {\n            item = stack[stack.length - 1];\n            segment = item[0];\n            index = item[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited[segment.id]) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the flag of skipping if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n                    skippedSegment = null;\n                }\n                visited[segment.id] = true;\n\n                // Call the callback when the first time.\n                if (!skippedSegment) {\n                    resolvedCallback.call(this, segment, controller);\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n                item[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n                item[0] = segment.nextSegments[index];\n                item[1] = 0;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;\n","/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\nfunction isLogicalAssignmentOperator(operator) {\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\nfunction getLabel(node) {\n    if (node.parent.type === \"LabeledStatement\") {\n        return node.parent.label.name;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        case \"AssignmentExpression\":\n            return isLogicalAssignmentOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n        case \"CallExpression\":\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n                state.makeOptionalRight();\n            }\n            break;\n        case \"MemberExpression\":\n            if (parent.optional === true && parent.property === node) {\n                state.makeOptionalRight();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (\n                parent.right === node &&\n                isLogicalAssignmentOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"ChainExpression\":\n            state.pushChainContext();\n            break;\n        case \"CallExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n        case \"MemberExpression\":\n            if (node.optional === true) {\n                state.makeOptionalNode();\n            }\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator.slice(0, -1), // removes `=` from the end\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"ChainExpression\":\n            state.popChainContext();\n            break;\n\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"AssignmentExpression\":\n            if (isLogicalAssignmentOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"ImportExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!breakableTypePattern.test(node.body.type)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n        case \"CallExpression\":\n            if (node.optional === true && node.arguments.length === 0) {\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n","/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\"use strict\";\n\nconst lodash = require(\"lodash\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n    return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\n * of filtered problems and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n    const problems = [];\n    let nextDirectiveIndex = 0;\n    let currentGlobalDisableDirective = null;\n    const disabledRuleMap = new Map();\n\n    // enabledRules is only used when there is a current global disable directive.\n    const enabledRules = new Set();\n    const usedDisableDirectives = new Set();\n\n    for (const problem of options.problems) {\n        while (\n            nextDirectiveIndex < options.directives.length &&\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\n        ) {\n            const directive = options.directives[nextDirectiveIndex++];\n\n            switch (directive.type) {\n                case \"disable\":\n                    if (directive.ruleId === null) {\n                        currentGlobalDisableDirective = directive;\n                        disabledRuleMap.clear();\n                        enabledRules.clear();\n                    } else if (currentGlobalDisableDirective) {\n                        enabledRules.delete(directive.ruleId);\n                        disabledRuleMap.set(directive.ruleId, directive);\n                    } else {\n                        disabledRuleMap.set(directive.ruleId, directive);\n                    }\n                    break;\n\n                case \"enable\":\n                    if (directive.ruleId === null) {\n                        currentGlobalDisableDirective = null;\n                        disabledRuleMap.clear();\n                    } else if (currentGlobalDisableDirective) {\n                        enabledRules.add(directive.ruleId);\n                        disabledRuleMap.delete(directive.ruleId);\n                    } else {\n                        disabledRuleMap.delete(directive.ruleId);\n                    }\n                    break;\n\n                // no default\n            }\n        }\n\n        if (disabledRuleMap.has(problem.ruleId)) {\n            usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));\n        } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {\n            usedDisableDirectives.add(currentGlobalDisableDirective);\n        } else {\n            problems.push(problem);\n        }\n    }\n\n    const unusedDisableDirectives = options.directives\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive))\n        .map(directive => ({\n            ruleId: null,\n            message: directive.ruleId\n                ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').`\n                : \"Unused eslint-disable directive (no problems were reported).\",\n            line: directive.unprocessedDirective.line,\n            column: directive.unprocessedDirective.column,\n            severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n            nodeType: null\n        }));\n\n    return { problems, unusedDisableDirectives };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, determines which problems should be reported.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @returns {{ruleId: (string|null), line: number, column: number}[]}\n * A list of reported problems that were not disabled by the directive comments.\n */\nmodule.exports = ({ directives, problems, reportUnusedDisableDirectives = \"off\" }) => {\n    const blockDirectives = directives\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\n        .sort(compareLocations);\n\n    const lineDirectives = lodash.flatMap(directives, directive => {\n        switch (directive.type) {\n            case \"disable\":\n            case \"enable\":\n                return [];\n\n            case \"disable-line\":\n                return [\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            case \"disable-next-line\":\n                return [\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            default:\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n        }\n    }).sort(compareLocations);\n\n    const blockDirectivesResult = applyDirectives({\n        problems,\n        directives: blockDirectives,\n        reportUnusedDisableDirectives\n    });\n    const lineDirectivesResult = applyDirectives({\n        problems: blockDirectivesResult.problems,\n        directives: lineDirectives,\n        reportUnusedDisableDirectives\n    });\n\n    return reportUnusedDisableDirectives !== \"off\"\n        ? lineDirectivesResult.problems\n            .concat(blockDirectivesResult.unusedDisableDirectives)\n            .concat(lineDirectivesResult.unusedDisableDirectives)\n            .sort(compareLocations)\n        : lineDirectivesResult.problems;\n};\n","/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        // Collapse whitespace around commas\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n            const trimmedName = name.trim();\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n};\n","/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(Boolean)) {\n                return lodash.union(...typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return lodash.intersection(...typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n    } catch (err) {\n        if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nconst parseSelector = lodash.memoize(rawSelector => {\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    return {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {SafeEmitter} emitter\n     * An SafeEmitter which is the destination of events. This emitter must already\n     * have registered listeners for all of the events that it needs to listen for.\n     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\n     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\n     * @returns {NodeEventGenerator} new instance\n     */\n    constructor(emitter, esqueryOptions) {\n        this.emitter = emitter;\n        this.esqueryOptions = esqueryOptions;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        emitter.eventNames().forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                selector.listenerTypes.forEach(nodeType => {\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n                return;\n            }\n            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n            selectors.push(selector);\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n","/**\n * @fileoverview An object that creates fix commands for rules.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates a fix command that inserts text at the specified index in the source text.\n * @param {int} index The 0-based index at which to insert the new text.\n * @param {string} text The text to insert.\n * @returns {Object} The fix command.\n * @private\n */\nfunction insertTextAt(index, text) {\n    return {\n        range: [index, index],\n        text\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates code fixing commands for rules.\n */\n\nconst ruleFixer = Object.freeze({\n\n    /**\n     * Creates a fix command that inserts text after the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfter(nodeOrToken, text) {\n        return this.insertTextAfterRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text after the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfterRange(range, text) {\n        return insertTextAt(range[1], text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBefore(nodeOrToken, text) {\n        return this.insertTextBeforeRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBeforeRange(range, text) {\n        return insertTextAt(range[0], text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceText(nodeOrToken, text) {\n        return this.replaceTextRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        return {\n            range,\n            text\n        };\n    },\n\n    /**\n     * Creates a fix command that removes the node or token from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.removeRange(nodeOrToken.range);\n    },\n\n    /**\n     * Creates a fix command that removes the specified range of text from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to remove, first item is start of range, second\n     *      is end of range.\n     * @returns {Object} The fix command.\n     */\n    removeRange(range) {\n        return {\n            range,\n            text: \"\"\n        };\n    }\n\n});\n\n\nmodule.exports = ruleFixer;\n","/**\n * @fileoverview Interpolate keys from an object into a string with {{ }} markers.\n * @author Jed Fox\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = (text, data) => {\n    if (!data) {\n        return text;\n    }\n\n    // Substitution content for any {{ }} markers.\n    return text.replace(/\\{\\{([^{}]+?)\\}\\}/gu, (fullMatch, termWithWhitespace) => {\n        const term = termWithWhitespace.trim();\n\n        if (term in data) {\n            return data[term];\n        }\n\n        // Preserve old behavior: If parameter name not provided, don't replace it.\n        return fullMatch;\n    });\n};\n","/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} [messageId]\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} [endLine]\n * @property {(number|undefined)} [endColumn]\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} [fix]\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\nfunction assertValidFix(fix) {\n    if (fix) {\n        assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n    }\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    for (const fix of fixes) {\n        assertValidFix(fix);\n    }\n\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n\n    assertValidFix(fix);\n    return fix;\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n        return [];\n    }\n\n    return descriptor.suggest\n        .map(suggestInfo => {\n            const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n\n            return {\n                ...suggestInfo,\n                desc: interpolate(computedDesc, suggestInfo.data),\n                fix: normalizeFixes(suggestInfo, sourceCode)\n            };\n        })\n\n        // Remove suggestions that didn't provide a fix\n        .filter(({ fix }) => fix);\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isn’t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    if (options.suggestions && options.suggestions.length > 0) {\n        problem.suggestions = options.suggestions;\n    }\n\n    return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n    if (suggest && Array.isArray(suggest)) {\n        suggest.forEach(suggestion => {\n            if (suggestion.messageId) {\n                const { messageId } = suggestion;\n\n                if (!messages) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n                }\n\n                if (!messages[messageId]) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n                }\n\n                if (suggestion.desc) {\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n                }\n            } else if (!suggestion.desc) {\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n            }\n\n            if (typeof suggestion.fix !== \"function\") {\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n            }\n        });\n    }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n        const messages = metadata.messageIds;\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!messages) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n        validateSuggestions(descriptor.suggest, messages);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: normalizeReportLoc(descriptor),\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n        });\n    };\n};\n","module.exports = new Map()\n","/**\n * @fileoverview Defines a storage for rules.\n * @author Nicholas C. Zakas\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst builtInRules = require(\"../rules\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Normalizes a rule module to the new-style API\n * @param {(Function|{create: Function})} rule A rule object, which can either be a function\n * (\"old-style\") or an object with a `create` method (\"new-style\")\n * @returns {{create: Function}} A new-style rule.\n */\nfunction normalizeRule(rule) {\n    return typeof rule === \"function\" ? Object.assign({ create: rule }, rule) : rule;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass Rules {\n    constructor() {\n        this._rules = Object.create(null);\n    }\n\n    /**\n     * Registers a rule module for rule id in storage.\n     * @param {string} ruleId Rule id (file name).\n     * @param {Function} ruleModule Rule handler.\n     * @returns {void}\n     */\n    define(ruleId, ruleModule) {\n        this._rules[ruleId] = normalizeRule(ruleModule);\n    }\n\n    /**\n     * Access rule handler by id (file name).\n     * @param {string} ruleId Rule id (file name).\n     * @returns {{create: Function, schema: JsonSchema[]}}\n     * A rule. This is normalized to always have the new-style shape with a `create` method.\n     */\n    get(ruleId) {\n        if (typeof this._rules[ruleId] === \"string\") {\n            this.define(ruleId, require(this._rules[ruleId]));\n        }\n        if (this._rules[ruleId]) {\n            return this._rules[ruleId];\n        }\n        if (builtInRules.has(ruleId)) {\n            return builtInRules.get(ruleId);\n        }\n\n        return null;\n    }\n\n    *[Symbol.iterator]() {\n        yield* builtInRules;\n\n        for (const ruleId of Object.keys(this._rules)) {\n            yield [ruleId, this.get(ruleId)];\n        }\n    }\n}\n\nmodule.exports = Rules;\n","/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\nmodule.exports = () => {\n    const listeners = Object.create(null);\n\n    return Object.freeze({\n        on(eventName, listener) {\n            if (eventName in listeners) {\n                listeners[eventName].push(listener);\n            } else {\n                listeners[eventName] = [listener];\n            }\n        },\n        emit(eventName, ...args) {\n            if (eventName in listeners) {\n                listeners[eventName].forEach(listener => listener(...args));\n            }\n        },\n        eventNames() {\n            return Object.keys(listeners);\n        }\n    });\n};\n","/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n","/**\n * @fileoverview Tracks performance of individual rules.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next */\n/**\n * Align the string to left\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignLeft(str, len, ch) {\n    return str + new Array(len - str.length + 1).join(ch || \" \");\n}\n\n/* istanbul ignore next */\n/**\n * Align the string to right\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignRight(str, len, ch) {\n    return new Array(len - str.length + 1).join(ch || \" \") + str;\n}\n\n//------------------------------------------------------------------------------\n// Module definition\n//------------------------------------------------------------------------------\n\nconst enabled = !!process.env.TIMING;\n\nconst HEADERS = [\"Rule\", \"Time (ms)\", \"Relative\"];\nconst ALIGN = [alignLeft, alignRight, alignRight];\n\n/**\n * Decide how many rules to show in the output list.\n * @returns {number} the number of rules to show\n */\nfunction getListSize() {\n    const MINIMUM_SIZE = 10;\n\n    if (typeof process.env.TIMING !== \"string\") {\n        return MINIMUM_SIZE;\n    }\n\n    if (process.env.TIMING.toLowerCase() === \"all\") {\n        return Number.POSITIVE_INFINITY;\n    }\n\n    const TIMING_ENV_VAR_AS_INTEGER = Number.parseInt(process.env.TIMING, 10);\n\n    return TIMING_ENV_VAR_AS_INTEGER > 10 ? TIMING_ENV_VAR_AS_INTEGER : MINIMUM_SIZE;\n}\n\n/* istanbul ignore next */\n/**\n * display the data\n * @param {Object} data Data object to be displayed\n * @returns {void} prints modified string with console.log\n * @private\n */\nfunction display(data) {\n    let total = 0;\n    const rows = Object.keys(data)\n        .map(key => {\n            const time = data[key];\n\n            total += time;\n            return [key, time];\n        })\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, getListSize());\n\n    rows.forEach(row => {\n        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);\n        row[1] = row[1].toFixed(3);\n    });\n\n    rows.unshift(HEADERS);\n\n    const widths = [];\n\n    rows.forEach(row => {\n        const len = row.length;\n\n        for (let i = 0; i < len; i++) {\n            const n = row[i].length;\n\n            if (!widths[i] || n > widths[i]) {\n                widths[i] = n;\n            }\n        }\n    });\n\n    const table = rows.map(row => (\n        row\n            .map((cell, index) => ALIGN[index](cell, widths[index]))\n            .join(\" | \")\n    ));\n\n    table.splice(1, 0, widths.map((width, index) => {\n        const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;\n\n        return ALIGN[index](\":\", width + extraAlignment, \"-\");\n    }).join(\"|\"));\n\n    console.log(table.join(\"\\n\")); // eslint-disable-line no-console\n}\n\n/* istanbul ignore next */\nmodule.exports = (function() {\n\n    const data = Object.create(null);\n\n    /**\n     * Time the run\n     * @param {*} key key from the data object\n     * @param {Function} fn function to be called\n     * @returns {Function} function to be executed\n     * @private\n     */\n    function time(key, fn) {\n        if (typeof data[key] === \"undefined\") {\n            data[key] = 0;\n        }\n\n        return function(...args) {\n            let t = process.hrtime();\n\n            fn(...args);\n            t = process.hrtime(t);\n            data[key] += t[0] * 1e3 + t[1] / 1e6;\n        };\n    }\n\n    if (enabled) {\n        process.on(\"exit\", () => {\n            display(data);\n        });\n    }\n\n    return {\n        time,\n        enabled,\n        getListSize\n    };\n\n}());\n","/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    path = require(\"path\"),\n    eslintScope = require(\"eslint-scope\"),\n    evk = require(\"eslint-visitor-keys\"),\n    espree = require(\"espree\"),\n    lodash = require(\"lodash\"),\n    BuiltInEnvironments = require(\"@eslint/eslintrc/conf/environments\"),\n    pkg = require(\"../../package.json\"),\n    astUtils = require(\"../shared/ast-utils\"),\n    ConfigOps = require(\"@eslint/eslintrc/lib/shared/config-ops\"),\n    ConfigValidator = require(\"@eslint/eslintrc/lib/shared/config-validator\"),\n    Traverser = require(\"../shared/traverser\"),\n    { SourceCode } = require(\"../source-code\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    applyDisableDirectives = require(\"./apply-disable-directives\"),\n    ConfigCommentParser = require(\"./config-comment-parser\"),\n    NodeEventGenerator = require(\"./node-event-generator\"),\n    createReportTranslator = require(\"./report-translator\"),\n    Rules = require(\"./rules\"),\n    createEmitter = require(\"./safe-emitter\"),\n    SourceCodeFixer = require(\"./source-code-fixer\"),\n    timing = require(\"./timing\"),\n    ruleReplacements = require(\"../../conf/replacements.json\");\n\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ConfigArray\"]>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ExtractedConfig\"]>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type\n * @property {number} line\n * @property {number} column\n * @property {(string|null)} ruleId\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor[\"postprocess\"]} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor[\"preprocess\"]} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    // mark all exported variables as such\n    Object.keys(exportedVariables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\nfunction createMissingRuleMessage(ruleId) {\n    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId)\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}`\n        : `Definition for rule '${ruleId}' was not found.`;\n}\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\nfunction createLintingProblem(options) {\n    const {\n        ruleId = null,\n        loc = DEFAULT_ERROR_LOC,\n        message = createMissingRuleMessage(options.ruleId),\n        severity = 2\n    } = options;\n\n    return {\n        ruleId,\n        message,\n        line: loc.start.line,\n        column: loc.start.column + 1,\n        endLine: loc.end.line,\n        endColumn: loc.end.column + 1,\n        severity,\n        nodeType: null\n    };\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {{line: number, column: number}} options.loc The 0-based location of the comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\nfunction createDisableDirectives(options) {\n    const { type, loc, value, ruleMapper } = options;\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\n    const directiveRules = ruleIds.length ? ruleIds : [null];\n    const result = {\n        directives: [], // valid disable directives\n        directiveProblems: [] // problems in directives\n    };\n\n    for (const ruleId of directiveRules) {\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n        if (ruleId === null || ruleMapper(ruleId) !== null) {\n            result.directives.push({ type, line: loc.start.line, column: loc.start.column + 1, ruleId });\n        } else {\n            result.directiveProblems.push(createLintingProblem({ ruleId, loc }));\n        }\n    }\n    return result;\n}\n\n/**\n * Remove the ignored part from a given directive comment and trim it.\n * @param {string} value The comment text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripDirectiveComment(value) {\n    return value.split(/\\s-{2,}\\s/u)[0].trim();\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {\n    const configuredRules = {};\n    const enabledGlobals = Object.create(null);\n    const exportedVariables = {};\n    const problems = [];\n    const disableDirectives = [];\n    const validator = new ConfigValidator({\n        builtInRules: Rules\n    });\n\n    ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n        const trimmedCommentText = stripDirectiveComment(comment.value);\n        const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(trimmedCommentText);\n\n        if (!match) {\n            return;\n        }\n        const directiveText = match[1];\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n        if (comment.type === \"Line\" && !lineCommentSupported) {\n            return;\n        }\n\n        if (warnInlineConfig) {\n            const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n                loc: comment.loc,\n                severity: 1\n            }));\n            return;\n        }\n\n        if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {\n            const message = `${directiveText} comment should not span multiple lines.`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message,\n                loc: comment.loc\n            }));\n            return;\n        }\n\n        const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);\n\n        switch (directiveText) {\n            case \"eslint-disable\":\n            case \"eslint-enable\":\n            case \"eslint-disable-next-line\":\n            case \"eslint-disable-line\": {\n                const directiveType = directiveText.slice(\"eslint-\".length);\n                const options = { type: directiveType, loc: comment.loc, value: directiveValue, ruleMapper };\n                const { directives, directiveProblems } = createDisableDirectives(options);\n\n                disableDirectives.push(...directives);\n                problems.push(...directiveProblems);\n                break;\n            }\n\n            case \"exported\":\n                Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n                break;\n\n            case \"globals\":\n            case \"global\":\n                for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n                    let normalizedValue;\n\n                    try {\n                        normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n                    } catch (err) {\n                        problems.push(createLintingProblem({\n                            ruleId: null,\n                            loc: comment.loc,\n                            message: err.message\n                        }));\n                        continue;\n                    }\n\n                    if (enabledGlobals[id]) {\n                        enabledGlobals[id].comments.push(comment);\n                        enabledGlobals[id].value = normalizedValue;\n                    } else {\n                        enabledGlobals[id] = {\n                            comments: [comment],\n                            value: normalizedValue\n                        };\n                    }\n                }\n                break;\n\n            case \"eslint\": {\n                const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n                if (parseResult.success) {\n                    Object.keys(parseResult.config).forEach(name => {\n                        const rule = ruleMapper(name);\n                        const ruleValue = parseResult.config[name];\n\n                        if (rule === null) {\n                            problems.push(createLintingProblem({ ruleId: name, loc: comment.loc }));\n                            return;\n                        }\n\n                        try {\n                            validator.validateRuleOptions(rule, name, ruleValue);\n                        } catch (err) {\n                            problems.push(createLintingProblem({\n                                ruleId: name,\n                                message: err.message,\n                                loc: comment.loc\n                            }));\n\n                            // do not apply the config, if found invalid options.\n                            return;\n                        }\n\n                        configuredRules[name] = ruleValue;\n                    });\n                } else {\n                    problems.push(parseResult.error);\n                }\n\n                break;\n            }\n\n            // no default\n        }\n    });\n\n    return {\n        configuredRules,\n        enabledGlobals,\n        exportedVariables,\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(ecmaVersion) {\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//gu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text)) !== null) {\n        retv = Object.assign(\n            retv || {},\n            commentParser.parseListConfig(stripDirectiveComment(match[1]))\n        );\n    }\n\n    return retv;\n}\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\nfunction normalizeFilename(filename) {\n    const parts = filename.split(path.sep);\n    const index = parts.lastIndexOf(\"<text>\");\n\n    return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions, config) {\n    const disableInlineConfig = config.noInlineConfig === true;\n    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig\n        ? ` (${config.configNameOfNoInlineConfig})`\n        : \"\";\n\n    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n    if (typeof reportUnusedDisableDirectives === \"boolean\") {\n        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n    }\n    if (typeof reportUnusedDisableDirectives !== \"string\") {\n        reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n    }\n\n    return {\n        filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n        allowInlineConfig: !ignoreInlineConfig,\n        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig\n            ? `your config${configNameOfNoInlineConfig}`\n            : null,\n        reportUnusedDisableDirectives,\n        disableFixes: Boolean(providedOptions.disableFixes)\n    };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {string} parserName The parser name which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\nfunction resolveParserOptions(parserName, providedOptions, enabledEnvironments) {\n    const parserOptionsFromEnv = enabledEnvironments\n        .filter(env => env.parserOptions)\n        .reduce((parserOptions, env) => lodash.merge(parserOptions, env.parserOptions), {});\n    const mergedParserOptions = lodash.merge(parserOptionsFromEnv, providedOptions || {});\n    const isModule = mergedParserOptions.sourceType === \"module\";\n\n    if (isModule) {\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\n    }\n\n    /*\n     * TODO: @aladdin-add\n     * 1. for a 3rd-party parser, do not normalize parserOptions\n     * 2. for espree, no need to do this (espree will do it)\n     */\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion);\n\n    return mergedParserOptions;\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n    return Object.assign(\n        {},\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\n        providedGlobals\n    );\n}\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig) {\n    if (Array.isArray(ruleConfig)) {\n        return ruleConfig.slice(1);\n    }\n    return [];\n\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {ParserOptions} parserOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, parserOptions, visitorKeys) {\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = parserOptions.ecmaVersion || 5;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion,\n        sourceType: parserOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: Traverser.getKeys\n    });\n}\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Parser} parser The parser to parse.\n * @param {ParserOptions} providedParserOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\nfunction parse(text, parser, providedParserOptions, filePath) {\n    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n    const parserOptions = Object.assign({}, providedParserOptions, {\n        loc: true,\n        range: true,\n        raw: true,\n        tokens: true,\n        comment: true,\n        eslintVisitorKeys: true,\n        eslintScopeManager: true,\n        filePath\n    });\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n    try {\n        const parseResult = (typeof parser.parseForESLint === \"function\")\n            ? parser.parseForESLint(textToParse, parserOptions)\n            : { ast: parser.parse(textToParse, parserOptions) };\n        const ast = parseResult.ast;\n        const parserServices = parseResult.services || {};\n        const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);\n\n        return {\n            success: true,\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n            sourceCode: new SourceCode({\n                text,\n                ast,\n                parserServices,\n                scopeManager,\n                visitorKeys\n            })\n        };\n    } catch (ex) {\n\n        // If the message includes a leading line number, strip it:\n        const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n        debug(\"%s\\n%s\", message, ex.stack);\n\n        return {\n            success: false,\n            error: {\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                message,\n                line: ex.lineNumber,\n                column: ex.column\n            }\n        };\n    }\n}\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @returns {eslint-scope.Scope} The scope information for this node\n */\nfunction getScope(scopeManager, currentNode) {\n\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== \"Program\";\n\n    for (let node = currentNode; node; node = node.parent) {\n        const scope = scopeManager.acquire(node, inner);\n\n        if (scope) {\n            if (scope.type === \"function-expression-name\") {\n                return scope.childScopes[0];\n            }\n            return scope;\n        }\n    }\n\n    return scopeManager.scopes[0];\n}\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\nfunction markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {\n    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;\n    const specialScope = hasGlobalReturn || parserOptions.sourceType === \"module\";\n    const currentScope = getScope(scopeManager, currentNode);\n\n    // Special Node.js scope means we need to start one level deeper\n    const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n    for (let scope = initialScope; scope; scope = scope.upper) {\n        const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n    try {\n        return rule.create(ruleContext);\n    } catch (ex) {\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n        throw ex;\n    }\n}\n\n/**\n * Gets all the ancestors of a given node\n * @param {ASTNode} node The node\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\n * from the root node and going inwards to the parent node.\n */\nfunction getAncestors(node) {\n    const ancestorsStartingAtParent = [];\n\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n        ancestorsStartingAtParent.push(ancestor);\n    }\n\n    return ancestorsStartingAtParent.reverse();\n}\n\n// methods that exist on SourceCode object\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n    getSource: \"getText\",\n    getSourceLines: \"getLines\",\n    getAllComments: \"getAllComments\",\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\n    getComments: \"getComments\",\n    getCommentsBefore: \"getCommentsBefore\",\n    getCommentsAfter: \"getCommentsAfter\",\n    getCommentsInside: \"getCommentsInside\",\n    getJSDocComment: \"getJSDocComment\",\n    getFirstToken: \"getFirstToken\",\n    getFirstTokens: \"getFirstTokens\",\n    getLastToken: \"getLastToken\",\n    getLastTokens: \"getLastTokens\",\n    getTokenAfter: \"getTokenAfter\",\n    getTokenBefore: \"getTokenBefore\",\n    getTokenByRangeStart: \"getTokenByRangeStart\",\n    getTokens: \"getTokens\",\n    getTokensAfter: \"getTokensAfter\",\n    getTokensBefore: \"getTokensBefore\",\n    getTokensBetween: \"getTokensBetween\"\n};\n\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(\n    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(\n        (contextInfo, methodName) =>\n            Object.assign(contextInfo, {\n                [methodName](...args) {\n                    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n                }\n            }),\n        {}\n    )\n);\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {Object} parserOptions The options that were passed to the parser\n * @param {string} parserName The name of the parser in the config\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @returns {Problem[]} An array of reported problems\n */\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n    const sharedTraversalContext = Object.freeze(\n        Object.assign(\n            Object.create(BASE_TRAVERSAL_CONTEXT),\n            {\n                getAncestors: () => getAncestors(currentNode),\n                getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n                getCwd: () => cwd,\n                getFilename: () => filename,\n                getScope: () => getScope(sourceCode.scopeManager, currentNode),\n                getSourceCode: () => sourceCode,\n                markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),\n                parserOptions,\n                parserPath: parserName,\n                parserServices: sourceCode.parserServices,\n                settings\n            }\n        )\n    );\n\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n        // not load disabled rules\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n\n        if (rule === null) {\n            lintingProblems.push(createLintingProblem({ ruleId }));\n            return;\n        }\n\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\n                Object.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n                        if (reportTranslator === null) {\n                            reportTranslator = createReportTranslator({\n                                ruleId,\n                                severity,\n                                sourceCode,\n                                messageIds,\n                                disableFixes\n                            });\n                        }\n                        const problem = reportTranslator(...args);\n\n                        if (problem.fix && rule.meta && !rule.meta.fixable) {\n                            throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = createRuleListeners(rule, ruleContext);\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            emitter.on(\n                selector,\n                timing.enabled\n                    ? timing.time(ruleId, ruleListeners[selector])\n                    : ruleListeners[selector]\n            );\n        });\n    });\n\n    // only run code path analyzer if the top level node is \"Program\", skip otherwise\n    const eventGenerator = nodeQueue[0].node.type === \"Program\"\n        ? new CodePathAnalyzer(new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys }))\n        : new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys });\n\n    nodeQueue.forEach(traversalInfo => {\n        currentNode = traversalInfo.node;\n\n        try {\n            if (traversalInfo.isEntering) {\n                eventGenerator.enterNode(currentNode);\n            } else {\n                eventGenerator.leaveNode(currentNode);\n            }\n        } catch (err) {\n            err.currentNode = currentNode;\n            throw err;\n        }\n    });\n\n    return lintingProblems;\n}\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\nfunction ensureText(textOrSourceCode) {\n    if (typeof textOrSourceCode === \"object\") {\n        const { hasBOM, text } = textOrSourceCode;\n        const bom = hasBOM ? \"\\uFEFF\" : \"\";\n\n        return bom + text;\n    }\n\n    return String(textOrSourceCode);\n}\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\nfunction getEnv(slots, envId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||\n        BuiltInEnvironments.get(envId) ||\n        null\n    );\n}\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\nfunction getRule(slots, ruleId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||\n        slots.ruleMap.get(ruleId)\n    );\n}\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\nfunction normalizeCwd(cwd) {\n    if (cwd) {\n        return cwd;\n    }\n    if (typeof process === \"object\") {\n        return process.cwd();\n    }\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined\n    return undefined;\n}\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\nconst internalSlotsMap = new WeakMap();\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nclass Linter {\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd]  path to a directory that should be considered as the current working directory, can be undefined.\n     */\n    constructor({ cwd } = {}) {\n        internalSlotsMap.set(this, {\n            cwd: normalizeCwd(cwd),\n            lastConfigArray: null,\n            lastSourceCode: null,\n            parserMap: new Map([[\"espree\", espree]]),\n            ruleMap: new Rules()\n        });\n\n        this.version = pkg.version;\n    }\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n    static get version() {\n        return pkg.version;\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(providedOptions, config);\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        // Resolve parser.\n        let parserName = DEFAULT_PARSER_NAME;\n        let parser = espree;\n\n        if (typeof config.parser === \"object\" && config.parser !== null) {\n            parserName = config.parser.filePath;\n            parser = config.parser.definition;\n        } else if (typeof config.parser === \"string\") {\n            if (!slots.parserMap.has(config.parser)) {\n                return [{\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Configured parser '${config.parser}' was not found.`,\n                    line: 0,\n                    column: 0\n                }];\n            }\n            parserName = config.parser;\n            parser = slots.parserMap.get(config.parser);\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = options.allowInlineConfig && !options.warnInlineConfig\n            ? findEslintEnv(text)\n            : {};\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\n            .filter(envName => resolvedEnvConfig[envName])\n            .map(envName => getEnv(slots, envName))\n            .filter(env => env);\n\n        const parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n        const settings = config.settings || {};\n\n        if (!slots.lastSourceCode) {\n            const parseResult = parse(\n                text,\n                parser,\n                parserOptions,\n                options.filename\n            );\n\n            if (!parseResult.success) {\n                return [parseResult.error];\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            if (!slots.lastSourceCode.scopeManager) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n        const commentDirectives = options.allowInlineConfig\n            ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig)\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\n\n        // augment global scope with declared global variables\n        addDeclaredGlobals(\n            sourceCode.scopeManager.scopes[0],\n            configuredGlobals,\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\n        );\n\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n\n        let lintingProblems;\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRule(slots, ruleId),\n                parserOptions,\n                parserName,\n                settings,\n                options.filename,\n                options.disableFixes,\n                slots.cwd\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = err.currentNode.loc.start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", parserOptions);\n            debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            directives: commentDirectives.disableDirectives,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n    }\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode, config, filenameOrOptions) {\n        debug(\"Verify\");\n        const options = typeof filenameOrOptions === \"string\"\n            ? { filename: filenameOrOptions }\n            : filenameOrOptions || {};\n\n        // CLIEngine passes a `ConfigArray` object.\n        if (config && typeof config.extractConfig === \"function\") {\n            return this._verifyWithConfigArray(textOrSourceCode, config, options);\n        }\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n        if (options.preprocess || options.postprocess) {\n            return this._verifyWithProcessor(textOrSourceCode, config, options);\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {LintMessage[]} The found problems.\n     */\n    _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n        debug(\"With ConfigArray: %s\", options.filename);\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n\n        // Extract the final config for this file.\n        const config = configArray.extractConfig(options.filename);\n        const processor =\n            config.processor &&\n            configArray.pluginProcessors.get(config.processor);\n\n        // Verify.\n        if (processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {LintMessage[]} The found problems.\n     */\n    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const text = ensureText(textOrSourceCode);\n        const preprocess = options.preprocess || (rawText => [rawText]);\n        const postprocess = options.postprocess || lodash.flatten;\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilename => blockFilename.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n        const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithoutProcessors(block, config, options);\n            }\n\n            const blockText = block.text;\n            const blockName = path.join(filename, `${i}_${block.filename}`);\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(blockName, blockText)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file extension was changed.\n            if (configForRecursive && path.extname(blockName) !== originalExtname) {\n                debug(\"Resolving configuration again because the file extension was changed.\");\n                return this._verifyWithConfigArray(\n                    blockText,\n                    configForRecursive,\n                    { ...options, filename: blockName }\n                );\n            }\n\n            // Does lint.\n            return this._verifyWithoutProcessors(\n                blockText,\n                config,\n                { ...options, filename: blockName }\n            );\n        });\n\n        return postprocess(messageLists, filenameToExpose);\n    }\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    getSourceCode() {\n        return internalSlotsMap.get(this).lastSourceCode;\n    }\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    defineRule(ruleId, ruleModule) {\n        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n    }\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    defineRules(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    }\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n    getRules() {\n        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* ruleMap;\n\n            if (lastConfigArray) {\n                yield* lastConfigArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n    defineParser(parserId, parserModule) {\n        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n    }\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n    verifyAndFix(text, config, options) {\n        let messages = [],\n            fixedResult,\n            fixed = false,\n            passNumber = 0,\n            currentText = text;\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n        do {\n            passNumber++;\n\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n            messages = this.verify(currentText, config, options);\n\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n            if (messages.length === 1 && messages[0].fatal) {\n                break;\n            }\n\n            // keep track if any fixes were ever applied - important for return value\n            fixed = fixed || fixedResult.fixed;\n\n            // update to use the fixed output instead of the original text\n            currentText = fixedResult.output;\n\n        } while (\n            fixedResult.fixed &&\n            passNumber < MAX_AUTOFIX_PASSES\n        );\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n        if (fixedResult.fixed) {\n            fixedResult.messages = this.verify(currentText, config, options);\n        }\n\n        // ensure the last result properly reflects if fixes were done\n        fixedResult.fixed = fixed;\n        fixedResult.output = currentText;\n\n        return fixedResult;\n    }\n}\n\nmodule.exports = {\n    Linter,\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n    getLinterInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n","\"use strict\";\n\nconst { Linter } = require(\"./linter\");\nconst interpolate = require(\"./interpolate\");\nconst SourceCodeFixer = require(\"./source-code-fixer\");\n\nmodule.exports = {\n    Linter,\n\n    // For testers.\n    SourceCodeFixer,\n    interpolate\n};\n"]}